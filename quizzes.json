[ {
  "question" : "UML 다이어그램 중 순차 다이어그램에 대한 설명으로 틀린 것은?",
  "answer" : "2.주로 시스템의 정적 측면을 모델링하기 위해 사용한다.",
  "commentary" : "정답은 \"주로 시스템의 정적 측면을 모델링하기 위해 사용한다.\" 이다. 순차 다이어그램은 객체 간의 동적 상호작용을 모델링하는 것이 주된 목적이며, 일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다. 회귀 메시지(Self-Message), 제어블록(Statement block) 등으로 구성된다. 따라서, 주로 시스템의 정적 측면을 모델링하기 위해 사용하는 것은 아니다.",
  "choices" : "1.객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링 하는 것이다./2.주로 시스템의 정적 측면을 모델링하기 위해 사용한다./3.일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다./4.회귀 메시지(Self-Message), 제어블록(Statement block) 등으로 구성된다./"
}, {
  "question" : "메시지 지향 미들웨어(Message-Oriented Middleware, MOM)에 대한 설명으로 틀린 것은?",
  "answer" : "1.느리고 안정적인 응답보다는 즉각적인 응답이 필요한 온라인 업무에 적합하다.",
  "commentary" : "\"느리고 안정적인 응답보다는 즉각적인 응답이 필요한 온라인 업무에 적합하다.\"가 틀린 것이다. MOM은 비동기 방식으로 작동하기 때문에 실시간성이 떨어지고, 안정적인 메시지 전달을 보장하기 위해 일정한 오버헤드가 발생한다. 따라서, 온라인 업무와 같이 즉각적인 응답이 필요한 경우에는 다른 방식의 미들웨어를 사용하는 것이 적합하다.",
  "choices" : "1.느리고 안정적인 응답보다는 즉각적인 응답이 필요한 온라인 업무에 적합하다./2.독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할을 한다./3.송신측과 수신측의 연결 시 메시지 큐를 활용하는 방법이 있다./4.상이한 애플리케이션 간 통신을 비동기 방식으로 지원한다./"
}, {
  "question" : "익스트림 프로그래밍에 대한 설명으로 틀린 것은?",
  "answer" : "1.대표적인 구조적 방법론 중 하나이다.",
  "commentary" : "\"대표적인 구조적 방법론 중 하나이다.\"가 틀린 것이다. 익스트림 프로그래밍은 구조적 방법론이 아니라 애자일 방법론에 속한다. 익스트림 프로그래밍은 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이며, 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다. 또한 구체적인 실천 방법을 정의하고 있으며, 개발 문서 보다는 소스코드에 중점을 둔다.",
  "choices" : "1.대표적인 구조적 방법론 중 하나이다./2.소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다./3.익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다./4.구체적인 실천 방법을 정의하고 있으며, 개발 문서 보다는 소스코드에 중점을 둔다./"
}, {
  "question" : "유스케이스(Use Case)의 구성 요소 간의 관계에 포함되지 않는 것은?",
  "answer" : "3.구체화",
  "commentary" : "유스케이스의 구성 요소 간의 관계에 포함되지 않는 것은 \"구체화\"이다. 이는 유스케이스의 구성 요소 중 하나인 액터와 유스케이스 간의 관계를 나타내는 것이 아니기 때문이다. 구체화는 유스케이스를 더 상세하게 분해하여 하위 유스케이스를 만드는 것을 의미한다.",
  "choices" : "1.연관/2.확장/3.구체화/4.일반화/"
}, {
  "question" : "요구사항 분석에서 비기능적(Nonfunctional) 요구에 대한 설명으로 옳은 것은?",
  "answer" : "2.'차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다'는 비기능적 요구이다.",
  "commentary" : "\"'차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다'는 비기능적 요구이다.\" 이유는 이 요구사항은 시스템의 성능과 관련된 요구사항으로, 시스템이 제공하는 기능 외에도 시스템의 성능과 품질에 대한 요구사항을 나타내기 때문이다.",
  "choices" : "1.시스템의 처리량(Throughput), 반응 시간 등의 성능 요구나 품질 요구는 비기능적 요구에 해당하지 않는다./2.'차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다'는 비기능적 요구이다./3.시스템 구축과 관련된 안전, 보안에 대한 요구사항들은 비기능적 요구에 해당하지 않는다./4.'금융 시스템은 조회, 인출, 입금, 송금의 기능이 있어야 한다'는 비기능적 요구이다./"
}, {
  "question" : "정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는?",
  "answer" : "4.Entity-Relationship Diagram",
  "commentary" : "Entity-Relationship Diagram은 데이터베이스 설계에서 가장 일반적으로 사용되는 모델링 언어이다. 이는 데이터베이스의 구조와 관계를 시각적으로 표현할 수 있으며, 엔티티(개체)와 관계(relationship)를 중심으로 모델링한다. 따라서 데이터베이스 설계의 표현으로 가장 적합하며, 다른 보기들은 시스템의 다른 측면을 모델링하는 데 사용된다.",
  "choices" : "1.Package Diagram/2.State Transition Diagram/3.Deployment Diagram/4.Entity-Relationship Diagram/"
}, {
  "question" : "미들웨어(Middleware)에 대한 설명으로 틀린 것은?",
  "answer" : "2.미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법 등의 내부 동작을 쉽게 확인할 수 있어야 한다.",
  "commentary" : "정답은 \"미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법 등의 내부 동작을 쉽게 확인할 수 있어야 한다.\" 이다. 이유는 미들웨어는 사용자와 직접적으로 상호작용하는 소프트웨어가 아니기 때문에 사용자가 내부 동작을 쉽게 확인할 필요가 없다. 오히려 미들웨어는 소프트웨어 컴포넌트를 연결하기 위한 인프라 구조를 제공하고, 여러 컴포넌트를 다양한 형태로 연결할 수 있도록 도와준다.",
  "choices" : "1.여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어이다./2.미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법 등의 내부 동작을 쉽게 확인할 수 있어야 한다./3.소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공한다./4.여러 컴포넌트를 1대 1, 1대 다, 다대 다 등 여러 가지 형태로 연결이 가능하다./"
}, {
  "question" : "UI의 설계 지침으로 틀린 것은?",
  "answer" : "3.치명적인 오류에 대한 부정적인 사항은 사용자가 인지할 수 없도록 한다.",
  "commentary" : "\"치명적인 오류에 대한 부정적인 사항은 사용자가 인지할 수 없도록 한다.\"가 틀린 설계 지침입니다. 사용자가 오류를 인지하지 못하면 문제가 발생했을 때 적절한 조치를 취할 수 없으므로, 오류 메시지나 경고를 표시하여 사용자가 인지할 수 있도록 해야 합니다.",
  "choices" : "1.이해하기 편하고 쉽게 사용할 수 있는 환경을 제공해야 한다./2.주요 기능을 메인 화면에 노출하여 조작이 쉽도록 하여야 한다./3.치명적인 오류에 대한 부정적인 사항은 사용자가 인지할 수 없도록 한다./4.사용자의 직무, 연령, 성별 등 다양한 계층을 수용하여야 한다./"
}, {
  "question" : "객체지향 개념에서 다형성(Polymorphism)과 관련한 설명으로 틀린 것은?",
  "answer" : "4.메소드 오버로딩(Overloading)의 경우 매개 변수 타입은 동일하지만 메소드명을 다르게 함으로써 구현, 구분할 수 있다.",
  "commentary" : "정답은 \"메소드 오버로딩(Overloading)의 경우 매개 변수 타입은 동일하지만 메소드명을 다르게 함으로써 구현, 구분할 수 있다.\" 이다. 메소드 오버로딩은 매개 변수의 개수나 타입이 다른 여러 개의 메소드를 같은 이름으로 정의하는 것이다. 이를 통해 같은 기능을 하는 메소드를 다양한 매개 변수로 호출할 수 있게 된다.",
  "choices" : "1.다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다./2.다형성이란 여러 가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말한다./3.메소드 오버라이딩(Overriding)은 상위 클래스에서 정의한 일반 메소드의 구현을 하위 클래스에서 무시하고 재정의할 수 있다./4.메소드 오버로딩(Overloading)의 경우 매개 변수 타입은 동일하지만 메소드명을 다르게 함으로써 구현, 구분할 수 있다./"
}, {
  "question" : "소프트웨어 개발 영역을 결정하는 요소 중 다음 사항과 관계있는 것은?",
  "answer" : "4.인터페이스(Interface)",
  "commentary" : "인터페이스는 소프트웨어 시스템의 다른 부분과 상호작용하기 위한 규약을 정의하는 요소이다. 따라서 소프트웨어 개발 영역을 결정하는 요소 중에서는 인터페이스가 다른 부분과의 상호작용을 결정하므로 인터페이스와 관련이 있다.",
  "choices" : "1.기능(Function)/2.성능(Performance)/3.제약 조건(Constraint)/4.인터페이스(Interface)/"
}, {
  "question" : "객체에 대한 설명으로 틀린 것은?",
  "answer" : "2.객체는 공통 속성을 공유하는 클래스들의 집합이다.",
  "commentary" : "\"객체는 공통 속성을 공유하는 클래스들의 집합이다.\"가 틀린 설명입니다. 객체는 클래스의 인스턴스이며, 클래스는 객체를 정의하는 틀이라고 할 수 있습니다. 따라서 객체는 클래스에 의해 정의되며, 클래스들의 집합이 아닙니다. 객체는 상태, 동작, 고유 식별자를 가진 모든 것이라 할 수 있으며, 필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 독립된 존재입니다. 객체의 상태는 속성값에 의해 정의됩니다.",
  "choices" : "1.객체는 상태, 동작, 고유 식별자를 가진 모든 것이라 할 수 있다./2.객체는 공통 속성을 공유하는 클래스들의 집합이다./3.객체는 필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 독립된 존재이다./4.객체의 상태는 속성값에 의해 정의된다./"
}, {
  "question" : "속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것을 의미하는 객체지향 개념은?",
  "answer" : "3.Encapsulation",
  "commentary" : "Encapsulation은 클래스 안에 속성과 관련된 연산을 묶어서 하나의 단위로 취급하는 객체지향 개념입니다. 이를 통해 속성과 연산이 서로 영향을 주지 않고 독립적으로 작동할 수 있으며, 코드의 가독성과 유지보수성이 향상됩니다. 따라서 Encapsulation이 정답입니다.",
  "choices" : "1.Inheritance/2.Class/3.Encapsulation/4.Association/"
}, {
  "question" : "애자일(Agile) 프로세스 모델에 대한 설명으로 틀린 것은?",
  "answer" : "1.변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다.",
  "commentary" : "\"변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다.\"가 틀린 것이다. 애자일 프로세스 모델은 변화에 대한 대응을 중요시하며, 계획보다는 실행 가능한 소프트웨어를 중시한다. 이는 고객의 요구사항이나 프로젝트 진행 중 발생하는 변화에 빠르게 대응하며, 지속적으로 소프트웨어를 개선해 나가는 것을 목표로 한다.",
  "choices" : "1.변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다./2.프로세스와 도구 중심이 아닌 개개인과의 상호소통을 통해 의견을 수렴한다./3.협상과 계약보다는 고객과의 협력을 중시한다./4.문서 중심이 아닌, 실행 가능한 소프트웨어를 중시한다./"
}, {
  "question" : "명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있는 것은?",
  "answer" : "3.Component",
  "commentary" : "인터페이스를 통해서만 접근할 수 있는 시스템의 부분은 Component이다. Component는 명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로, 다른 시스템에서도 재사용될 수 있는 단위이다. 따라서 인터페이스를 통해서만 접근할 수 있으며, 다른 보기인 Model, Sheet, Cell은 Component가 아니므로 정답이 될 수 없다.",
  "choices" : "1.Model/2.Sheet/3.Component/4.Cell/"
}, {
  "question" : "GoF(Gang of Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때, 구조 패턴이 아닌 것은?",
  "answer" : "3.Builder 패턴",
  "commentary" : "Builder 패턴은 생성 패턴에 속하며, 객체 생성 과정을 추상화하여 복잡한 객체를 생성하는 방법을 제공합니다. 따라서 구조 패턴이 아닌 생성 패턴입니다. 반면, Adapter 패턴, Bridge 패턴, Proxy 패턴은 모두 구조 패턴에 속합니다. Adapter 패턴은 인터페이스를 변환하여 호환성을 제공하고, Bridge 패턴은 추상화와 구현을 분리하여 유연성을 제공하며, Proxy 패턴은 객체에 대한 대리자를 제공하여 접근 제어 및 부가 기능을 제공합니다.",
  "choices" : "1.Adapter 패턴/2.Bridge 패턴/3.Builder 패턴/4.Proxy 패턴/"
}, {
  "question" : "UI와 관련된 기본 개념 중 하나로, 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있도록 도와주는 것은?",
  "answer" : "1.Feedback",
  "commentary" : "\"Feedback\"은 사용자가 시스템에 명령을 내린 후 시스템이 그 명령을 받아들이고 처리하는 과정에서 사용자에게 상태와 결과를 보여주는 것을 말합니다. 이는 사용자가 명령을 내린 후 시스템이 작동 중인지, 명령이 처리되고 있는지 등을 파악할 수 있도록 도와주는 중요한 UI 개념입니다.",
  "choices" : "1.Feedback/2.Posture/3.Module/4.Hash/"
}, {
  "question" : "UI의 종류로 멀티 터치(Multi-touch), 동작 인식(Gesture Recognition) 등 사용자의 자연스러운 움직임을 인식하여 서로 주고받는 정보를 제공하는 사용자 인터페이스를 의미하는 것은?",
  "answer" : "3.NUI(Natural User Interface)",
  "commentary" : "NUI는 사용자의 자연스러운 움직임을 인식하여 정보를 제공하는 사용자 인터페이스를 의미한다. 다른 인터페이스들은 사용자가 키보드나 마우스 등을 이용하여 명령을 입력하는 방식이지만, NUI는 사용자의 몸짓이나 손가락 움직임 등을 인식하여 명령을 입력받는다. 이러한 특징으로 인해 NUI는 사용자와 컴퓨터 간의 상호작용을 더욱 자연스럽고 직관적으로 만들어준다.",
  "choices" : "1.GUI(Graphical User Interface)/2.OUI(Organic User Interface)/3.NUI(Natural User Interface)/4.CLI(Command Line Interface)/"
}, {
  "question" : "소프트웨어 모델링과 관련한 설명으로 틀린 것은?",
  "answer" : "1.모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 없다.",
  "commentary" : "\"모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 없다.\"는 틀린 설명입니다. 모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 있으며, 이전 모델링 작업의 결과물을 바탕으로 새로운 모델링 작업을 수행하기도 합니다. 예를 들어, 요구사항 모델링 작업의 결과물인 유스케이스 다이어그램은 설계 모델링 작업에서도 활용될 수 있습니다.",
  "choices" : "1.모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 없다./2.구조적 방법론에서는 DFD(Data Flow Diagram), DD(Data Dictionary) 등을 사용하여 요구 사항의 결과를 표현한다./3.객체지향 방법론에서는 UML 표기법을 사용한다./4.소프트웨어 모델을 사용할 경우 개발될 소프트웨어에 대한 이해도 및 이해 당사자 간의 의사소통 향상에 도움이 된다./"
}, {
  "question" : "유스케이스 다이어그램(Use Case Diagram)에 관련된 내용으로 틀린 것은?",
  "answer" : "1.시스템과 상호작용하는 외부시스템은 액터로 파악해서는 안된다.",
  "commentary" : "\"시스템과 상호작용하는 외부시스템은 액터로 파악해서는 안된다.\"이 틀린 내용이다. 외부 시스템은 시스템과 상호작용하는 주체로서 액터로 파악해야 한다.",
  "choices" : "1.시스템과 상호작용하는 외부시스템은 액터로 파악해서는 안된다./2.유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다./3.시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말한다./4.액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다./"
}, {
  "question" : "소프트웨어 아키텍처 모델 중 MVC(Model-View-Controller)와 관련한 설명으로 틀린 것은?",
  "answer" : "2.모델(Model)은 뷰(View)와 제어(Controller) 사이에서 전달자 역할을 하며, 뷰마다 모델 서브시스템이 각각 하나씩 연결된다.",
  "commentary" : "정답은 \"모델(Model)은 뷰(View)와 제어(Controller) 사이에서 전달자 역할을 하며, 뷰마다 모델 서브시스템이 각각 하나씩 연결된다.\"가 아니다. MVC 모델에서 모델(Model)은 뷰(View)와 제어(Controller)와 독립적으로 존재하며, 데이터와 비즈니스 로직을 처리하는 역할을 한다. 뷰(View)는 모델(Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당하고, 제어(Controller)는 사용자의 입력을 받아 모델(Model)에 명령을 보냄으로써 모델의 상태를 변경할 수 있다. 따라서 모델(Model)은 뷰(View)와 제어(Controller) 사이에서 전달자 역할을 하는 것이 아니라, 독립적으로 존재하며 중재자 역할을 한다고 볼 수 있다.",
  "choices" : "1.MVC 모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있다./2.모델(Model)은 뷰(View)와 제어(Controller) 사이에서 전달자 역할을 하며, 뷰마다 모델 서브시스템이 각각 하나씩 연결된다./3.뷰(View)는 모델(Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당한다./4.제어(Controller)는 모델(Model)에 명령을 보냄으로써 모델의 상태를 변경할 수 있다./"
}, {
  "question" : "통합 테스트(Integration Test)와 관련한 설명으로 틀린 것은?",
  "answer" : "3.상향식 통합 테스트의 경우 시스템 구조도의 최상위에 있는 모듈을 먼저 구현하고 테스트한다.",
  "commentary" : "\"상향식 통합 테스트의 경우 시스템 구조도의 최상위에 있는 모듈을 먼저 구현하고 테스트한다.\"이 부분이 틀린 설명입니다. 상향식 통합 테스트는 하위 모듈부터 순차적으로 테스트를 진행하는 방식이며, 최상위 모듈은 마지막에 테스트됩니다. 이는 모듈 간의 의존성을 고려하여 하위 모듈이 먼저 테스트되어야 하기 때문입니다.",
  "choices" : "1.시스템을 구성하는 모듈의 인터페이스와 결합을 테스트하는 것이다./2.하향식 통합 테스트의 경우 넓이 우선(Breadth First) 방식으로 테스트를 할 모듈을 선택할 수 있다./3.상향식 통합 테스트의 경우 시스템 구조도의 최상위에 있는 모듈을 먼저 구현하고 테스트한다./4.모듈 간의 인터페이스와 시스템의 동작이 정상적으로 잘되고 있는지를 빨리 파악하고자 할 때 상향식 보다는 하향식 통합 테스트를 사용하는 것이 좋다./"
}, {
  "question" : "다음과 같이 레코드가 구성되어 있을 때, 이진 검색 방법으로 14를 찾을 경우 비교되는 횟수는?",
  "answer" : "2.3",
  "commentary" : "이진 검색 방법은 중앙값을 기준으로 탐색 범위를 반으로 줄여가며 찾는 방법이다. 따라서 처음에는 중앙값인 8과 비교하게 된다. 14는 8보다 크므로 오른쪽 부분 배열을 탐색하면서 중앙값인 12와 비교하게 된다. 14는 12보다 크므로 다시 오른쪽 부분 배열을 탐색하면서 중앙값인 14와 비교하게 된다. 이때 14를 찾았으므로 총 3번의 비교가 이루어진다. 따라서 정답은 \"3\"이다.",
  "choices" : "1.2/2.3/3.4/4.5/"
}, {
  "question" : "소프트웨어 공학에서 워크스루(Walktiirough)에 대한 설명으로 틀린 것은?",
  "answer" : "3.인스펙션(Inspection)과 동일한 의미를 가진다.",
  "commentary" : "\"인스펙션(Inspection)과 동일한 의미를 가진다.\"는 틀린 설명입니다. 워크스루(Walkthrough)는 인스펙션과는 다른 소프트웨어 검토 기법 중 하나로, 검토 대상에 대한 이해도를 높이기 위해 작성자나 다른 팀원들이 설명하면서 진행하는 검토 방법입니다. 인스펙션은 보다 엄격하고 체계적인 검토 방법으로, 미리 정해진 규칙에 따라 검토를 수행합니다.",
  "choices" : "1.사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용할 수 있다./2.복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다./3.인스펙션(Inspection)과 동일한 의미를 가진다./4.단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것이다./"
}, {
  "question" : "소프트웨어의 개발과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동을 뜻하는 것은?",
  "answer" : "2.형상관리",
  "commentary" : "소프트웨어의 개발과정에서는 여러 명이 함께 작업하고, 소스코드가 계속해서 변경되기 때문에 이를 효율적으로 관리하기 위해 형상관리가 필요합니다. 형상관리는 소스코드의 버전을 관리하고, 변경사항을 추적하며, 충돌을 방지하고, 팀원들 간의 협업을 원활하게 하는 등의 일련의 활동을 의미합니다. 따라서, \"형상관리\"가 정답입니다.",
  "choices" : "1.복호화/2.형상관리/3.저작권/4.크랙/"
}, {
  "question" : "테스트 케이스와 관련한 설명으로 틀린 것은?",
  "answer" : "1.테스트의 목표 및 테스트 방법을 결정하기 전에 테스트 케이스를 작성해야 한다.",
  "commentary" : "\"테스트의 목표 및 테스트 방법을 결정하기 전에 테스트 케이스를 작성해야 한다.\"가 틀린 것이다. 테스트의 목표와 방법을 결정한 후에 테스트 케이스를 작성해야 한다. 테스트 케이스는 목표와 방법을 바탕으로 작성되며, 입력 값과 실행 조건, 예상 결과의 집합으로 볼 수 있다. 이를 통해 개발된 서비스가 정의된 요구 사항을 준수하는지 확인할 수 있다. 또한, 프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요하다. 마지막으로, 테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트 오라클(Test Oracle)이라고 한다.",
  "choices" : "1.테스트의 목표 및 테스트 방법을 결정하기 전에 테스트 케이스를 작성해야 한다./2.프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요하다./3.개발된 서비스가 정의된 요구 사항을 준수하는지 확인하기 위한 입력 값과 실행 조건, 예상 결과의 집합으로 볼 수 있다./4.테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트 오라클(Test Oracle)이라고 한다./"
}, {
  "question" : "객체지향 개념을 활용한 소프트웨어 구현과 관련한 설명 중 틀린 것은?",
  "answer" : "2.JAVA에서 정보은닉(Information Hiding)을 표기할 때 private의 의미는 '공개'이다.",
  "commentary" : "JAVA에서 정보은닉(Information Hiding)을 표기할 때 private의 의미는 '공개'가 아니라 '비공개'이다. private로 선언된 변수나 메소드는 해당 클래스 내부에서만 접근이 가능하고, 외부에서는 접근할 수 없다. 이는 객체지향 프로그래밍에서 중요한 개념 중 하나로, 객체의 내부 구현을 외부로부터 감추어 정보를 보호하고 객체 간의 결합도를 낮추는 역할을 한다.",
  "choices" : "1.객체(Object)란 필요한 자료 구조와 수행되는 함수들을 가진 하나의 독립된 존재이다./2.JAVA에서 정보은닉(Information Hiding)을 표기할 때 private의 의미는 '공개'이다./3.상속(Inheritance)은 개별 클래스를 상속 관계로 묶음으로써 클래스 간의 체계화된 전체 구조를 파악하기 쉽다는 장점이 있다./4.같은 클래스에 속하는 개개의 객체이자 하나의 클래스에서 생성된 객체를 인스턴스(Instance)라고 한다./"
}, {
  "question" : "DRM(Digital Rights Management)과 관련한 설명으로 틀린 것은?",
  "answer" : "4.원본을 안전하게 유통하기 위한 전자적 보안은 고려하지 않기 때문에 불법 유통과 복제의 방지는 불가능하다.",
  "commentary" : "\"원본을 안전하게 유통하기 위한 전자적 보안은 고려하지 않기 때문에 불법 유통과 복제의 방지는 불가능하다.\"가 틀린 설명이다. DRM은 디지털 콘텐츠의 불법 복제와 유통을 방지하기 위한 기술로, 디지털 콘텐츠를 암호화하고 접근 제어를 설정하여 불법 복제와 유통을 방지한다. 따라서 전자적 보안을 고려하여 불법 복제와 유통을 방지할 수 있다.",
  "choices" : "1.디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근 제어 기술을 의미한다./2.디지털 미디어의 생명 주기 동안 발생하는 사용 권한 관리, 과금, 유통 단계를 관리하는 기술로도 볼 수 있다./3.클리어링 하우스(Clearing House)는 사용자에게 콘텐츠 라이센스를 발급하고 권한을 부여해주는 시스템을 말한다./4.원본을 안전하게 유통하기 위한 전자적 보안은 고려하지 않기 때문에 불법 유통과 복제의 방지는 불가능하다./"
}, {
  "question" : "위험 모니터링의 의미로 옳은 것은?",
  "answer" : "4.위험 요소 징후들에 대하여 계속적으로 인지하는 것",
  "commentary" : "위험 모니터링은 위험 요소 징후들에 대하여 계속적으로 인지하는 것을 의미합니다. 이는 위험을 이해하고 첫 번째 조치로 위험을 피할 수 있도록 하는 것과 함께, 위험 발생 후 즉시 조치하는 것의 전제 조건이 됩니다. 따라서 위험 모니터링은 위험을 예방하고 대처하는 데 매우 중요한 역할을 합니다.",
  "choices" : "1.위험을 이해하는 것/2.첫 번째 조치로 위험을 피할 수 있도록 하는 것/3.위험 발생 후 즉시 조치하는 것/4.위험 요소 징후들에 대하여 계속적으로 인지하는 것/"
}, {
  "question" : "동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는?",
  "answer" : "1.RCS(Revision Control System)",
  "commentary" : "RCS는 소스 코드의 버전을 관리하고 변경 내용을 추적할 수 있는 도구로, 동시에 소스를 수정하는 것을 방지하여 충돌을 방지할 수 있습니다. 또한 다른 개발자들이 작업한 내용을 합치거나 변경 내용을 추적할 수 있어 협업에 용이합니다. 따라서 RCS가 정답입니다.",
  "choices" : "1.RCS(Revision Control System)/2.RTS(Reliable Transfer Service)/3.RPC(Remote Procedure Call)/4.RVS(Relative Version System)/"
}, {
  "question" : "화이트박스 테스트와 관련한 설명으로 틀린 것은?",
  "answer" : "3.프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정한다.",
  "commentary" : "\"프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정한다.\"이 부분이 틀린 것이 아니라 옳은 것입니다. 화이트박스 테스트는 프로그램의 내부 구조를 고려하여 테스트 케이스를 결정하는 방법이 아니라, 프로그램의 요구사항이나 명세를 기반으로 테스트 케이스를 결정합니다. 이는 블랙박스 테스트와 대조되는 개념입니다.",
  "choices" : "1.화이트박스 테스트의 이해를 위해 논리흐름도(Logic-Flow Diagram)를 이용할 수 있다./2.테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는 동적 테스트(Dynamic Test)에 해당한다./3.프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정한다./4.테스트 데이터를 선택하기 위하여 검증기준(Test Coverage)을 정한다./"
}, {
  "question" : "알고리즘과 관련한 설명으로 틀린 것은?",
  "answer" : "4.선형 검색은 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.",
  "commentary" : "\"선형 검색은 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.\"는 틀린 설명입니다. 선형 검색은 정렬되지 않은 데이터에서도 검색이 가능합니다. 다만, 정렬되지 않은 데이터에서 검색을 수행할 경우에는 모든 데이터를 순서대로 비교해야 하기 때문에 검색 속도가 느릴 수 있습니다.",
  "choices" : "1.주어진 작업을 수행하는 컴퓨터 명령어를 순서대로 나열한 것으로 볼 수 있다./2.검색(Searching)은 정렬이 되지 않은 데이터 혹은 정렬이 된 데이터 중에서 키값에 해당되는 데이터를 찾는 알고리즘이다./3.정렬(Sorting)은 흩어져있는 데이터를 키값을 이용하여 순서대로 열거하는 알고리즘이다./4.선형 검색은 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다./"
}, {
  "question" : "버블 정렬을 이용하여 다음 자료를 오름차순으로 정렬할 경우 PASS 1의 결과는?",
  "answer" : "4.6, 7, 3, 5, 9",
  "commentary" : null,
  "choices" : "1.6, 9, 7, 3, 5/2.3, 9, 6, 7, 5/3.3, 6, 7, 9, 5/4.6, 7, 3, 5, 9/"
}, {
  "question" : "다음은 인스펙션(Inspection) 과정을 표현한 것이다. (가)~(마)에 들어갈 말을 보기에서 찾아 바르게 연결한 것은?",
  "answer" : "2.(나) - ㉠, (다) - ㉢",
  "commentary" : "(가)에서는 \"검사 대상\"을 선정하고, (나)에서는 \"검사 항목\"을 선정한다. 이는 검사 대상을 선정한 후에 어떤 항목을 검사할 것인지를 결정하기 때문에 (나) - ㉠, (다) - ㉢가 올바른 연결이다.",
  "choices" : "1.(가) - ㉡, (나) - ㉢/2.(나) - ㉠, (다) - ㉢/3.(다) - ㉢, (라) - ㉤/4.(라) - ㉣, (마) - ㉢/"
}, {
  "question" : "소프트웨어를 보다 쉽게 이해할 수 있고 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부구조를 변경하는 것은?",
  "answer" : "1.Refactoring",
  "commentary" : "Refactoring은 소프트웨어의 내부 구조를 변경하면서도 겉으로 보이는 동작의 변화가 없도록 하는 작업입니다. 이를 통해 소프트웨어를 보다 쉽게 이해하고 유지보수할 수 있으며, 비용도 절감할 수 있습니다. 따라서 이 문제에서 정답은 Refactoring입니다.",
  "choices" : "1.Refactoring/2.Architecting/3.Specification/4.Renewal/"
}, {
  "question" : "단위 테스트(Unit Test)와 관련한 설명으로 틀린 것은?",
  "answer" : "3.필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 스텁(Stub)이라고 한다.",
  "commentary" : "정답은 \"모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.\"이다. 테스트 스텁(Stub)은 필요 데이터를 인자로 받아 처리하고, 그 결과값을 반환하는 가상의 모듈로, 실제 모듈과 같은 인터페이스를 가지고 있어서 테스트할 모듈을 호출하는 모듈이 테스트 스텁을 호출하면 마치 실제 모듈을 호출하는 것과 같은 결과를 반환한다. 단위 테스트(Unit Test)는 개발자가 작성한 코드의 각 모듈이 예상대로 동작하는지 검증하는 테스트이며, 구현 단계에서 각 모듈의 개발을 완료한 후 명세서의 내용대로 정확히 구현되었는지 테스트한다. 따라서 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트보다는 인터페이스를 중심으로 테스트를 진행한다.",
  "choices" : "1.구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다./2.모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다./3.필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 스텁(Stub)이라고 한다./4.테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다./"
}, {
  "question" : "IDE(Integrated Development Environment) 도구의 각 기능에 대한 설명으로 틀린 것은?",
  "answer" : "2.Compile - 저급언어의 프로그램을 고급언어 프로그램으로 변환하는 기능",
  "commentary" : "정답은 \"Compile - 저급언어의 프로그램을 고급언어 프로그램으로 변환하는 기능\"입니다. 이유는 IDE 도구에서 Compile 기능은 고급언어로 작성된 소스 코드를 컴파일하여 실행 가능한 저급언어 코드로 변환하는 기능입니다. 즉, 고급언어 프로그램을 저급언어 프로그램으로 변환하는 것이 맞습니다.",
  "choices" : "1.Coding - 프로그래밍 언어를 가지고 컴퓨터 프로그램을 작성할 수 있는 환경을 제공/2.Compile - 저급언어의 프로그램을 고급언어 프로그램으로 변환하는 기능/3.Debugging - 프로그램에서 발견되는 버그를 찾아 수정할 수 있는 기능/4.Deployment - 소프트웨어를 최종 사용자에게 전달하기 위한 기능/"
}, {
  "question" : "아래 Tree 구조에 대하여 후위 순회(Postorder) 한 결과는?",
  "answer" : "2.d → b → g → h → e → f → c → a",
  "commentary" : "후위 순회(Postorder)는 왼쪽 자식 → 오른쪽 자식 → 부모 순서로 방문하는 것입니다. 따라서, 위의 Tree 구조를 후위 순회하면 d → b → g → h → e → f → c → a 순서로 방문하게 됩니다.",
  "choices" : "1.a → b → d → c → e → g → h → f/2.d → b → g → h → e → f → c → a/3.d → b → a → g → e → h → c → f/4.a → b → d → g → e → h → c → f/"
}, {
  "question" : "인터페이스 구현 시 사용하는 기술로 속성-값 쌍(Attribute-Value Pairs)으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷은?",
  "answer" : "1.JSON",
  "commentary" : "JSON은 JavaScript Object Notation의 약자로, JavaScript에서 객체를 표현하는 방식을 따르는 개방형 표준 포맷이다. 이를 이용하여 데이터를 속성-값 쌍으로 표현하고 전달할 수 있어 인터페이스 구현 시 많이 사용된다. 또한, JSON은 가벼우면서도 읽기 쉽고 파싱하기도 용이하여 많은 언어에서 지원되고 있다.",
  "choices" : "1.JSON/2.HTML/3.AVPN/4.DOF/"
}, {
  "question" : "순서가 있는 리스트에서 데이터의 삽입(Push), 삭제(Pop)가 한 쪽 끝에서 일어나며 LIFO(Last-In-First-Out)의 특징을 가지는 자료구조는?",
  "answer" : "3.Stack",
  "commentary" : "Stack은 LIFO(Last-In-First-Out)의 특징을 가지며, 데이터의 삽입과 삭제가 한 쪽 끝에서 일어나는 순서가 있는 리스트 자료구조이기 때문에 정답입니다. Tree와 Graph는 비선형 자료구조이며, Queue는 FIFO(First-In-First-Out)의 특징을 가지는 자료구조입니다.",
  "choices" : "1.Tree/2.Graph/3.Stack/4.Queue/"
}, {
  "question" : "다음 중 단위 테스트 도구로 사용될 수 없는 것은?",
  "answer" : "4.IgpUnit",
  "commentary" : "정답은 \"IgpUnit\"입니다. 이유는 IgpUnit이라는 도구는 존재하지 않기 때문입니다. CppUnit은 C++ 언어를 위한 단위 테스트 도구이고, JUnit은 Java 언어를 위한 단위 테스트 도구입니다. HttpUnit은 웹 애플리케이션의 단위 테스트를 위한 도구입니다. 하지만 IgpUnit은 존재하지 않는 도구이므로 단위 테스트 도구로 사용될 수 없습니다.",
  "choices" : "1.CppUnit/2.JUnit/3.HttpUnit/4.IgpUnit/"
}, {
  "question" : "다음 조건을 모두 만족하는 정규형은?",
  "answer" : "1.BCNF",
  "commentary" : "1. 제1정규형: 모든 속성은 원자값(Atomic Value)을 가지고 있어야 한다. - 위의 스키마는 모든 속성이 원자값을 가지고 있으므로 제1정규형을 만족한다. 2. 제2정규형: 기본키가 아닌 모든 속성이 기본키에 대해 완전 함수 종속을 만족해야 한다. - 위의 스키마에서는 기본키가 {A, B} 이므로, C가 A에 대해 완전 함수 종속을 만족하지 않는다. 따라서 제2정규형을 만족하지 않는다. 3. 제3정규형: 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수 종속을 만족하지 않아야 한다. - 위의 스키마에서는 기본키가 {A, B} 이고, C가 A에 대해 이행적 함수 종속을 만족하지 않으므로 제3정규형을 만족한다. 4. BCNF: 모든 결정자가 후보키이어야 한다. - 위의 스키마에서는 C가 후보키가 아니지만, A와 B가 모두 기본키이므로 모든 결정자가 후보키이다. 따라서 BCNF를 만족한다. 따라서, 위의 스키마는 BCNF를 만족한다.",
  "choices" : "1.BCNF/2.제1정규형/3.제2정규형/4.제3정규형/"
}, {
  "question" : "데이터베이스의 트랜잭션 성질들 중에서 다음 설명에 해당하는 것은?",
  "answer" : "1.Atomicity",
  "commentary" : "트랜잭션의 Atomicity는 \"원자성\"을 의미합니다. 즉, 트랜잭션 내의 모든 작업이 전부 성공하거나 전부 실패해야 한다는 것을 보장합니다. 위의 그림에서는 \"Transfer 1000 from A to B\"라는 작업이 실패하면 \"Transfer 1000 from B to A\" 작업도 취소되어야 하기 때문에 Atomicity가 보장됩니다.",
  "choices" : "1.Atomicity/2.Consistency/3.Isolation/4.Durability/"
}, {
  "question" : "분산 데이터베이스 시스템과 관련한 설명으로 틀린 것은?",
  "answer" : "4.데이터베이스가 분산되어 있음을 사용자가 인식할 수 있도록 분산 투명성(Distribution Transparency)을 배제해야 한다.",
  "commentary" : "\"데이터베이스가 분산되어 있음을 사용자가 인식할 수 있도록 분산 투명성(Distribution Transparency)을 배제해야 한다.\"가 틀린 설명입니다. 분산 데이터베이스 시스템에서는 사용자가 데이터가 어디에 저장되어 있는지 인식하지 않아도 되도록 분산 투명성을 제공해야 합니다. 이를 위해 분산 데이터베이스 관리 시스템(Distributed Database Management System)이 데이터의 위치와 접근 방법을 추상화하여 사용자에게 일관된 인터페이스를 제공합니다.",
  "choices" : "1.물리적으로 분산된 데이터베이스 시스템을 논리적으로 하나의 데이터베이스 시스템처럼 사용할 수 있도록 한 것이다./2.물리적으로 분산되어 지역별로 필요한 데이터를 처리할 수 있는 지역 컴퓨터(Local Computer)를 분산 처리기(Distributed Processor)라고 한다./3.분산 데이터베이스 시스템을 위한 통신 네트워크 구조가 데이터 통신에 영향을 주므로 효율적으로 설계해야 한다./4.데이터베이스가 분산되어 있음을 사용자가 인식할 수 있도록 분산 투명성(Distribution Transparency)을 배제해야 한다./"
}, {
  "question" : "다음 테이블을 보고 강남지점의 판매량이 많은 제품부터 출력되도록 할 때 다음 중 가장 적절한 SQL 구문은? (단, 출력은 제품명과 판매량이 출력되도록 한다.)",
  "answer" : "4.SELECT 제품명, 판매량 FROM 푸드 WHERE 지점명 = '강남지점' ORDER BY 판매량 DESC;",
  "commentary" : "강남지점의 판매량이 많은 제품부터 출력하려면 WHERE 절을 이용해 강남지점의 데이터만 가져와야 한다. 그리고 ORDER BY 절을 이용해 판매량이 많은 순서대로 정렬해야 한다. 따라서 \"SELECT 제품명, 판매량 FROM 푸드 WHERE 지점명 = '강남지점' ORDER BY 판매량 DESC;\"가 가장 적절한 SQL 구문이다.",
  "choices" : "1.SELECT 제품명, 판매량 FROM 푸드 ORDER BY 판매량 ASC;/2.SELECT 제품명, 판매량 FROM 푸드 ORDER BY 판매량 DESC;/3.SELECT 제품명, 판매량 FROM 푸드 WHERE 지점명 = '강남지점' ORDER BY 판매량 ASC;/4.SELECT 제품명, 판매량 FROM 푸드 WHERE 지점명 = '강남지점' ORDER BY 판매량 DESC;/"
}, {
  "question" : "데이터베이스의 인덱스와 관련한 설명으로 틀린 것은?",
  "answer" : "3.인덱스의 추가, 삭제 명령어는 각각 ADD, DELETE이다.",
  "commentary" : "\"인덱스의 추가, 삭제 명령어는 각각 ADD, DELETE이다.\"가 틀린 설명입니다. 대부분의 데이터베이스에서는 인덱스를 추가할 때는 CREATE INDEX, 삭제할 때는 DROP INDEX를 사용합니다. ADD, DELETE는 일부 데이터베이스에서만 사용되는 명령어입니다. 인덱스는 데이터베이스에서 매우 중요한 역할을 합니다. 데이터베이스의 테이블에 인덱스를 추가하면 검색 속도가 향상되어 데이터를 빠르게 찾을 수 있습니다. 인덱스는 테이블의 열(column)에 대한 색인(index)을 만들어 두는 것으로, 이를 이용해 데이터를 검색하면 전체 데이터를 검색하는 것보다 훨씬 빠르게 결과를 얻을 수 있습니다. 인덱스는 데이터베이스의 성능을 향상시키는 데 매우 중요한 역할을 합니다. 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제되는 경우가 많습니다. 이는 인덱스가 테이블의 일부분으로 생성되기 때문입니다. 따라서 테이블을 삭제하면 인덱스도 함께 삭제되어야 합니다.",
  "choices" : "1.문헌의 색인, 사전과 같이 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조이다./2.테이블에 붙여진 색인으로 데이터 검색 시 처리 속도 향상에 도움이 된다./3.인덱스의 추가, 삭제 명령어는 각각 ADD, DELETE이다./4.대부분의 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제된다./"
}, {
  "question" : "물리적 데이터베이스 구조의 기본 데이터 단위인 저장 레코드의 양식을 설계할 때 고려 사항이 아닌 것은?",
  "answer" : "3.트랜잭션 모델링",
  "commentary" : "저장 레코드의 양식을 설계할 때 고려해야 할 사항은 데이터 타입, 데이터 값의 분포, 접근 빈도 등이 있습니다. 그러나 트랜잭션 모델링은 저장 레코드의 양식을 설계할 때 고려해야 할 사항이 아닙니다. 트랜잭션 모델링은 데이터베이스 시스템에서 트랜잭션의 동시성 제어와 병행성 제어를 위해 고려해야 할 사항입니다. 따라서 저장 레코드의 양식을 설계할 때는 트랜잭션 모델링보다는 다른 요소들을 더 중요하게 고려해야 합니다.",
  "choices" : "1.데이터 타입/2.데이터 값의 분포/3.트랜잭션 모델링/4.접근 빈도/"
}, {
  "question" : "SQL의 기능에 따른 분류 중에서 REVOKE문과 같이 데이터의 사용 권한을 관리하는데 사용하는 언어는?",
  "answer" : "3.DCL(Data Control Language)",
  "commentary" : "DCL(Data Control Language)은 데이터의 사용 권한을 관리하는데 사용하는 언어이다. REVOKE문과 같은 권한 취소 기능을 제공하며, GRANT문을 통해 권한을 부여할 수도 있다. DDL(Data Definition Language)은 데이터베이스의 구조를 정의하는데 사용되며, DML(Data Manipulation Language)은 데이터를 조작하는데 사용된다. DUL(Data User Language)은 사용자가 데이터베이스에 접근할 때 사용하는 언어이다.",
  "choices" : "1.DDL(Data Definition Language)/2.DML(Data Manipulation Language)/3.DCL(Data Control Language)/4.DUL(Data User Language)/"
}, {
  "question" : "데이터 사전에 대한 설명으로 틀린 것은?",
  "answer" : "2.데이터 사전 역시 데이터베이스의 일종이므로 일반 사용자가 생성, 유지 및 수정 할 수 있다.",
  "commentary" : "데이터 사전 역시 데이터베이스의 일종이므로 일반 사용자가 생성, 유지 및 수정 할 수 있다. - 이 설명이 틀렸습니다. 데이터 사전은 일반 사용자가 접근하거나 수정할 수 없는 시스템 카탈로그 또는 시스템 데이터베이스입니다.",
  "choices" : "1.시스템 카탈로그 또는 시스템 데이터베이스라고도 한다./2.데이터 사전 역시 데이터베이스의 일종이므로 일반 사용자가 생성, 유지 및 수정 할 수 있다./3.데이터베이스에 대한 데이터인 메타데이터(Metadata)를 저장하고 있다./4.데이터 사전에 있는 데이터에 실제로 접근하는 데 필요한 위치 정보는 데이터 디렉토리(Data Directory)라는 곳에서 관리한다./"
}, {
  "question" : "데이터베이스에서 릴레이션에 대한 설명으로 틀린 것은?",
  "answer" : "2.하나의 릴레이션에서 튜플은 특정한 순서를 가진다.",
  "commentary" : "\"하나의 릴레이션에서 튜플은 특정한 순서를 가진다.\"가 틀린 설명입니다. 릴레이션에서 튜플은 순서가 없이 저장되며, 특정한 순서를 가지려면 쿼리문에서 ORDER BY를 사용해야 합니다.",
  "choices" : "1.모든 튜플은 서로 다른 값을 가지고 있다./2.하나의 릴레이션에서 튜플은 특정한 순서를 가진다./3.각 속성은 릴레이션 내에서 유일한 이름을 가진다./4.모든 속성 값은 원자 값(atomic value)을 가진다./"
}, {
  "question" : "데이터베이스에서의 뷰(View)에 대한 설명으로 틀린 것은?",
  "answer" : "4.뷰는 논리적으로 존재하는 기본 테이블과 다르게 물리적으로만 존재하며 카탈로그에 저장된다.",
  "commentary" : null,
  "choices" : "1.뷰는 다른 뷰를 기반으로 새로운 뷰를 만들 수 있다./2.뷰는 일종의 가상 테이블이며, update에는 제약이 따른다./3.뷰는 기본 테이블을 만드는 것처럼 create view를 사용하여 만들 수 있다./4.뷰는 논리적으로 존재하는 기본 테이블과 다르게 물리적으로만 존재하며 카탈로그에 저장된다./"
}, {
  "question" : "트랜잭션의 상태 중 트랜잭션의 마지막 연산이 실행된 직후의 상태로, 모든 연산의 처리는 끝났지만 트랜잭션이 수행한 최종 결과를 데이터베이스에 반영하지 않은 상태는?",
  "answer" : "2.Partially Committed",
  "commentary" : "\"Partially Committed\" 상태는 모든 연산이 처리되었지만, 아직 트랜잭션이 수행한 최종 결과를 데이터베이스에 반영하지 않은 상태이기 때문에 정답입니다. 이 상태에서는 트랜잭션의 결과를 영구적으로 저장하기 전에 다른 트랜잭션들이 해당 데이터를 읽을 수 없습니다. 따라서 이 상태에서는 트랜잭션의 결과를 저장하기 위해 \"Commit\" 또는 \"Rollback\"을 선택해야 합니다.",
  "choices" : "1.Active/2.Partially Committed/3.Committed/4.Aborted/"
}, {
  "question" : "SQL의 명령을 사용 용도에 따라 DDL, DML, DCL로 구분할 경우, 그 성격이 나머지 셋과 다른 것은?",
  "answer" : "4.GRANT",
  "commentary" : "GRANT는 DCL(데이터 제어어)에 속하며, 데이터베이스 사용자에게 권한을 부여하는 명령어이다. 나머지 SELECT, UPDATE, INSERT는 DML(데이터 조작어)에 속하며, 데이터를 조회하거나 수정, 삽입하는 명령어이다. 따라서 GRANT는 데이터 조작이 아닌 데이터 제어에 사용되는 명령어이다.",
  "choices" : "1.SELECT/2.UPDATE/3.INSERT/4.GRANT/"
}, {
  "question" : "키의 종류 중 유일성과 최소성을 만족하는 속성 또는 속성들의 집합은?",
  "answer" : "3.Candidate key",
  "commentary" : "Candidate key는 유일성과 최소성을 모두 만족하는 속성 또는 속성들의 집합을 의미합니다. 즉, 해당 속성 또는 속성들로는 테이블에서 유일하게 식별할 수 있으며, 다른 속성을 추가하면 유일성이 깨지는 최소한의 속성 또는 속성들입니다. Atomic key는 속성이 원자적(더 이상 분해할 수 없는)인 경우를 의미하며, Super key는 유일성은 만족하지만 최소성은 만족하지 않는 속성 또는 속성들의 집합을 의미합니다. Test key는 테스트를 위해 사용되는 임시적인 키를 의미합니다.",
  "choices" : "1.Atomic key/2.Super key/3.Candidate key/4.Test key/"
}, {
  "question" : "데이터베이스에서 개념적 설계 단계에 대한 설명으로 틀린 것은?",
  "answer" : "3.트랜잭션 인터페이스를 설계 및 작성한다.",
  "commentary" : "정답은 \"트랜잭션 인터페이스를 설계 및 작성한다.\" 이다. 개념적 설계 단계에서는 데이터베이스의 구조와 관련된 개념들을 정의하고, 이를 E-R Diagram 등의 산출물로 표현한다. 또한 DBMS에 독립적인 개념 스키마를 설계한다. 하지만 트랜잭션 인터페이스는 논리적 설계 단계에서 수행되며, 데이터베이스에 접근하는 애플리케이션과 데이터베이스 간의 인터페이스를 설계하고 작성하는 것이다.",
  "choices" : "1.산출물로 E-R Diagram을 만들 수 있다./2.DBMS에 독립적인 개념 스키마를 설계한다./3.트랜잭션 인터페이스를 설계 및 작성한다./4.논리적 설계 단계의 앞 단계에서 수행된다./"
}, {
  "question" : "테이블의 기본키(Primary Key)로 지정된 속성에 관한 설명으로 가장 거리가 먼 것은?",
  "answer" : "4.검색할 때 반드시 필요하다.",
  "commentary" : "\"외래키로 참조될 수 있다.\"는 기본키와는 관련이 없는 내용이므로 가장 거리가 먼 것이다. 기본키는 릴레이션에서 각 튜플을 유일하게 식별할 수 있는 속성으로, 검색할 때 반드시 필요하다. 이는 기본키를 이용하여 특정 튜플을 빠르게 찾을 수 있기 때문이다. 또한, 기본키는 NOT NULL 제약 조건을 가지므로 널 값을 가지지 않는다는 특징도 있다.",
  "choices" : "1.NOT NULL로 널 값을 가지지 않는다./2.릴레이션에서 튜플을 구별할 수 있다./3.외래키로 참조될 수 있다./4.검색할 때 반드시 필요하다./"
}, {
  "question" : "데이터 모델의 구성 요소 중 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?",
  "answer" : "4.Operation",
  "commentary" : "데이터 모델의 구성 요소 중 데이터 구조는 데이터를 어떻게 구성하고 저장할지를 결정하는데, 이 구조에 따라 처리되는 작업을 의미하는 것이 \"Operation\"입니다. 즉, 데이터 구조가 정의되면 해당 데이터를 검색, 추가, 수정, 삭제 등의 작업을 수행할 수 있으며, 이러한 작업을 \"Operation\"이라고 합니다.",
  "choices" : "1.Relation/2.Data Structure/3.Constraint/4.Operation/"
}, {
  "question" : "다음 [조건]에 부합하는 SQL문을 작성하고자 할 때, [SQL문]의 빈칸에 들어갈 내용으로 옳은 것은? (단, '팀코드' 및 '이름'은 속성이며, '직원'은 테이블이다.)",
  "answer" : "4.SELECT 팀코드 FROM 직원 WHERE 이름 = '정도일'",
  "commentary" : "조건: 이름이 '정도일'인 직원의 팀코드를 조회한다. SQL문: SELECT 팀코드 FROM 직원 WHERE 이름 = '정도일' 설명: WHERE 절을 이용하여 이름이 '정도일'인 직원을 찾고, SELECT 절에서는 해당 직원의 팀코드를 조회한다. 따라서 정답은 \"SELECT 팀코드 FROM 직원 WHERE 이름 = '정도일'\"이다.",
  "choices" : "1.WHERE 이름 = '정도일'/2.SELECT 팀코드 FROM 이름 WHERE 직원 = '정도일'/3.WHERE 직원 = '정도일'/4.SELECT 팀코드 FROM 직원 WHERE 이름 = '정도일'/"
}, {
  "question" : "무결성 제약조건 중 개체 무결성 제약조건에 대한 설명으로 옳은 것은?",
  "answer" : "2.기본키는 NULL 값을 가져서는 안되며 릴레이션 내에 오직 하나의 값만 존재해야 한다.",
  "commentary" : "기본키는 NULL 값을 가질 수 없는 이유는 기본키는 릴레이션 내에서 각 튜플을 유일하게 식별하는 역할을 하기 때문입니다. 만약 기본키가 NULL 값을 가진다면, 해당 튜플은 유일하게 식별되지 않게 되므로 개체 무결성 제약조건을 위반하게 됩니다. 또한, 기본키는 릴레이션 내에서 오직 하나의 값만 존재해야 하는 이유도 이와 같습니다. 기본키가 중복되면, 해당 튜플들은 구별할 수 없게 되므로 개체 무결성 제약조건을 위반하게 됩니다.",
  "choices" : "1.릴레이션 내의 튜플들이 각 속성의 도메인에 정해진 값만을 가져야 한다./2.기본키는 NULL 값을 가져서는 안되며 릴레이션 내에 오직 하나의 값만 존재해야 한다./3.자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 한다./4.자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받는다./"
}, {
  "question" : "관계 데이터 모델에서 릴레이션(Relation)에 포함되어 있는 튜플(Tuple)의 수를 무엇이라고 하는가?",
  "answer" : "2.Cardinality",
  "commentary" : "릴레이션에 포함되어 있는 튜플의 수를 Cardinality라고 한다. 이는 릴레이션의 크기를 나타내는 중요한 개념으로, 데이터베이스에서 데이터의 양을 파악하는 데에 사용된다. 다른 보기들은 관계 데이터 모델에서 중요한 개념이지만, 릴레이션의 크기를 나타내는 것은 Cardinality이기 때문에 정답은 이것이다.",
  "choices" : "1.Degree/2.Cardinality/3.Attribute/4.Cartesian product/"
}, {
  "question" : "사용자 'PARK'에게 테이블을 생성할 수 있는 권한을 부여하기 위한 SQL문의 구성으로 빈칸에 적합한 내용은?",
  "answer" : "1.CREATE TABLE TO",
  "commentary" : "GRANT CREATE TABLE TO PARK; \"CREATE TABLE TO\"은 권한을 부여할 대상이 되는 사용자(PARK)가 새로운 테이블을 생성할 수 있는 권한을 부여하는 SQL 구문이다. \"CREATE TO\", \"CREATE FROM\", \"CREATE TABLE FROM\"은 올바른 SQL 구문이 아니므로 선택지에서 제외된다.",
  "choices" : "1.CREATE TABLE TO/2.CREATE TO/3.CREATE FROM/4.CREATE TABLE FROM/"
}, {
  "question" : "C언어에서 문자열 처리 함수의 서식과 그 기능의 연결로 틀린 것은?",
  "answer" : "3.strcmp(s1, s2) - s1과 s2를 연결한다.",
  "commentary" : "\"strcmp(s1, s2) - s1과 s2를 연결한다.\"는 틀린 설명입니다. strcmp 함수는 s1과 s2를 비교하여 같으면 0을, s1이 s2보다 작으면 음수를, s1이 s2보다 크면 양수를 반환합니다. 따라서 s1과 s2를 연결하는 기능이 아닙니다.",
  "choices" : "1.strlen(s) - s의 길이를 구한다./2.strcpy(s1, s2) - s2를 s1으로 복사한다./3.strcmp(s1, s2) - s1과 s2를 연결한다./4.strrev(s)－s를 거꾸로 변환한다./"
}, {
  "question" : "다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",
  "answer" : "2.２",
  "commentary" : null,
  "choices" : "1.０/2.２/3.５/4.14/"
}, {
  "question" : "다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",
  "answer" : "2.60",
  "commentary" : null,
  "choices" : "1.30/2.60/3.80/4.120/"
}, {
  "question" : "IP 프로토콜에서 사용하는 필드와 해당 필드에 대한 설명으로 틀린 것은?",
  "answer" : "2.Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 232－1비트이다.",
  "commentary" : "정답은 \"Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 232－1비트이다.\" 이다. IP 프로토콜에서 사용하는 필드는 Header Length, Packet Length, Time To Live, Version Number이다. Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 216비트이다.",
  "choices" : "1.Header Length는 IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다./2.Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 232－1비트이다./3.Time To Live는 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것이다./4.Version Number는 IP 프로토콜의 버전번호를 나타낸다./"
}, {
  "question" : "다음 Python 프로그램의 실행 결과가 [실행결과]와 같을 때, 빈칸에 적합한 것은?",
  "answer" : "2.elif",
  "commentary" : "[실행결과] 10 20 30 정답: \"elif\" 이유: if문은 조건문을 검사하여 참(True)이면 해당 코드 블록을 실행하고, 거짓(False)이면 다음 조건문을 검사한다. elif는 이전 조건문이 거짓일 때, 새로운 조건문을 검사하여 참이면 해당 코드 블록을 실행한다. 따라서, 첫 번째 if문이 거짓이므로 elif문을 검사하게 되고, x가 20이므로 해당 코드 블록이 실행되어 20이 출력된다. 마찬가지로, 두 번째 elif문도 검사되어 30이 출력된다. 마지막으로 else문은 모든 조건문이 거짓일 때 실행되는데, 이 경우에는 실행되지 않는다.",
  "choices" : "1.either/2.elif/3.else if/4.else/"
}, {
  "question" : "RIP 라우팅 프로토콜에 대한 설명으로 틀린 것은?",
  "answer" : "2.라우팅 프로토콜을 IGP와 EGP로 분류했을 때 EGP에 해당한다.",
  "commentary" : "\"라우팅 프로토콜을 IGP와 EGP로 분류했을 때 EGP에 해당한다.\"는 틀린 설명입니다. IGP는 Autonomous System(AS) 내에서 라우팅을 수행하는 프로토콜을 의미하고, EGP는 AS 간 라우팅을 수행하는 프로토콜을 의미합니다. RIP는 IGP 중 하나이며, AS 내에서 라우팅을 수행합니다.",
  "choices" : "1.경로 선택 메트릭은 홉 카운트(hop count)이다./2.라우팅 프로토콜을 IGP와 EGP로 분류했을 때 EGP에 해당한다./3.최단 경로 탐색에 Bellman-Ford 알고리즘을 사용한다./4.각 라우터는 이웃 라우터들로부터 수신한 정보를 이용하여 라우팅 표를 갱신한다./"
}, {
  "question" : "다음에서 설명하는 프로세스 스케줄링은?",
  "answer" : "3.HRN 스케줄링",
  "commentary" : "주어진 프로세스의 우선순위를 계산하여 가장 높은 우선순위를 가진 프로세스를 먼저 실행하는 스케줄링 알고리즘입니다. HRN 스케줄링은 우선순위를 계산할 때, 대기 시간과 서비스 시간을 모두 고려하여 우선순위를 계산합니다. 따라서 대기 시간이 긴 프로세스일수록 우선순위가 높아지게 되어, 대기 시간이 긴 프로세스를 먼저 실행하는 효과를 가지게 됩니다.",
  "choices" : "1.FIFO 스케줄링/2.RR 스케줄링/3.HRN 스케줄링/4.MQ 스케줄링/"
}, {
  "question" : "UNIX 운영체제에 관한 특징으로 틀린 것은?",
  "answer" : "2.Multi-User는 지원하지만 Multi-Tasking은 지원하지 않는다.",
  "commentary" : "\"Multi-Tasking은 지원하지 않는다.\"는 틀린 설명입니다. UNIX 운영체제는 하나 이상의 작업에 대하여 백그라운드에서 수행이 가능하며, Multi-User와 Multi-Tasking을 모두 지원합니다. 따라서 이유를 설명할 필요가 없습니다.",
  "choices" : "1.하나 이상의 작업에 대하여 백그라운드에서 수행이 가능하다./2.Multi-User는 지원하지만 Multi-Tasking은 지원하지 않는다./3.트리 구조의 파일 시스템을 갖는다./4.이식성이 높으며 장치 간의 호환성이 높다./"
}, {
  "question" : "UDP 프로토콜의 특징이 아닌 것은?",
  "answer" : "3.주로 주소를 지정하고, 경로를 설정하는 기능을 한다.",
  "commentary" : "UDP 프로토콜은 주소를 지정하고 경로를 설정하는 기능을 하지 않습니다. 이는 IP 프로토콜에서 처리되는 부분입니다. UDP는 비연결형 서비스를 제공하며, 단순한 헤더 구조로 오버헤드가 적습니다. 또한 TCP와 같이 트랜스포트 계층에 존재합니다.",
  "choices" : "1.비연결형 서비스를 제공한다./2.단순한 헤더 구조로 오버헤드가 적다./3.주로 주소를 지정하고, 경로를 설정하는 기능을 한다./4.TCP와 같이 트랜스포트 계층에 존재한다./"
}, {
  "question" : "Python 데이터 타입 중 시퀀스(Sequence) 데이터 타입에 해당하며 다양한 데이터 타입들을 주어진 순서에 따라 저장할 수 있으나 저장된 내용을 변경할 수 없는 것은?",
  "answer" : "4.튜플(tuple) 타입",
  "commentary" : "튜플(tuple) 타입은 저장된 내용을 변경할 수 없는 Immutable(불변)한 데이터 타입이기 때문입니다. 따라서 한 번 생성된 튜플은 내부 요소를 추가, 삭제, 수정할 수 없습니다. 이와 달리 리스트(list) 타입은 Mutable(가변)한 데이터 타입으로 내부 요소를 변경할 수 있습니다.",
  "choices" : "1.복소수(complex) 타입/2.리스트(list) 타입/3.사전(dict) 타입/4.튜플(tuple) 타입/"
}, {
  "question" : "다음 JAVA 프로그램이 실행되었을 때, 실행결과는?",
  "answer" : "2.0 1 2 3",
  "commentary" : "이유는 for문에서 i의 초기값이 0이고, i가 4보다 작을 때까지 반복하며 i를 1씩 증가시키기 때문에 0, 1, 2, 3이 출력되기 때문입니다. 따라서 정답은 \"0 1 2 3\"입니다.",
  "choices" : "1.1 2 3 4/2.0 1 2 3/3.1 2 3/4.0 1 2/"
}, {
  "question" : "다음 JAVA 프로그램이 실행되었을 때의 결과는?",
  "answer" : "3.3",
  "commentary" : null,
  "choices" : "1.1/2.2/3.3/4.4/"
}, {
  "question" : "다음 중 Myers가 구분한 응집도(Cohesion)의 정도에서 가장 낮은 응집도를 갖는 단계는?",
  "answer" : "4.우연적 응집도(Coincidental Cohesion)",
  "commentary" : "우연적 응집도는 모듈 내부의 요소들이 서로 관련성이 없이 무작위로 모여있는 경우를 말한다. 따라서 가장 낮은 응집도를 갖는 단계는 우연적 응집도이다.",
  "choices" : "1.순차적 응집도(Sequential Cohesion)/2.기능적 응집도(Functional Cohesion)/3.시간적 응집도(Temporal Cohesion)/4.우연적 응집도(Coincidental Cohesion)/"
}, {
  "question" : "다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",
  "answer" : "2.1",
  "commentary" : null,
  "choices" : "1.0/2.1/3.2/4.3/"
}, {
  "question" : "IP 프로토콜의 주요 특징에 해당하지 않는 것은?",
  "answer" : "1.체크섬(Checksum) 기능으로 데이터 체크섬(Data Checksum)만 제공한다.",
  "commentary" : "IP 프로토콜은 데이터 체크섬 기능뿐만 아니라 패킷 분할, 병합 기능도 수행하며 비연결형 서비스를 제공하고 Best Effort 원칙에 따른 전송 기능을 제공한다. 따라서 \"체크섬(Checksum) 기능으로 데이터 체크섬(Data Checksum)만 제공한다.\"는 IP 프로토콜의 주요 특징에 해당하지 않는다.",
  "choices" : "1.체크섬(Checksum) 기능으로 데이터 체크섬(Data Checksum)만 제공한다./2.패킷을 분할, 병합하는 기능을 수행하기도 한다./3.비연결형 서비스를 제공한다./4.Best Effort 원칙에 따른 전송 기능을 제공한다./"
}, {
  "question" : "4개의 페이지를 수용할 수 있는 주기억장치가 있으며, 초기에는 모두 비어 있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, LRU 페이지 교체 알고리즘을 사용할 경우 몇 번의 페이지 결함이 발생하는가?",
  "answer" : "1.5회",
  "commentary" : null,
  "choices" : "1.5회/2.6회/3.7회/4.8회/"
}, {
  "question" : "사용자 수준에서 지원되는 스레드(thread)가 커널에서 지원되는 스레드에 비해 가지는 장점으로 옳은 것은?",
  "answer" : "4.커널 모드로의 전환 없이 스레드 교환이 가능하므로 오버헤드가 줄어든다.",
  "commentary" : "사용자 수준에서 지원되는 스레드는 커널 모드로의 전환 없이 스레드 교환이 가능하므로 오버헤드가 줄어들어 시스템 성능을 높일 수 있다. 이는 스레드 간의 컨텍스트 전환에 필요한 시간과 자원을 줄여주기 때문이다. 따라서 \"커널 모드로의 전환 없이 스레드 교환이 가능하므로 오버헤드가 줄어든다.\"가 옳은 답이다.",
  "choices" : "1.한 프로세스가 운영체제를 호출할 때 전체 프로세스가 대기할 필요가 없으므로 시스템 성능을 높일 수 있다./2.동시에 여러 스레드가 커널에 접근할 수 있으므로 여러 스레드가 시스템 호출을 동시에 사용할 수 있다./3.각 스레드를 개별적으로 관리할 수 있으므로 스레드의 독립적인 스케줄링이 가능하다./4.커널 모드로의 전환 없이 스레드 교환이 가능하므로 오버헤드가 줄어든다./"
}, {
  "question" : "한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우의 결합도는?",
  "answer" : "1.내용 결합도(Content Coupling)",
  "commentary" : "내용 결합도(Content Coupling)는 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하는 결합도이다. 즉, 모듈 간의 의존성이 매우 높아져서 한 모듈의 변경이 다른 모듈에 큰 영향을 미치게 된다. 이는 모듈의 재사용성과 유지보수성을 저하시키는 원인이 된다. 따라서 내용 결합도는 최대한 피해야 한다.",
  "choices" : "1.내용 결합도(Content Coupling)/2.제어 결합도(Control Coupling)/3.공통 결합도(Common Coupling)/4.스탬프 결합도(Stamp Coupling)/"
}, {
  "question" : "a[0]의 주소값이 10일 경우 다음 C언어 프로그램이 실행되었을 때의 결과는? (단, int 형의 크기는 4Byte로 가정한다.)",
  "answer" : "3.18, 10",
  "commentary" : "a[0]의 주소값이 10일 경우, a[1]은 a[0]에서 int 형의 크기인 4Byte만큼 떨어진 곳에 위치하므로 주소값은 14가 된다. 따라서 a[1]의 주소값은 14이다. 또한, 변수 b는 int 형의 크기인 4Byte를 차지하므로 a[0]에서 4Byte만큼 떨어진 곳에 위치하게 된다. 따라서 b의 주소값은 18이 된다. 따라서 정답은 \"18, 10\"이 된다.",
  "choices" : "1.14, 10/2.14, 14/3.18, 10/4.18, 14/"
}, {
  "question" : "모듈화(Modularity)와 관련한 설명으로 틀린 것은?",
  "answer" : "2.응집도는 모듈과 모듈 사이의 상호의존 또는 연관 정도를 의미한다.",
  "commentary" : "\"응집도는 모듈과 모듈 사이의 상호의존 또는 연관 정도를 의미한다.\"가 틀린 설명입니다. 응집도는 모듈 내부의 구성 요소들 간의 관련성 정도를 의미합니다. 즉, 모듈 내부의 요소들이 서로 밀접하게 연관되어 있는 정도를 나타냅니다.",
  "choices" : "1.시스템을 모듈로 분할하면 각각의 모듈을 별개로 만들고 수정할 수 있기 때문에 좋은 구조가 된다./2.응집도는 모듈과 모듈 사이의 상호의존 또는 연관 정도를 의미한다./3.모듈 간의 결합도가 약해야 독립적인 모듈이 될 수 있다./4.모듈 내 구성 요소들 간의 응집도가 강해야 좋은 모듈 설계이다./"
}, {
  "question" : "소프트웨어 개발에서 정보보안 3요소에 해당 하지 않는 설명은?",
  "answer" : "4.휘발성 : 인가된 사용자가 수행한 데이터는 처리 완료 즉시 폐기 되어야 한다.",
  "commentary" : null,
  "choices" : "1.기밀성 : 인가된 사용자에 대해서만 자원 접근이 가능하다./2.무결성 : 인가된 사용자에 대해서만 자원 수정이 가능하며 전송중인 정보는 수정되지 않는다./3.가용성 : 인가된 사용자는 가지고 있는 권한 범위 내에서 언제든 자원 접근이 가능하다./4.휘발성 : 인가된 사용자가 수행한 데이터는 처리 완료 즉시 폐기 되어야 한다./"
}, {
  "question" : "어떤 외부 컴퓨터가 접속되면 접속 인가 여부를 점검해서 인가된 경우에는 접속이 허용되고, 그 반대의 경우에는 거부할 수 있는 접근제어 유틸리티는?",
  "answer" : "1.tcp wrapper",
  "commentary" : "\"tcp wrapper\"는 호스트 기반의 접근제어 유틸리티로, 외부 컴퓨터가 접속할 때 해당 호스트의 접근 권한을 확인하고 인가된 경우에만 접속을 허용합니다. 이를 위해 호스트 기반의 설정 파일을 사용하며, 이 파일에는 접근을 허용할 호스트나 네트워크의 IP 주소 등을 등록할 수 있습니다. 따라서 \"tcp wrapper\"는 외부로부터의 접근을 제어하고 보안을 강화하는 데에 유용한 도구입니다.",
  "choices" : "1.tcp wrapper/2.trace checker/3.token finder/4.change detector/"
}, {
  "question" : "기기를 키오스크에 갖다 대면 원하는 데이터를 바로 가져올 수 있는 기술로 10㎝ 이내 근접 거리에서 기가급 속도로 데이터 전송이 가능한 초고속 근접무선통신(NFC : Near Field Communication) 기술은?",
  "answer" : "2.Zing",
  "commentary" : "NFC 기술은 \"Zing\"이라는 이름으로 불리는데, 이는 기기를 간편하게 연결하고 데이터를 빠르게 전송할 수 있는 쾌적한 사용 경험을 제공하기 때문입니다.",
  "choices" : "1.BcN(Broadband Convergence Network)/2.Zing/3.Marine Navi/4.C-V2X(Cellular Vehicle To Everything)/"
}, {
  "question" : "취약점 관리를 위한 응용 프로그램의 보안 설정과 가장 거리가 먼 것은?",
  "answer" : "1.서버 관리실 출입 통제",
  "commentary" : "\"서버 관리실 출입 통제\"는 물리적인 보안 요소로서, 응용 프로그램의 보안 설정과는 직접적인 연관성이 없습니다. 즉, 응용 프로그램의 보안 설정은 주로 소프트웨어적인 측면에서의 보안을 강화하는 것이며, \"서버 관리실 출입 통제\"는 물리적인 접근 제어를 통해 보안을 강화하는 것입니다. 따라서, 이 중에서 가장 거리가 먼 것은 \"서버 관리실 출입 통제\"입니다.",
  "choices" : "1.서버 관리실 출입 통제/2.실행 프로세스 권한 설정/3.운영체제의 접근 제한/4.운영체제의 정보 수집 제한/"
}, {
  "question" : "소프트웨어 개발 프레임워크와 관련한 설명으로 가장 적절하지 않은 것은?",
  "answer" : "2.라이브러리와는 달리 사용자 코드에서 프레임워크를 호출해서 사용하고, 그에 대한 제어도 사용자 코드가 가지는 방식이다.",
  "commentary" : "\"반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장 받을 수 있게 하는 개발 소프트웨어이다.\"는 소프트웨어 개발 프레임워크와 관련한 설명으로 적절하지 않다. \"라이브러리와는 달리 사용자 코드에서 프레임워크를 호출해서 사용하고, 그에 대한 제어도 사용자 코드가 가지는 방식이다.\"는 프레임워크의 특징을 설명하는 것으로, 사용자 코드가 프레임워크에 의해 제어되는 IoC(Inversion of Control) 개념과도 관련이 있다. 따라서 정답은 \"반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장 받을 수 있게 하는 개발 소프트웨어이다.\"이다. IoC(Inversion of Control) 개념은 사용자 코드가 프레임워크에 의해 제어되는 것으로, 프레임워크의 동작 원리를 일반적인 프로그램 흐름과 반대로 동작한다고 설명하기도 한다. 소프트웨어 디자인 패턴은 프레임워크의 설계 관점에서 개발 방식을 패턴화시키기 위한 노력의 결과물로 볼 수 있다.",
  "choices" : "1.반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장 받을 수 있게 하는 개발 소프트웨어이다./2.라이브러리와는 달리 사용자 코드에서 프레임워크를 호출해서 사용하고, 그에 대한 제어도 사용자 코드가 가지는 방식이다./3.설계 관점에 개발 방식을 패턴화시키기 위한 노력의 결과물인 소프트웨어 디자인 패턴을 반제품 소프트웨어 상태로 집적화시킨 것으로 볼 수 있다./4.프레임워크의 동작 원리를 그 제어 흐름의 일반적인 프로그램 흐름과 반대로 동작한다고 해서 IoC(Inversion of Control)이라고 설명하기도 한다./"
}, {
  "question" : "클라우드 기반 HSM(Cloud-based Hardware Security Module)에 대한 설명으로 틀린 것은?",
  "answer" : "4.하드웨어가 아닌 소프트웨어적으로만 구현되기 때문에 소프트웨어식 암호 기술에 내재된 보안 취약점을 해결할 수 없다는 것이 주요 단점이다.",
  "commentary" : "\"하드웨어가 아닌 소프트웨어적으로만 구현되기 때문에 소프트웨어식 암호 기술에 내재된 보안 취약점을 해결할 수 없다는 것이 주요 단점이다.\"가 틀린 것이다. 클라우드 기반 HSM은 하드웨어와 소프트웨어의 조합으로 구현되며, 소프트웨어적인 부분은 보안 취약점을 해결하기 위해 엄격한 보안 검증과 테스트를 거쳐 개발된다. 따라서 소프트웨어식 암호 기술에 내재된 보안 취약점을 해결할 수 있다.",
  "choices" : "1.클라우드(데이터센터) 기반 암호화 키 생성, 처리, 저장 등을 하는 보안 기기이다./2.국내에서는 공인인증제의 폐지와 전자서명법 개정을 추진하면서 클라우드 HSM 용어가 자주 등장하였다./3.클라우드에 인증서를 저장하므로 기존 HSM 기기나 휴대폰에 인증서를 저장해 다닐 필요가 없다./4.하드웨어가 아닌 소프트웨어적으로만 구현되기 때문에 소프트웨어식 암호 기술에 내재된 보안 취약점을 해결할 수 없다는 것이 주요 단점이다./"
}, {
  "question" : "다음 내용이 설명하는 기술로 가장 적절한 것은?",
  "answer" : "3.Mesh Network",
  "commentary" : "위 그림은 Mesh Network를 나타내고 있습니다. Mesh Network는 여러 개의 노드들이 서로 연결되어 있는 네트워크입니다. 각 노드는 다른 노드와 직접적으로 연결되어 있어서, 한 노드가 고장나더라도 다른 노드들과 통신이 가능합니다. 이러한 구조로 인해 Mesh Network는 높은 신뢰성과 안정성을 가지고 있습니다.",
  "choices" : "1.Virtual Local Area Network/2.Simple Station Network/3.Mesh Network/4.Modem Network/"
}, {
  "question" : "물리적 위협으로 인한 문제에 해당하지 않는 것은?",
  "answer" : "4.방화벽 설정의 잘못된 조작으로 인한 네트워크, 서버 보안 위협",
  "commentary" : "방화벽 설정의 잘못된 조작은 물리적인 파괴나 장애가 아니라, 네트워크와 서버의 보안에 직접적인 영향을 미치는 디지털적인 위협이기 때문에, 물리적 위협으로 분류되지 않는다.",
  "choices" : "1.화재, 홍수 등 천재지변으로 인한 위협/2.하드웨어 파손, 고장으로 인한 장애/3.방화, 테러로 인한 하드웨어와 기록장치를 물리적으로 파괴하는 행위/4.방화벽 설정의 잘못된 조작으로 인한 네트워크, 서버 보안 위협/"
}, {
  "question" : "악성코드의 유형 중 다른 컴퓨터의 취약점을 이용하여 스스로 전파하거나 메일로 전파되며 스스로를 증식하는 것은?",
  "answer" : "1.Worm",
  "commentary" : "\"Worm\"은 다른 컴퓨터의 취약점을 이용하여 스스로 전파하거나 메일로 전파되며 스스로를 증식하는 악성코드의 유형이다. 따라서 위의 보기 중 \"Worm\"이 정답이다. \"Rogue Ware\"는 가짜 보안 소프트웨어를 설치하여 사용자를 속이는 악성코드, \"Adware\"는 광고를 노출시키는 악성코드, \"Reflection Attack\"는 DDoS 공격에 사용되는 기술이다.",
  "choices" : "1.Worm/2.Rogue Ware/3.Adware/4.Reflection Attack/"
}, {
  "question" : "다음 설명에 해 당하는 공격기법은?",
  "answer" : "1.Ping of Death",
  "commentary" : "이 공격기법은 \"Ping of Death\"이다. 이유는 ICMP 패킷을 이용하여 대상 시스템에 과도한 크기의 패킷을 보내 크래시를 유발하는 공격이기 때문이다. ICMP 패킷은 일반적으로 64바이트 이하의 크기를 가지지만, 이 공격에서는 65,535바이트의 크기를 가진 패킷을 보내 크래시를 유발한다.",
  "choices" : "1.Ping of Death/2.Session Hijacking/3.Piggyback Attack/4.XSS/"
}, {
  "question" : "다음 설명에 해당하는 소프트웨어는?",
  "answer" : "2.소프트웨어 개발 프레임워크",
  "commentary" : "이미지에서 보이는 것은 소프트웨어 개발 프레임워크인 React입니다. React는 UI를 만들기 위한 자바스크립트 라이브러리로, 컴포넌트 기반으로 구성되어 있습니다. 따라서 React는 전역 함수 라이브러리나 어휘 분석기와 같은 것이 아니라, 소프트웨어 개발 프레임워크입니다.",
  "choices" : "1.전역 함수 라이브러리/2.소프트웨어 개발 프레임워크/3.컨테이너 아키텍처/4.어휘 분석기/"
}, {
  "question" : "소프트웨어 개발 방법론 중 애자일(Agile) 방법론의 특징과 가장 거리가 먼 것은?",
  "answer" : "1.각 단계의 결과가 완전히 확인된 후 다음 단계 진행",
  "commentary" : "애자일 방법론은 소프트웨어 개발에 참여하는 구성원들 간의 의사소통을 중시하며, 환경 변화에 대한 즉시 대응과 프로젝트 상황에 따른 주기적 조정을 특징으로 합니다. 따라서 \"각 단계의 결과가 완전히 확인된 후 다음 단계 진행\"은 애자일 방법론과 가장 거리가 먼 특징입니다. 애자일 방법론은 반복적인 개발 주기를 통해 빠르게 결과물을 도출하고, 이를 기반으로 지속적으로 개선해 나가는 방식을 취하기 때문에 각 단계의 결과물이 완전히 확인된 후 다음 단계를 진행하는 전통적인 개발 방법론과는 차이가 있습니다.",
  "choices" : "1.각 단계의 결과가 완전히 확인된 후 다음 단계 진행/2.소프트웨어 개발에 참여하는 구성원들 간의 의사소통 중시/3.환경 변화에 대한 즉시 대응/4.프로젝트 상황에 따른 주기적 조정/"
}, {
  "question" : "대칭 암호 알고리즘과 비대칭 암호 알고리즘에 대한 설명으로 틀린 것은?",
  "answer" : "2.대칭 암호 알고리즘은 비밀키 전달을 위한 키 교환이 필요하지 않아 암호화 및 복호화의 속도가 빠르다.",
  "commentary" : "정답은 \"대칭 암호 알고리즘은 비밀키 전달을 위한 키 교환이 필요하지 않아 암호화 및 복호화의 속도가 빠르다.\" 이유는 대칭 암호 알고리즘에서는 암호화와 복호화에 같은 키를 사용하기 때문에 키 교환이 필요하지 않습니다. 따라서 비밀키를 미리 공유하고 있으면 빠르게 암호화와 복호화를 수행할 수 있습니다.",
  "choices" : "1.대칭 암호 알고리즘은 비교적 실행 속도가 빠르기 때문에 다양한 암호의 핵심 함수로 사용될 수 있다./2.대칭 암호 알고리즘은 비밀키 전달을 위한 키 교환이 필요하지 않아 암호화 및 복호화의 속도가 빠르다./3.비대칭 암호 알고리즘은 자신만이 보관하는 비밀키를 이용하여 인증, 전자서명 등에 적용이 가능하다./4.대표적인 대칭키 암호 알고리즘으로는 AES, IDEA 등이 있다./"
}, {
  "question" : "두 명의 개발자가 5개월에 걸쳐 10000 라인의 코드를 개발하였을 때, 월별(man-month) 생산성 측정을 위한 계산 방식으로 가장 적합한 것은?",
  "answer" : "2.10000／(5×2)",
  "commentary" : "월별 생산성 측정을 위해서는 개발 기간을 개발자 수로 나누어야 합니다. 따라서, 5개월 동안 2명의 개발자가 일했으므로, 월별 생산성은 10000 라인의 코드를 (5×2) = 10명의 개발자가 개발한 것과 동일하다고 가정할 수 있습니다. 따라서, 월별 생산성은 10000／(5×2)가 됩니다.",
  "choices" : "1.10000／2/2.10000／(5×2)/3.10000／5/4.(2×10000)／5/"
}, {
  "question" : "접근 통제 방법 중 조직 내에서 직무, 직책 등 개인의 역할에 따라 결정하여 부여하는 접근 정책은?",
  "answer" : "1.RBAC",
  "commentary" : "RBAC은 Role-Based Access Control의 약자로, 조직 내에서 각 개인의 역할에 따라 접근 권한을 부여하는 방식입니다. 즉, 개인의 신분이나 소속 부서 등이 아닌, 그들이 수행하는 역할에 따라 접근 권한이 결정됩니다. 이는 보안성을 높이고, 권한 관리를 용이하게 하며, 규모가 큰 조직에서 특히 효과적입니다. 따라서 RBAC이 조직 내에서 직무, 직책 등 개인의 역할에 따라 결정하여 부여하는 접근 정책이라고 할 수 있습니다.",
  "choices" : "1.RBAC/2.DAC/3.MAC/4.QAC/"
}, {
  "question" : "COCOMO(Constructive Cost Model) 모형의 특징이 아닌 것은?",
  "answer" : "4.프로젝트 개발유형에 따라 object, dynamic, function의 3가지 모드로 구분한다.",
  "commentary" : "COCOMO 모형의 특징 중에서 \"프로젝트 개발유형에 따라 object, dynamic, function의 3가지 모드로 구분한다.\"는 올바른 특징이다. 이는 프로젝트의 특성에 따라 적합한 모드를 선택하여 비용 산정을 할 수 있도록 하는 것이다. 다른 보기들은 COCOMO 모형의 특징으로 올바른 것들이다.",
  "choices" : "1.프로젝트를 완성하는데 필요한 man-month로 산정 결과를 나타낼 수 있다./2.보헴(Boehm)이 제안한 것으로 원시코드 라인 수에 의한 비용 산정 기법이다./3.비교적 작은 규모의 프로젝트 기록을 통계 분석하여 얻은 결과를 반영한 모델이며 중소 규모 소프트웨어 프로젝트 비용 추정에 적합하다./4.프로젝트 개발유형에 따라 object, dynamic, function의 3가지 모드로 구분한다./"
}, {
  "question" : "각 사용자 인증의 유형에 대한 설명으로 가장 적절하지 않은 것은?",
  "answer" : "3.존재 : 주체는 '그를 대체하는 것'을 보여주며 예시로는 패턴, QR 등이 있다.",
  "commentary" : "\"존재 : 주체는 '그를 대체하는 것'을 보여주며 예시로는 패턴, QR 등이 있다.\"가 가장 적절하지 않은 설명이다. 이유는 패턴, QR 등은 주체를 대체하는 것이 아니라 주체의 소유물이나 지식을 나타내는 것이기 때문이다. 따라서 이 설명은 \"소유\"나 \"지식\"에 더 적절하다.",
  "choices" : "1.지식 : 주체는 '그가 알고 있는 것'을 보여주며 예시로는 패스워드, PIN 등이 있다./2.소유 : 주체는 '그가 가지고 있는 것'을 보여주며 예시로는 토큰, 스마트카드 등이 있다./3.존재 : 주체는 '그를 대체하는 것'을 보여주며 예시로는 패턴, QR 등이 있다./4.행위 : 주체는 '그가 하는 것'을 보여주며 예시로는 서명, 움직임, 음성 등이 있다./"
}, {
  "question" : "시스템의 사용자가 로그인하여 명령을 내리는 과정에 대한 시스템의 동작 중 다음 설명에 해당하는 것은?",
  "answer" : "4.Authentication",
  "commentary" : "이 과정은 사용자가 자신의 신원을 증명하고 인증받는 과정으로, \"Authentication\"에 해당한다.",
  "choices" : "1.Aging/2.Accounting/3.Authorization/4.Authentication/"
}, {
  "question" : "다음에서 설명하는 IT 기술은?",
  "answer" : "1.SDN(Software Defined Networking)",
  "commentary" : "위 그림은 SDN(Software Defined Networking)의 구조를 나타내고 있습니다. SDN은 네트워크 제어와 데이터 전송을 분리하여 네트워크를 소프트웨어로 관리하는 기술입니다. 이를 통해 네트워크 관리자는 네트워크를 더욱 유연하게 제어할 수 있으며, 네트워크의 구성과 관리가 용이해집니다. NFS(Network File System), Network Mapper, AOE Network는 모두 다른 네트워크 기술입니다.",
  "choices" : "1.SDN(Software Defined Networking)/2.NFS(Network File System)/3.Network Mapper/4.AOE Network/"
}, {
  "question" : "프로젝트 일정 관리 시 사용하는 PERT 차트에 대한 설명에 해당하는 것은?",
  "answer" : "4.작업들 간의 상호 관련성, 결정경로, 경계시간, 자원할당 등을 제시한다.",
  "commentary" : null,
  "choices" : "1.각 작업들이 언제 시작하고 언제 종료되는지에 대한 일정을 막대 도표를 이용하여 표시한다./2.시간선(Time-line) 차트라고도 한다./3.수평 막대의 길이는 각 작업의 기간을 나타낸다./4.작업들 간의 상호 관련성, 결정경로, 경계시간, 자원할당 등을 제시한다./"
}, {
  "question" : "User Interface 설계 시 오류 메시지나 경고에 관한 지침으로 가장 거리가 먼 것은?",
  "answer" : "4.소리나 색의 사용을 줄이고 텍스트로만 전달하도록 한다.",
  "commentary" : "소리나 색은 시각적이거나 청각적인 장애를 가진 사용자들에게는 전달이 어렵기 때문에, 텍스트로만 전달하는 것이 보다 접근성이 높은 방법이다. 따라서 UI 설계 시 오류 메시지나 경고는 가능한 한 텍스트로만 전달하도록 하는 것이 좋다.",
  "choices" : "1.메시지는 이해하기 쉬워야 한다./2.오류로부터 회복을 위한 구체적인 설명이 제공되어야 한다./3.오류로 인해 발생 될 수 있는 부정적인 내용을 적극적으로 사용자들에게 알려야 한다./4.소리나 색의 사용을 줄이고 텍스트로만 전달하도록 한다./"
}, {
  "question" : "다음 중 애자일(Agile) 소프트웨어 개발에 대한 설명으로 틀린 것은?",
  "answer" : "2.동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다.",
  "commentary" : "\"동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다.\"가 틀린 설명이다. 애자일 소프트웨어 개발은 동작하는 소프트웨어를 가장 우선시하며, 포괄적인 문서보다는 작동하는 소프트웨어에 더 가치를 둔다. 이는 고객의 요구사항에 더 빠르게 대응하고, 더 나은 제품을 만들기 위해 지속적인 피드백과 개선을 추구하기 때문이다.",
  "choices" : "1.공정과 도구보다 개인과의 상호작용을 더 가치 있게 여긴다./2.동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다./3.계약 협상보다는 고객과의 협력을 가치 있게 여긴다./4.계획을 따르기보다 변화에 대응하기를 가치 있게 여긴다./"
}, {
  "question" : "소프트웨어 설계에서 요구사항 분석에 대한 설명으로 틀린 것은?",
  "answer" : "3.소프트웨어 시스템이 사용되는 동안 발견되는 오류를 정리하는 단계이다.",
  "commentary" : "\"소프트웨어 시스템이 사용되는 동안 발견되는 오류를 정리하는 단계이다.\"가 틀린 것이다. 요구사항 분석은 사용자의 요구를 추출하여 목표를 정하고 어떤 방식으로 해결할 것인지 결정하는 단계이다. 즉, 소프트웨어가 무엇을 해야하는가를 추적하여 요구사항 명세를 작성하는 작업이다.",
  "choices" : "1.소프트웨어가 무엇을 해야하는가를 추적하여 요구사항 명세를 작성하는 작업이다./2.사용자의 요구를 추출하여 목표를 정하고 어떤 방식으로 해결할 것인지 결정하는 단계이다./3.소프트웨어 시스템이 사용되는 동안 발견되는 오류를 정리하는 단계이다./4.소프트웨어 개발의 출발점이면서 실질적인 첫 번째 단계이다./"
}, {
  "question" : "객체지향 기법에서 상위 클래스의 메소드와 속성을 하위 클래스가 물려받는 것을 의미하는 것은?",
  "answer" : "4.Inheritance",
  "commentary" : "하위 클래스가 상위 클래스의 메소드와 속성을 물려받는 것을 Inheritance라고 합니다. 이는 상위 클래스의 코드를 재사용하고, 하위 클래스에서는 상위 클래스의 기능을 확장하거나 변경할 수 있도록 합니다.",
  "choices" : "1.Abstraction/2.Polymorphism/3.Encapsulation/4.Inheritance/"
}, {
  "question" : "설계 기법 중 하향식 설계 방법과 상향식 설계 방법에 대한 비교 설명으로 가장 옳지 않은 것은?",
  "answer" : "4.상향식 설계에서는 인터페이스가 이미 성립되어 있지 않더라도 기능 추가가 쉽다.",
  "commentary" : "\"상향식 설계에서는 인터페이스가 이미 성립되어 있지 않더라도 기능 추가가 쉽다.\"는 옳은 설명이다. 상향식 설계에서는 모듈을 하나씩 추가하면서 전체 시스템을 구성하므로, 인터페이스가 완전히 정의되어 있지 않더라도 새로운 모듈을 추가하는 것이 비교적 쉽다. 하향식 설계에서는 이미 정의된 인터페이스를 기반으로 모듈을 구현하기 때문에, 인터페이스가 변경되면 모듈을 다시 구현해야 할 수도 있다.",
  "choices" : "1.하향식 설계에서는 통합 검사 시 인터페이스가 이미 정의되어 있어 통합이 간단하다./2.하향식 설계에서 레벨이 낮은 데이터 구조의 세부 사항은 설계초기 단계에서 필요하다./3.상향식 설계는 최하위 수준에서 각각의 모듈들을 설계하고 이러한 모듈이 완성되면 이들을 결합하여 검사한다./4.상향식 설계에서는 인터페이스가 이미 성립되어 있지 않더라도 기능 추가가 쉽다./"
}, {
  "question" : "자료흐름도(DFD)의 각 요소별 표기 형태의 연결이 옳지 않은 것은?",
  "answer" : "3.Data Store : 삼각형",
  "commentary" : "정답은 \"Data Flow : 화살표\"이다. 자료흐름도에서 데이터의 흐름을 나타내는 것은 화살표이며, 처리 과정을 나타내는 것은 원이다. 데이터 저장소를 나타내는 것은 삼각형이며, 시스템의 입출력을 나타내는 것은 사각형이다. 데이터 저장소를 삼각형으로 나타내는 이유는 데이터가 저장되는 곳이기 때문이다. 삼각형은 데이터가 쌓이는 모양을 가지고 있어서 이러한 형태로 표기된다. 또한, 데이터 저장소는 데이터의 입출력이 가능하므로 데이터 흐름도에서는 데이터 저장소와 데이터 흐름이 연결되어 있다.",
  "choices" : "1.Process : 원/2.Data Flow : 화살표/3.Data Store : 삼각형/4.Terminator : 사각형/"
}, {
  "question" : "소프트웨어 개발에 이용되는 모델(Model)에 대한 설명 중 거리가 먼 것은?",
  "answer" : "4.모델을 통해 향후 개발될 시스템의 유추는 불가능하다.",
  "commentary" : "\"모델을 통해 향후 개발될 시스템의 유추는 불가능하다.\"가 거리가 먼 설명이다. 이는 모델이 개발될 시스템의 일부분만을 표현하고 있기 때문에 완전한 시스템을 유추할 수 없기 때문이다. 모델은 개발 대상을 추상화하고 시각적으로 표현하여 이해도를 높이고 의사소통을 향상시키는데 활용된다.",
  "choices" : "1.모델은 개발 대상을 추상화하고 기호나 그림 등으로 시각적으로 표현한다./2.모델을 통해 소프트웨어에 대한 이해도를 향상시킬 수 있다./3.모델을 통해 이해 당사자 간의 의사소통이 향상된다./4.모델을 통해 향후 개발될 시스템의 유추는 불가능하다./"
}, {
  "question" : "다음의 설명에 해당하는 언어는?",
  "answer" : "3.UML",
  "commentary" : null,
  "choices" : "1.JAVA/2.C/3.UML/4.Python/"
}, {
  "question" : "다음 내용이 설명하는 UI설계 도구는?",
  "answer" : "2.목업(Mockup)",
  "commentary" : "이미지에서 보이는 것은 UI 디자인의 초기 단계에서 사용되는 도구로, 실제로 구현되지 않은 화면을 시각적으로 표현하는 것이다. 이를 통해 디자이너와 개발자는 디자인의 문제점을 파악하고 수정할 수 있다. 이러한 목적으로 사용되는 도구는 \"목업(Mockup)\"이다.",
  "choices" : "1.스토리보드(Storyboard)/2.목업(Mockup)/3.프로토타입(Prototype)/4.유스케이스(Usecase)/"
}, {
  "question" : "애자일(Agile) 기법 중 스크럼(Scrum)과 관련된 용어에 대한 설명이 틀린 것은?",
  "answer" : "3.스프린트(Sprint)는 하나의 완성된 최종 결과물을 만들기 위한 주기로 3달 이상의 장기간으로 결정된다.",
  "commentary" : "\"스프린트(Sprint)는 하나의 완성된 최종 결과물을 만들기 위한 주기로 3달 이상의 장기간으로 결정된다.\"가 틀린 설명입니다. 스프린트는 일반적으로 1주일에서 4주 사이의 짧은 주기로 결정되며, 하나의 완성된 결과물을 만들기 위한 주기입니다.",
  "choices" : "1.스크럼 마스터(Scrum Master)는 스크럼 프로세스를 따르고, 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등을 맡는다./2.제품 백로그(Product Backlog)는 스크럼 팀이 해결해야 하는 목록으로 소프트웨어 요구사항, 아키텍처 정의 등이 포함될 수 있다./3.스프린트(Sprint)는 하나의 완성된 최종 결과물을 만들기 위한 주기로 3달 이상의 장기간으로 결정된다./4.속도(Velocity)는 한 번의 스프린트에서 한 팀이 어느 정도의 제품 백로그를 감당할 수 있는지에 대한 추정치로 볼 수 있다./"
}, {
  "question" : "UML 다이어그램 중 정적 다이어그램이 아닌 것은?",
  "answer" : "3.순차 다이어그램",
  "commentary" : "순차 다이어그램은 시간의 흐름에 따라 객체들 간의 상호작용을 보여주는 동적 다이어그램으로, 정적인 구조를 보여주는 다른 다이어그램들과는 달리 객체들 간의 메시지 전송 순서를 보여줍니다. 따라서 정적인 구조를 보여주는 다른 다이어그램들과는 구분되어 정적 다이어그램이 아닙니다.",
  "choices" : "1.컴포넌트 다이어그램/2.배치 다이어그램/3.순차 다이어그램/4.패키지 다이어그램/"
}, {
  "question" : "LOC기법에 의하여 예측된 총 라인수가 36000라인, 개발에 참여할 프로그래머가 6명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간을 계산한 결과로 가장 옳은 것은?",
  "answer" : "4.20개월",
  "commentary" : "LOC 기법에 의해 예측된 총 라인수는 36000라인이며, 개발에 참여할 프로그래머가 6명이므로, 개발에 참여할 프로그래머 1명이 월간 생산성이 300라인이라면, 6명의 월간 생산성은 6 x 300 = 1800라인이 됩니다. 따라서, 전체 라인수 36000라인을 1800라인/월로 나누면 20개월이 소요됩니다. 따라서, 정답은 \"20개월\"입니다.",
  "choices" : "1.5개월/2.10개월/3.15개월/4.20개월/"
}, {
  "question" : "클래스 설계원칙에 대한 바른 설명은?",
  "answer" : "2.개방-폐쇄의 원칙 : 클래스는 확장에 대해 열려 있어야 하며 변경에 대해 닫혀 있어야 한다.",
  "commentary" : "개방-폐쇄의 원칙은 클래스가 확장에 대해 열려 있어야 하며 변경에 대해 닫혀 있어야 한다는 원칙입니다. 이는 새로운 기능이 추가되어도 기존 코드를 변경하지 않고 확장할 수 있도록 설계해야 한다는 것을 의미합니다. 따라서 클래스는 인터페이스를 통해 확장 가능하도록 설계되어야 하며, 기존 코드를 변경하지 않고도 새로운 기능을 추가할 수 있도록 해야 합니다.",
  "choices" : "1.단일 책임원칙 : 하나의 클래스만 변경 가능 해야한다./2.개방-폐쇄의 원칙 : 클래스는 확장에 대해 열려 있어야 하며 변경에 대해 닫혀 있어야 한다./3.리스코프 교체의 원칙 : 여러 개의 책임을 가진 클래스는 하나의 책임을 가진 클래스로 대체되어야 한다./4.의존관계 역전의 원칙 : 클라이언트는 자신이 사용하는 메소드와 의존관계를 갖지 않도록 해야 한다./"
}, {
  "question" : "GoF(Gangs of Four) 디자인 패턴에서 생성(Creational) 패턴에 해당하는 것은?",
  "answer" : "3.추상 팩토리(Abstract Factory)",
  "commentary" : "추상 팩토리는 객체 생성에 관련된 패턴으로, 관련성 있는 객체들을 생성하기 위한 인터페이스를 제공하고, 이를 구현하는 구체적인 팩토리 클래스를 통해 객체를 생성하는 방식입니다. 따라서 생성(Creational) 패턴에 해당합니다.",
  "choices" : "1.컴퍼지트(Composite)/2.어댑터(Adapter)/3.추상 팩토리(Abstract Factory)/4.옵서버(Observer)/"
}, {
  "question" : "아키텍처 설계과정이 올바른 순서로 나열된 것은?",
  "answer" : "1.㉮ → ㉯ → ㉰ → ㉱ → ㉲",
  "commentary" : "아키텍처 설계 과정은 크게 요구사항 수집, 아키텍처 설계, 아키텍처 검증, 아키텍처 구현으로 나눌 수 있습니다. ㉮ 요구사항 수집: 시스템이 제공해야 할 기능과 비기능적 요구사항을 수집하고 분석합니다. 이 단계에서는 시스템의 목적과 범위를 파악하고, 사용자와 시스템 간의 인터페이스, 데이터 흐름, 보안 등을 고려합니다. ㉯ 아키텍처 설계: 수집된 요구사항을 바탕으로 시스템의 전체 구조와 구성요소들 간의 관계를 설계합니다. 이 단계에서는 시스템의 기능적 요구사항을 만족시키기 위한 아키텍처 패턴, 프레임워크, 기술 스택 등을 선택하고, 시스템의 성능, 확장성, 유지보수성 등을 고려합니다. ㉰ 아키텍처 검증: 설계한 아키텍처가 요구사항을 충족시키는지 검증합니다. 이 단계에서는 아키텍처의 일부 또는 전체를 시뮬레이션하거나 프로토타입을 만들어 검증합니다. ㉱ 아키텍처 구현: 검증된 아키텍처를 바탕으로 시스템을 구현합니다. 이 단계에서는 아키텍처 설계서를 바탕으로 코드를 작성하고, 테스트를 수행하여 시스템이 요구사항을 만족시키는지 확인합니다. ㉲ 아키텍처 관리: 시스템이 운영되는 동안 아키텍처를 관리하고 유지보수합니다. 이 단계에서는 시스템의 변경사항을 반영하고, 문제가 발생할 경우 대처합니다. 따라서, 올바른 순서는 \"㉮ → ㉯ → ㉰ → ㉱ → ㉲\" 입니다. 요구사항 수집부터 아키텍처 설계, 검증, 구현, 관리까지 순서대로 진행되어야 하기 때문입니다.",
  "choices" : "1.㉮ → ㉯ → ㉰ → ㉱ → ㉲/2.㉲ → ㉮ → ㉯ → ㉱ → ㉰/3.㉮ → ㉲ → ㉯ → ㉱ → ㉰/4.㉮ → ㉯ → ㉰ → ㉲ → ㉱/"
}, {
  "question" : "사용자 인터페이스를 설계할 경우 고려해야 할 가이드라인과 가장 거리가 먼 것은?",
  "answer" : "1.심미성을 사용성보다 우선하여 설계해야 한다.",
  "commentary" : "심미성을 사용성보다 우선하여 설계하는 것은 사용자가 인터페이스를 보기 좋게 느끼는 것이 중요하다고 생각하는 것이지만, 실제로는 사용자가 인터페이스를 쉽게 이해하고 사용할 수 있어야 한다는 것이 더욱 중요하다. 따라서 사용성을 우선하여 설계해야 한다.",
  "choices" : "1.심미성을 사용성보다 우선하여 설계해야 한다./2.효율성을 높이게 설계해야 한다./3.발생하는 오류를 쉽게 수정할 수 있어야 한다./4.사용자에게 피드백을 제공해야 한다./"
}, {
  "question" : "소프트웨어 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법을 무엇이라고 하는가?",
  "answer" : "2.디자인 패턴",
  "commentary" : "디자인 패턴은 소프트웨어 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법을 정형화한 것이다. 이를 사용하면 개발자들은 비슷한 문제를 해결할 때마다 처음부터 새로운 해결책을 찾지 않아도 되므로 개발 시간과 비용을 절약할 수 있다. 따라서 디자인 패턴은 소프트웨어 개발에서 매우 중요한 개념이다.",
  "choices" : "1.모듈 분해/2.디자인 패턴/3.연관 관계/4.클래스 도출/"
}, {
  "question" : "객체지향 분석기법의 하나로 객체 모형, 동적 모형, 기능 모형의 3개 모형을 생성하는 방법은?",
  "answer" : "2.Rumbaugh Method",
  "commentary" : "객체지향 분석기법에서 Rumbaugh Method는 객체 모형, 동적 모형, 기능 모형의 3개 모형을 생성하는 방법입니다. 이 방법은 객체지향 분석과 설계를 위한 UML(Unified Modeling Language)을 개발한 Grady Booch, James Rumbaugh, Ivar Jacobson 세 사람 중 하나인 James Rumbaugh가 개발한 방법으로, 객체 모형은 클래스 다이어그램으로, 동적 모형은 시퀀스 다이어그램으로, 기능 모형은 상태 다이어그램으로 표현합니다. 따라서 Rumbaugh Method가 정답입니다.",
  "choices" : "1.Wirfs-Block Method/2.Rumbaugh Method/3.Booch Method/4.Jacobson Method/"
}, {
  "question" : "입력되는 데이터를 컴퓨터의 프로세서가 처리하기 전에 미리 처리하여 프로세서가 처리하는 시간을 줄여주는 프로그램이나 하드웨어를 말하는 것은?",
  "answer" : "2.FEP",
  "commentary" : "정답은 \"FEP\"입니다. FEP는 Front-End Processor의 약자로, 입력되는 데이터를 미리 처리하여 프로세서가 처리하는 시간을 줄여주는 하드웨어나 소프트웨어를 말합니다. 이는 컴퓨터의 성능을 향상시키고, 처리 속도를 높이는 데에 큰 역할을 합니다. 따라서, EAI는 기업 애플리케이션 통합, GPL은 일반 공중 라이선스, Duplexing은 이중화를 의미하므로, 이들은 FEP와는 관련이 없습니다.",
  "choices" : "1.EAI/2.FEP/3.GPL/4.Duplexing/"
}, {
  "question" : "객체 지향 개념 중 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화를 의미하는 것은?",
  "answer" : "2.Class",
  "commentary" : "Class는 객체 지향 프로그래밍에서 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화를 의미합니다. 즉, 객체를 생성하기 위한 틀이라고 할 수 있으며, 객체의 속성과 행위를 정의하는데 사용됩니다. Method는 클래스나 객체가 가지고 있는 기능을 정의하는 것이고, Field는 클래스나 객체가 가지고 있는 속성을 정의하는 것입니다. Message는 객체 간의 상호작용을 나타내는 것입니다.",
  "choices" : "1.Method/2.Class/3.Field/4.Message/"
}, {
  "question" : "클린 코드(Clean Code)를 작성하기 위한 원칙으로 틀린 것은?",
  "answer" : "1.추상화 : 하위 클래스/메소드/함수를 통해 애플리케이션의 특성을 간략하게 나타내고, 상세 내용은 상위 클래스/메소드/함수에서 구현한다.",
  "commentary" : "추상화 : 하위 클래스/메소드/함수를 통해 애플리케이션의 특성을 간략하게 나타내고, 상세 내용은 상위 클래스/메소드/함수에서 구현한다. 이것이 틀린 것은 아니다. 추상화는 객체 지향 프로그래밍에서 중요한 개념 중 하나로, 객체들의 공통적인 특성을 추출하여 상위 클래스나 인터페이스로 정의하는 것을 말한다. 이를 통해 코드의 재사용성과 유지보수성을 높일 수 있다.",
  "choices" : "1.추상화 : 하위 클래스/메소드/함수를 통해 애플리케이션의 특성을 간략하게 나타내고, 상세 내용은 상위 클래스/메소드/함수에서 구현한다./2.의존성 : 다른 모듈에 미치는 영향을 최소화하도록 작성한다./3.가독성 : 누구든지 읽기 쉽게 코드를 작성한다./4.중복성 : 중복을 최소화 할 수 있는 코드를 작성한다./"
}, {
  "question" : "단위 테스트에서 테스트의 대상이 되는 하위 모듈을 호출하고, 파라미터를 전달하는 가상의 모듈로 상향식 테스트에 필요한 것은?",
  "answer" : "2.테스트 드라이버(Test Driver)",
  "commentary" : "하위 모듈을 호출하고 파라미터를 전달하는 가상의 모듈은 테스트 스텁(Test Stub)이다. 하지만 상향식 테스트에서는 테스트 스텁 뿐만 아니라 테스트 드라이버(Test Driver)도 필요하다. 테스트 드라이버는 상위 모듈을 호출하고 하위 모듈에 전달할 파라미터를 생성하는 역할을 한다. 따라서 테스트 스텁은 하위 모듈을 대신하고, 테스트 드라이버는 상위 모듈을 대신하여 테스트를 수행하는 데 필요한 가상의 모듈이다.",
  "choices" : "1.테스트 스텁(Test Stub)/2.테스트 드라이버(Test Driver)/3.테스트 슈트(Test Suites)/4.테스트 케이스(Test Case)/"
}, {
  "question" : "스택(Stack)에 대한 옳은 내용으로만 나열된 것은?",
  "answer" : "3.㉣",
  "commentary" : "㉣은 스택의 특징 중 하나인 후입선출(LIFO) 구조를 잘 나타내고 있기 때문입니다. 스택은 가장 최근에 삽입된 데이터가 가장 먼저 삭제되는 구조를 가지고 있습니다. 따라서 ㉣은 스택의 특징을 가장 잘 나타내고 있습니다.",
  "choices" : "1.㉠, ㉡/2.㉡, ㉢/3.㉣/4.㉠, ㉡, ㉢, ㉣/"
}, {
  "question" : "소프트웨어 모듈화의 장점이 아닌 것은?",
  "answer" : "2.기능의 분리가 가능하여 인터페이스가 복잡하다.",
  "commentary" : "소프트웨어 모듈화를 통해 기능을 분리하면 오류의 파급 효과를 최소화할 수 있고, 모듈의 재사용 가능으로 개발과 유지보수가 용이해지며, 프로그램의 효율적인 관리가 가능해진다. 따라서, \"기능의 분리가 가능하여 인터페이스가 복잡하다.\"는 장점이 아닌 단점이다. 기능을 분리하면 인터페이스가 간단해지는 것이 일반적이다.",
  "choices" : "1.오류의 파급 효과를 최소화한다./2.기능의 분리가 가능하여 인터페이스가 복잡하다./3.모듈의 재사용 가능으로 개발과 유지보수가 용이하다./4.프로그램의 효율적인 관리가 가능하다./"
}, {
  "question" : "소프트웨어 프로젝트 관리에 대한 설명으로 가장 옳은 것은?",
  "answer" : "4.주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발",
  "commentary" : "소프트웨어 프로젝트 관리에서 가장 중요한 목표는 주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발하는 것입니다. 이는 프로젝트의 성공을 보장하며, 개발자와 사용자 모두에게 이익을 제공합니다. 따라서 개발에 따른 산출물 관리와 소요인력 최대화, 정책 결정 신속 처리, 주어진 기간 연장 등은 모두 이 목표를 달성하기 위한 방법으로 고려될 수 있습니다.",
  "choices" : "1.개발에 따른 산출물 관리/2.소요인력은 최대화하되 정책 결정은 신속하게 처리/3.주어진 기간은 연장하되 최소의 비용으로 시스템을 개발/4.주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발/"
}, {
  "question" : "정형 기술 검토(FTR)의 지침으로 틀린 것은?",
  "answer" : "4.참가자의 수를 제한하지 않는다.",
  "commentary" : "정형 기술 검토(FTR)는 가능한 많은 참가자가 참여하여 다양한 시각과 경험을 공유하고, 논쟁과 반박을 통해 문제를 해결하기 위한 방법론이다. 따라서 참가자의 수를 제한하지 않는 것이 올바른 지침이다.",
  "choices" : "1.의제를 제한한다./2.논쟁과 반박을 제한한다./3.문제 영역을 명확히 표현한다./4.참가자의 수를 제한하지 않는다./"
}, {
  "question" : "소프트웨어 재공학의 주요 활동 중 기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업을 의미하는 것은?",
  "answer" : "2.Migration",
  "commentary" : "주어진 문제에서 설명하는 작업은 \"기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업\"이다. 이러한 작업은 \"Migration\"으로 불린다. 따라서 정답은 \"Migration\"이다.",
  "choices" : "1.Analysis/2.Migration/3.Restructuring/4.Reverse Engineering/"
}, {
  "question" : "정보시스템 개발 단계에서 프로그래밍 언어 선택 시 고려할 사항으로 가장 거리가 먼 것은?",
  "answer" : "4.컴파일러의 독창성",
  "commentary" : "컴파일러의 독창성은 프로그래밍 언어 선택 시 고려할 필요가 없는 사항입니다. 컴파일러의 독창성이란, 컴파일러가 언어의 특정 기능을 지원하는 정도나 방식이 다른 컴파일러와 차이가 있는 것을 의미합니다. 하지만 이는 개발자가 직접 컴파일러를 개발하는 경우에만 고려해야 할 사항이며, 대부분의 경우에는 이미 개발된 컴파일러를 사용하기 때문에 고려할 필요가 없습니다. 따라서 정답은 \"컴파일러의 독창성\"입니다.",
  "choices" : "1.개발 정보시스템의 특성/2.사용자의 요구사항/3.컴파일러의 가용성/4.컴파일러의 독창성/"
}, {
  "question" : "소프트웨어 패키징에 대한 설명으로 틀린 것은?",
  "answer" : "1.패키징은 개발자 중심으로 진행한다.",
  "commentary" : "정답은 \"패키징은 개발자 중심으로 진행한다.\" 이다. 이유는 패키징은 개발자뿐만 아니라 다양한 역할을 수행하는 인력들이 함께 참여하여 진행되기 때문이다. 예를 들어, 품질관리팀은 테스트를 수행하고, 문서작성팀은 매뉴얼을 작성하며, 배포관리팀은 배포를 담당한다. 따라서 패키징은 다양한 역할의 인력들이 협업하여 진행되는 과정이다.",
  "choices" : "1.패키징은 개발자 중심으로 진행한다./2.신규 및 변경 개발소스를 식별하고, 이를 모듈화하여 상용제품으로 패키징한다./3.고객의 편의성을 위해 매뉴얼 및 버전관리를 지속적으로 한다./4.범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 패키징이 진행된다./"
}, {
  "question" : "자료 구조의 분류 중 선형 구조가 아닌 것은?",
  "answer" : "1.트리",
  "commentary" : "트리는 계층적인 구조를 가지며, 부모와 자식 노드 간의 관계가 존재하기 때문에 선형 구조가 아닙니다. 반면 리스트, 스택, 데크는 모두 선형 구조를 가지고 있습니다.",
  "choices" : "1.트리/2.리스트/3.스택/4.데크/"
}, {
  "question" : "아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 아주 어려운 프로그램을 의미하는 것은?",
  "answer" : "4.Alien Code",
  "commentary" : "\"Alien Code\"는 개발자가 없거나 참고문서가 없어 유지보수가 어려운 프로그램을 의미합니다. 이는 다른 보기인 \"Title Code\", \"Source Code\", \"Object Code\"와는 달리 프로그램의 상태나 구조를 이해하기 어렵기 때문입니다. 따라서 유지보수나 수정 작업이 매우 어려워지며, 이로 인해 시스템의 안정성과 보안에도 문제가 발생할 수 있습니다.",
  "choices" : "1.Title Code/2.Source Code/3.Object Code/4.Alien Code/"
}, {
  "question" : "소프트웨어를 재사용함으로써 얻을 수 있는 이점으로 가장 거리가 먼 것은?",
  "answer" : "4.새로운 개발 방법론 도입 용이",
  "commentary" : "소프트웨어를 재사용함으로써 얻을 수 있는 이점 중에서 \"새로운 개발 방법론 도입 용이\"는 다른 이점들과는 달리 직접적인 경제적 이점이 아니기 때문에 가장 거리가 먼 것입니다. 소프트웨어를 재사용하면 이미 검증된 코드를 활용할 수 있기 때문에 개발 시간과 비용을 절약할 수 있습니다. 이는 생산성 증가와 프로젝트 문서 공유, 소프트웨어 품질 향상과 같은 다른 이점들과 연결되어 있습니다. 하지만 \"새로운 개발 방법론 도입 용이\"는 이러한 경제적 이점과는 직접적인 연관성이 없습니다. 새로운 개발 방법론을 도입하면 개발 프로세스를 개선하고 효율성을 높일 수 있습니다. 이는 소프트웨어 재사용과는 별개의 이점으로, 다른 이점들과는 달리 경제적인 이점보다는 기술적인 이점에 더 초점을 둔 것입니다.",
  "choices" : "1.생산성 증가/2.프로젝트 문서 공유/3.소프트웨어 품질 향상/4.새로운 개발 방법론 도입 용이/"
}, {
  "question" : "인터페이스 간의 통신을 위해 이용되는 데이터 포맷이 아닌 것은?",
  "answer" : "1.AJTML",
  "commentary" : "\"AJTML\"은 실제로 존재하지 않는 데이터 포맷이기 때문에 인터페이스 간의 통신을 위해 이용되지 않습니다. 따라서 정답은 \"AJTML\"입니다.",
  "choices" : "1.AJTML/2.JSON/3.XML/4.YAML/"
}, {
  "question" : "프로그램 설계도의 하나인 NS Chart에 대한 설명으로 가장 거리가 먼 것은?",
  "answer" : "3.화살표나 GOTO를 사용하여 이해하기 쉽다.",
  "commentary" : "NS Chart는 제어 논리 구조를 도형으로 표현하는 프로그램 설계도이다. 이해하기 쉽고 코드 변환이 용이하며, 연속, 선택, 반복 등의 제어 논리 구조를 표현한다는 것은 모두 NS Chart의 특징이다. 하지만 \"화살표나 GOTO를 사용하여 이해하기 쉽다.\"는 옳지 않은 설명이다. NS Chart에서는 GOTO문을 사용하지 않으며, 화살표는 단순히 도형 간의 연결을 나타내는 것이지 제어 흐름을 나타내는 것은 아니다. 따라서 이 설명은 거리가 먼 것이다.",
  "choices" : "1.논리의 기술에 중점을 두고 도형을 이용한 표현 방법이다./2.이해하기 쉽고 코드 변환이 용이하다./3.화살표나 GOTO를 사용하여 이해하기 쉽다./4.연속, 선택, 반복 등의 제어 논리 구조를 표현한다./"
}, {
  "question" : "순서가 A, B, C, D로 정해진 입력자료를 push, push, pop, push, push, pop, pop, pop 순서로 스택연산을 수행하는 경우 출력 결과는?",
  "answer" : "1.B D C A",
  "commentary" : "스택은 후입선출(LIFO) 구조이므로, push 연산은 스택의 맨 위에 값을 추가하고, pop 연산은 스택의 맨 위 값을 제거하면서 반환한다. 따라서, 주어진 연산 순서에 따라 스택에 쌓이는 값들은 다음과 같다. 1. push A -> [A] 2. push B -> [B, A] 3. pop -> [A] 4. push C -> [C, A] 5. push D -> [D, C, A] 6. pop -> [C, A] 7. pop -> [A] 8. pop -> [] 따라서, 스택에서 pop 되는 값들의 순서는 \"B D C A\" 이다.",
  "choices" : "1.B D C A/2.A B C D/3.B A C D/4.A B D C/"
}, {
  "question" : "분할 정복(Divide and Conquer)에 기반한 알고리즘으로 피벗(pivot)을 사용하며 최악의 경우 회의 비교를 수행해야 하는 정렬(Sort)은?",
  "answer" : "4.Quick Sort",
  "commentary" : "Quick Sort는 분할 정복 알고리즘을 사용하여 리스트를 정렬하는 알고리즘이다. 리스트에서 피벗(pivot)을 선택하고 피벗을 기준으로 리스트를 분할한 후, 각각의 부분 리스트를 재귀적으로 정렬하는 방식으로 동작한다. 이 때, 피벗을 선택하는 방법에 따라 최악의 경우 시간복잡도가 O(n^2)이 될 수 있지만, 평균적으로는 O(nlogn)의 시간복잡도를 가진다. 따라서, 회의 비교를 수행해야 하는 정렬 문제에서는 Quick Sort가 가장 적합한 알고리즘이다.",
  "choices" : "1.Selection Sort/2.Bubble Sort/3.Insert Sort/4.Quick Sort/"
}, {
  "question" : "화이트 박스 검사 기법에 해당하는 것으로만 짝지어진 것은?",
  "answer" : "1.㉠, ㉡",
  "commentary" : "화이트 박스 검사 기법은 코드의 내부 구조를 검사하는 기법이다. 따라서 코드의 내부 구조를 파악할 수 있는 \"제어 흐름도\"와 \"소스 코드\"가 필요하다. 이에 따라 보기에서 \"제어 흐름도\"와 \"소스 코드\"가 함께 포함된 ㉠와 ㉡이 화이트 박스 검사 기법에 해당한다.",
  "choices" : "1.㉠, ㉡/2.㉠, ㉣/3.㉡, ㉤/4.㉢, ㉥/"
}, {
  "question" : "소프트웨어 품질 관련 국제 표준인 ISO/IEC 25000에 관한 설명으로 옳지 않은 것은?",
  "answer" : "3.ISO/IEC 2501n에서는 소프트웨어의 내부 측정, 외부측정, 사용품질 측정, 품질 측정 요소 등을 다룬다.",
  "commentary" : "ISO/IEC 2501n에서는 소프트웨어의 내부 측정, 외부측정, 사용품질 측정, 품질 측정 요소 등을 다룬다는 설명이 옳지 않습니다. ISO/IEC 25000은 소프트웨어 품질 평가를 위한 통합 모델 표준으로, SQuaRE라고도 불리며 기존의 ISO/IEC 9126과 ISO/IEC 14598을 통합한 모델입니다. 이 모델은 소프트웨어 품질 평가를 위한 프로세스와 요구사항, 측정 및 평가를 다루며, 내부 측정, 외부 측정, 사용자 품질 측정 등을 포함합니다.",
  "choices" : "1.소프트웨어 품질 평가를 위한 소프트웨어 품질평가 통합모델 표준이다./2.System and Software Quality Requirements and Evaluation으로 줄여서 SQuaRE라고도 한다./3.ISO/IEC 2501n에서는 소프트웨어의 내부 측정, 외부측정, 사용품질 측정, 품질 측정 요소 등을 다룬다./4.기존 소프트웨어 품질 평가 모델과 소프트웨어 평가 절차 모델인 ISO/IEC 9126과 ISO/IEC 14598을 통합하였다./"
}, {
  "question" : "코드 인스펙션과 관련한 설명으로 틀린 것은?",
  "answer" : "3.동적 테스트 시에만 활용하는 기법이다.",
  "commentary" : "\"동적 테스트 시에만 활용하는 기법이다.\"는 틀린 설명입니다. 코드 인스펙션은 정적 분석 기법으로, 프로그램을 실행시키지 않고 코드를 분석하여 결함 및 코드 품질을 검사하는 기법입니다. 따라서 정답은 \"동적 테스트 시에만 활용하는 기법이다.\"가 아닌 \"정적 분석 기법으로, 프로그램을 실행시키지 않고 코드를 분석하여 결함 및 코드 품질을 검사하는 기법이다.\"입니다.",
  "choices" : "1.프로그램을 수행시켜보는 것 대신에 읽어보고 눈으로 확인하는 방법으로 볼 수 있다./2.코드 품질 향상 기법 중 하나이다./3.동적 테스트 시에만 활용하는 기법이다./4.결함과 함께 코딩 표준 준수 여부, 효율성 등의 다른 품질 이슈를 검사하기도 한다./"
}, {
  "question" : "프로젝트에 내재된 위험 요소를 인식하고 그 영향을 분석하여 이를 관리하는 활동으로서, 프로젝트를 성공시키기 위하여 위험 요소를 사전에 예측, 대비하는 모든 기술과 활동을 포함하는 것은?",
  "answer" : "2.Risk Analysis",
  "commentary" : "위험 분석은 프로젝트에 내재된 위험 요소를 사전에 예측하고 대비하는 활동으로, 프로젝트를 성공시키기 위한 중요한 기술입니다. 따라서 정답은 \"Risk Analysis\"입니다. 다른 보기들은 프로젝트 관리에서 중요한 기술이지만, 위험 분석과는 직접적인 연관성이 적습니다.",
  "choices" : "1.Critical Path Method/2.Risk Analysis/3.Work Breakdown Structure/4.Waterfall Model/"
}, {
  "question" : "데이터베이스 설계 단계 중 물리적 설계 시 고려 사항으로 적절하지 않은 것은?",
  "answer" : "1.스키마의 평가 및 정제",
  "commentary" : "스키마의 평가 및 정제는 데이터베이스 설계 단계 중 논리적 설계 단계에서 이루어지는 작업이므로 물리적 설계 시 고려 사항으로 적절하지 않습니다. 물리적 설계 시에는 응답 시간, 저장 공간의 효율화, 트랜잭션 처리량 등의 성능과 관련된 요소들을 고려하여 최적화된 데이터베이스 구조를 설계해야 합니다.",
  "choices" : "1.스키마의 평가 및 정제/2.응답 시간/3.저장 공간의 효율화/4.트랜잭션 처리량/"
}, {
  "question" : "DELETE 명령에 대한 설명으로 틀린 것은?",
  "answer" : "2.WHERE 조건절이 없는 DELETE 명령을 수행하면 DROP TABLE 명령을 수행했을 때와 동일한 효과를 얻을 수 있다.",
  "commentary" : "\"WHERE 조건절이 없는 DELETE 명령을 수행하면 DROP TABLE 명령을 수행했을 때와 동일한 효과를 얻을 수 있다.\"라는 설명이 틀립니다. DELETE 명령은 테이블의 행을 삭제하는 명령이며, WHERE 조건절을 사용하지 않으면 모든 행이 삭제됩니다. DROP TABLE 명령은 테이블 자체를 삭제하는 명령입니다. 따라서 WHERE 조건절이 없는 DELETE 명령과 DROP TABLE 명령은 서로 다른 효과를 가집니다.",
  "choices" : "1.테이블의 행을 삭제할 때 사용한다./2.WHERE 조건절이 없는 DELETE 명령을 수행하면 DROP TABLE 명령을 수행했을 때와 동일한 효과를 얻을 수 있다./3.SQL을 사용 용도에 따라 분류할 경우 DML에 해당한다./4.기본 사용 형식은 “DELETE FROM 테이블 [WHERE 조건];” 이다./"
}, {
  "question" : "어떤 릴레이션 R의 모든 조인 종속성의 만족이 R의 후보 키를 통해서만 만족될 때, 이 릴레이션 R이 해당하는 정규형은?",
  "answer" : "1.제5정규형",
  "commentary" : "이 릴레이션 R은 모든 조인 종속성이 후보 키를 통해서만 만족되므로, R은 다중값 종속성을 가지고 있습니다. 다중값 종속성을 제거하기 위해서는 R을 분해하여 새로운 릴레이션들을 생성해야 합니다. 이때, 새로운 릴레이션들은 모두 후보 키를 포함하게 됩니다. 이러한 분해 과정을 반복하여 모든 릴레이션이 후보 키를 가지게 되면, 이 릴레이션 R은 제5정규형입니다. 제5정규형은 다중값 종속성을 제거한 최고 수준의 정규형입니다.",
  "choices" : "1.제5정규형/2.제4정규형/3.제3정규형/4.제1정규형/"
}, {
  "question" : "E-R 모델에서 다중값 속성의 표기법은?",
  "answer" : "3.",
  "commentary" : "다중값 속성의 표기법은 반직선으로 표시한다. 이는 속성 값이 여러 개일 수 있음을 나타내며, 반직선의 끝 부분에 \"M\"이라는 표시를 함으로써 다중값 속성임을 명시한다. 따라서 \"\"이 정답이다.",
  "choices" : "1./2./3./4./"
}, {
  "question" : "다른 릴레이션의 기본키를 참조하는 키를 의미하는 것은?",
  "answer" : "3.외래키",
  "commentary" : "외래키는 다른 릴레이션의 기본키를 참조하는 키를 의미합니다. 즉, 한 릴레이션의 특정 필드가 다른 릴레이션의 기본키를 참조하면서 그 릴레이션과의 관계를 맺을 때 사용하는 키입니다. 이를 통해 두 릴레이션 간의 관계를 설정하고 데이터를 효율적으로 관리할 수 있습니다.",
  "choices" : "1.필드키/2.슈퍼키/3.외래키/4.후보키/"
}, {
  "question" : "관계해석에서 '모든 것에 대하여'의 의미를 나타내는 논리 기호는?",
  "answer" : "3.∀",
  "commentary" : "\"∀\"는 \"모든 것에 대하여\"의 의미를 나타내는 논리 기호입니다. 이는 모든 개체나 조건이 참인 경우를 나타내며, \"모든\"이라는 의미를 강조하기 위해 사용됩니다. 예를 들어, \"모든 학생은 공부해야 한다\"라는 명제는 \"∀\" 기호로 표현할 수 있습니다.",
  "choices" : "1.∃/2.∈/3.∀/4.⊂/"
}, {
  "question" : "다음 릴레이션의 Degree와 Cardinality는?",
  "answer" : "1.Degree : 4, Cardinality : 3",
  "commentary" : "이 릴레이션은 4개의 속성(A, B, C, D)으로 이루어져 있으므로 Degree는 4이고, 릴레이션에는 3개의 튜플이 존재하므로 Cardinality는 3이다.",
  "choices" : "1.Degree : 4, Cardinality : 3/2.Degree : 3, Cardinality : 4/3.Degree : 3, Cardinality : 12/4.Degree : 12, Cardinality : 3/"
}, {
  "question" : "뷰(View)에 대한 설명으로 틀린 것은?",
  "answer" : "4.SQL을 사용하면 뷰에 대한 삽입, 갱신, 삭제 연산 시 제약 사항이 없다.",
  "commentary" : "SQL을 사용하면 뷰에 대한 삽입, 갱신, 삭제 연산 시 제약 사항이 없는 것은 틀린 설명입니다. 뷰는 가상의 테이블이므로 실제 데이터를 가지고 있지 않습니다. 따라서 뷰에 대한 삽입, 갱신, 삭제 연산은 뷰를 정의하는 기본 테이블에 영향을 미치므로 제약 사항이 있습니다.",
  "choices" : "1.뷰 위에 또 다른 뷰를 정의할 수 있다./2.DBA는 보안성 측면에서 뷰를 활용할 수 있다./3.사용자가 필요한 정보를 요구에 맞게 가공하여 뷰로 만들 수 있다./4.SQL을 사용하면 뷰에 대한 삽입, 갱신, 삭제 연산 시 제약 사항이 없다./"
}, {
  "question" : "관계 대수식을 SQL 질의로 옳게 표현한 것은?",
  "answer" : "2.SELECT 이름 FROM 학생 WHERE 학과='교육';",
  "commentary" : "주어진 관계에서 학생의 이름을 선택하고, 그 중에서도 학과가 '교육'인 학생들만 선택하도록 WHERE 조건을 추가한 것이므로 \"SELECT 이름 FROM 학생 WHERE 학과='교육';\"가 옳은 SQL 질의이다.",
  "choices" : "1.SELECT 학생 FROM 이름 WHERE 학과='교육';/2.SELECT 이름 FROM 학생 WHERE 학과='교육';/3.SELECT 교육 FROM 학과 WHERE 이름='학생';/4.SELECT 학과 FROM 학생 WHERE 이름='교육';/"
}, {
  "question" : "정규화 과정에서 함수 종속이 A→B 이고 B→C 일 때 A→C인 관계를 제거하는 단계는?",
  "answer" : "2.2NF → 3NF",
  "commentary" : "2NF에서는 부분 함수 종속을 제거하고, 3NF에서는 이행적 함수 종속을 제거하여 A→C 관계를 제거합니다. 따라서 정답은 \"2NF → 3NF\"입니다. 2NF에서는 모든 속성이 기본키에 대해 완전 함수 종속을 가져야 하므로, A→B, B→C의 경우 B가 기본키에 포함되어 있지 않으면 부분 함수 종속이 발생합니다. 이를 제거하기 위해 2NF에서는 B를 기본키로 하는 새로운 릴레이션을 생성합니다. 그리고 3NF에서는 이행적 함수 종속을 제거하여 A→C 관계를 제거합니다. 이를 위해 B→C의 경우 B를 기본키로 하는 새로운 릴레이션을 생성합니다.",
  "choices" : "1.1NF → 2NF/2.2NF → 3NF/3.3NF → BCNF/4.BCNF → 4NF/"
}, {
  "question" : "CREATE TABLE문에 포함되지 않는 기능은?",
  "answer" : "1.속성 타입 변경",
  "commentary" : "CREATE TABLE문은 테이블을 생성하는 명령어로, 테이블의 속성들을 정의하고 제약조건을 설정하는 등의 기능을 포함한다. 그러나 속성 타입 변경은 이미 생성된 테이블의 속성을 수정하는 작업으로, CREATE TABLE문에는 포함되지 않는다. 따라서 \"속성 타입 변경\"이 정답이다.",
  "choices" : "1.속성 타입 변경/2.속성의 NOT NULL 여부 지정/3.기본키를 구성하는 속성 지정/4.CHECK 제약조건의 정의/"
}, {
  "question" : "SQL과 관련한 설명으로 틀린 것은?",
  "answer" : "1.REVOKE 키워드를 사용하여 열 이름을 다시 부여할 수 있다.",
  "commentary" : "\"REVOKE 키워드를 사용하여 열 이름을 다시 부여할 수 있다.\"는 틀린 설명입니다. REVOKE는 권한을 취소하는 데 사용되는 키워드이며, 열 이름을 다시 부여하는 것은 ALTER TABLE RENAME COLUMN을 사용해야 합니다.",
  "choices" : "1.REVOKE 키워드를 사용하여 열 이름을 다시 부여할 수 있다./2.데이터 정의어는 기본 테이블, 뷰 테이블, 또는 인덱스 등을 생성, 변경, 제거하는데 사용되는 명령어이다./3.DISTINCT를 활용하여 중복 값을 제거할 수 있다./4.JOIN을 통해 여러 테이블의 레코드를 조합하여 표현할 수 있다./"
}, {
  "question" : "다음 SQL문의 실행결과로 생성되는 튜플 수는?",
  "answer" : "4.5",
  "commentary" : null,
  "choices" : "1.1/2.3/3.4/4.5/"
}, {
  "question" : "다음 SQL문에서 사용된 BETWEEN 연산의 의미와 동일한 것은?",
  "answer" : "1.점수 ＞= 90 AND 점수 ＜= 95",
  "commentary" : "BETWEEN 연산은 주어진 범위 내에 있는 값을 선택하는 연산이다. 예를 들어, BETWEEN 1 AND 10은 1부터 10까지의 값을 선택한다는 의미이다. 따라서 \"점수 ＞= 90 AND 점수 ＜= 95\"는 90부터 95까지의 값을 선택하는 것이다. 이유는 BETWEEN 연산에서는 주어진 범위의 양 끝 값도 포함되기 때문이다.",
  "choices" : "1.점수 ＞= 90 AND 점수 ＜= 95/2.점수 ＞ 90 AND 점수 ＜ 95/3.점수 ＞ 90 AND 점수 ＜= 95/4.점수 ＞= 90 AND 점수 ＜ 95/"
}, {
  "question" : "트랜잭션의 상태 중 트랜잭션의 수행이 실패하여 Rollback 연산을 실행한 상태는?",
  "answer" : "1.철회(Aborted)",
  "commentary" : "트랜잭션의 수행이 실패하여 Rollback 연산을 실행하면 이전에 수행한 모든 작업을 취소하고 원래 상태로 되돌리는 과정을 거치게 됩니다. 이러한 상태를 \"철회(Aborted)\" 상태라고 합니다. 따라서 정답은 \"철회(Aborted)\"입니다.",
  "choices" : "1.철회(Aborted)/2.부분 완료(Partially Committed)/3.완료(Commit)/4.실패(Fail)/"
}, {
  "question" : "데이터 제어어(DCL)에 대한 설명으로 옳은 것은?",
  "answer" : "3.GRANT : 데이터베이스 사용자의 사용 권한을 부여한다.",
  "commentary" : "GRANT는 데이터베이스 사용자에게 특정 데이터베이스 객체(테이블, 뷰 등)에 대한 사용 권한을 부여하는 DCL 명령어입니다. 따라서 데이터베이스 사용자가 해당 객체를 사용할 수 있도록 권한을 부여할 때 사용됩니다.",
  "choices" : "1.ROLLBACK : 데이터의 보안과 무결성을 정의한다./2.COMMIT : 데이터베이스 사용자의 사용 권한을 취소한다./3.GRANT : 데이터베이스 사용자의 사용 권한을 부여한다./4.REVOKE : 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래 상태로 복구한다./"
}, {
  "question" : "테이블 R과 S에 대한 SQL에 대한 SQL문이 실행되었을 때, 실행결과로 옳은 것은?",
  "answer" : "4.",
  "commentary" : null,
  "choices" : "1./2./3./4./"
}, {
  "question" : "분산 데이터베이스 시스템(Distributed Database System)에 대한 설명으로 틀린 것은?",
  "answer" : "4.분산 데이터베이스 시스템의 주요 구성 요소는 분산 처리기, P2P 시스템, 단일 데이터베이스 등이 있다.",
  "commentary" : "분산 데이터베이스 시스템의 주요 구성 요소는 \"단일 데이터베이스\"가 아니라 \"분산 데이터베이스\"이다.",
  "choices" : "1.분산 데이터베이스는 논리적으로는 하나의 시스템에 속하지만 물리적으로는 여러 개의 컴퓨터 사이트에 분산되어 있다./2.위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성을 목표로 한다./3.데이터베이스의 설계가 비교적 어렵고, 개발 비용과 처리 비용이 증가한다는 단점이 있다./4.분산 데이터베이스 시스템의 주요 구성 요소는 분산 처리기, P2P 시스템, 단일 데이터베이스 등이 있다./"
}, {
  "question" : "테이블 두 개를 조인하여 뷰 V_1을 정의하고, V_1을 이용하여 뷰 V_2를 정의하였다. 다음 명령 수행 후 결과로 옳은 것은?",
  "answer" : "3.V_1과 V_2 모두 삭제된다.",
  "commentary" : "뷰 V_2는 뷰 V_1을 기반으로 정의되었기 때문에, 뷰 V_1이 삭제되면 뷰 V_2도 함께 삭제된다. 따라서 정답은 \"V_1과 V_2 모두 삭제된다.\"이다.",
  "choices" : "1.V_1만 삭제된다./2.V_2만 삭제된다./3.V_1과 V_2 모두 삭제된다./4.V_1과 V_2 모두 삭제되지 않는다./"
}, {
  "question" : "데이터베이스에서 병행제어의 목적으로 틀린 것은?",
  "answer" : "3.데이터베이스 공유 최소화",
  "commentary" : "병행제어의 목적은 데이터베이스 일관성 유지를 위한 것입니다. 데이터베이스 공유 최소화는 병행제어의 방법 중 하나이며, 데이터베이스 일관성 유지를 위한 방법 중 하나입니다. 데이터베이스 공유 최소화는 동시에 여러 사용자가 동일한 데이터를 수정하는 것을 방지하여 데이터 일관성을 유지하는 것을 목적으로 합니다.",
  "choices" : "1.시스템 활용도 최대화/2.사용자에 대한 응답시간 최소화/3.데이터베이스 공유 최소화/4.데이터베이스 일관성 유지/"
}, {
  "question" : "IP 주소체계와 관련한 설명으로 틀린 것은?",
  "answer" : "1.IPv6의 패킷 헤더는 32 octet의 고정된 길이를 가진다.",
  "commentary" : "\"IPv6의 패킷 헤더는 32 octet의 고정된 길이를 가진다.\"가 틀린 설명이다. IPv6의 패킷 헤더는 40 octet의 고정된 길이를 가진다. 이는 IPv4의 패킷 헤더보다 더 큰 크기이지만, IPv6는 보다 효율적인 패킷 처리를 위해 최적화되어 있다.",
  "choices" : "1.IPv6의 패킷 헤더는 32 octet의 고정된 길이를 가진다./2.IPv6는 주소 자동설정(Auto Configuration) 기능을 통해 손쉽게 이용자의 단말을 네트워크에 접속시킬 수 있다./3.IPv4는 호스트 주소를 자동으로 설정하며 유니캐스트(Unicast)를 지원한다./4.IPv4는 클래스별로 네트워크와 호스트 주소의 길이가 다르다./"
}, {
  "question" : "다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",
  "answer" : "3.8, 9",
  "commentary" : "프로그램은 2차원 배열 arr을 선언하고, arr[1][2]의 값을 8로 초기화한 후, arr[1][3]의 값을 ++ 연산자로 1 증가시킨다. 따라서 arr[1][2]의 값은 8이고, arr[1][3]의 값은 9가 된다. 따라서 정답은 \"8, 9\"이다.",
  "choices" : "1.7, 5/2.8, 5/3.8, 9/4.7, 9/"
}, {
  "question" : "OSI 7계층 중 데이터링크 계층에 해당되는 프로토콜이 아닌 것은?",
  "answer" : "1.HTTP",
  "commentary" : "HTTP는 OSI 7계층 중 응용 계층에 해당하는 프로토콜이므로 데이터링크 계층에 해당되는 프로토콜이 아니다. 데이터링크 계층에서 사용되는 프로토콜로는 HDLC, PPP, LLC 등이 있다.",
  "choices" : "1.HTTP/2.HDLC/3.PPP/4.LLC/"
}, {
  "question" : "C언어에서 두 개의 논리 값 중 하나라도 참이면 1을, 모두 거짓이면 0을 반환하는 연산자는?",
  "answer" : "1.||",
  "commentary" : "정답은 \"||\"이다. 이유는 \"||\" 연산자는 두 개의 논리 값 중 하나라도 참이면 전체 결과가 참이 되기 때문이다. 반면에 \"&&\" 연산자는 두 개의 논리 값이 모두 참일 때만 전체 결과가 참이 되고, \"**\" 연산자는 거듭제곱을 계산하는 연산자이며, \"!=\" 연산자는 두 개의 값이 서로 다르면 참이 되는 비교 연산자이다.",
  "choices" : "1.||/2.&&/3.**/4.!=/"
}, {
  "question" : "IPv6에 대한 특성으로 틀린 것은?",
  "answer" : "1.표시방법은 8비트씩 4부분의 10진수로 표시한다.",
  "commentary" : "\"표시방법은 8비트씩 4부분의 10진수로 표시한다.\"가 틀린 것이다. IPv6는 128비트의 이진수로 표시되며, 이를 16진수로 나타내어 각각을 콜론(:)으로 구분하여 표시한다. 예를 들어, 2001:0db8:85a3:0000:0000:8a2e:0370:7334와 같은 형식이다.",
  "choices" : "1.표시방법은 8비트씩 4부분의 10진수로 표시한다./2.2128개의 주소를 표현할 수 있다./3.등급별, 서비스별로 패킷을 구분할 수 있어 품질보장이 용이하다./4.확장기능을 통해 보안기능을 제공한다./"
}, {
  "question" : "JAVA의 예외(exception)와 관련한 설명으로 틀린 것은?",
  "answer" : "1.문법 오류로 인해 발생한 것",
  "commentary" : "정답은 \"문법 오류로 인해 발생한 것\"이다. 예외는 실행 시간 동안 발생하는 오류로, 문법 오류는 컴파일 시간에 발생하는 오류이다.",
  "choices" : "1.문법 오류로 인해 발생한 것/2.오동작이나 결과에 악영향을 미칠 수 있는 실행 시간 동안에 발생한 오류/3.배열의 인덱스가 그 범위를 넘어서는 경우 발생하는 오류/4.존재하지 않는 파일을 읽으려고 하는 경우에 발생하는 오류/"
}, {
  "question" : "TCP/IP 계층 구조에서 IP의 동작 과정에서의 전송 오류가 발생하는 경우에 대비해 오류 정보를 전송하는 목적으로 사용하는 프로토콜은?",
  "answer" : "3.ICMP(Internet Control Message Protocol)",
  "commentary" : "ICMP는 IP 패킷 전송 중 발생하는 오류 정보를 전송하기 위한 프로토콜로, 예를 들어 목적지 호스트가 도달할 수 없는 경우나 TTL(Time To Live)이 만료된 경우 등에 사용됩니다. 따라서 IP의 동작 과정에서 전송 오류가 발생하는 경우에 대비해 오류 정보를 전송하는 목적으로 사용하는 프로토콜은 ICMP입니다.",
  "choices" : "1.ECP(Error Checking Protocol)/2.ARP(Address Resolution Protocol)/3.ICMP(Internet Control Message Protocol)/4.PPP(Point-to-Point Protocol)/"
}, {
  "question" : "좋은 소프트웨어 설계를 위한 소프트웨어의 모듈간의 결합도(Coupling)와 모듈 내 요소 간 응집도(Cohesion)에 대한 설명으로 옳은 것은?",
  "answer" : "2.응집도는 높게 결합도는 낮게 설계한다.",
  "commentary" : "모듈간의 결합도는 모듈들이 서로 얼마나 의존하는지를 나타내며, 모듈 내 요소 간 응집도는 모듈 내부의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타냅니다. 따라서, 좋은 소프트웨어 설계를 위해서는 모듈간의 결합도는 낮게, 모듈 내 요소 간 응집도는 높게 설계해야 합니다. 이는 각 모듈이 독립적으로 작동할 수 있도록 하고, 모듈 내부의 요소들이 명확하게 구분되어 있어 유지보수와 확장이 용이하도록 하기 위함입니다. 응집도는 높게 결합도는 낮게 설계하는 이유는, 모듈 내부의 요소들이 서로 밀접하게 관련되어 있으면서도, 다른 모듈과는 최소한의 의존성을 가지도록 설계하기 위함입니다. 이는 모듈 간의 결합도를 낮추어 유연성과 재사용성을 높이기 위함입니다.",
  "choices" : "1.응집도는 낮게 결합도는 높게 설계한다./2.응집도는 높게 결합도는 낮게 설계한다./3.양쪽 모두 낮게 설계한다./4.양쪽 모두 높게 설계한다./"
}, {
  "question" : "다음과 같은 형태로 임계 구역의 접근을 제어하는 상호배제 기법은?",
  "answer" : "4.Semaphore",
  "commentary" : "위 그림에서 보이는 임계 구역에 진입하기 위해서는 Semaphore를 사용하여 접근을 제어하는 것이다. Semaphore는 공유 자원에 대한 접근을 제어하기 위한 동기화 기법으로, 특정 자원에 대한 접근 권한을 가진 프로세스만이 해당 자원을 사용할 수 있도록 제어한다. Semaphore는 카운팅 세마포어와 이진 세마포어로 나뉘며, 이진 세마포어는 뮤텍스와 유사한 역할을 한다.",
  "choices" : "1.Dekker Algorithm/2.Lamport Algorithm/3.Peterson Algorithm/4.Semaphore/"
}, {
  "question" : "소프트웨어 개발에서 모듈(Module)이 되기 위한 주요 특징에 해당하지 않는 것은?",
  "answer" : "4.다른 모듈에서의 접근이 불가능해야 한다.",
  "commentary" : "\"다른 모듈에서의 접근이 불가능해야 한다.\"는 모듈 간의 의존성을 최소화하기 위한 원칙 중 하나인 정보 은닉(Encapsulation)을 나타냅니다. 모듈 내부의 구현 세부사항을 외부에서 직접 접근할 수 없도록 하여 모듈 간의 결합도를 낮추고, 모듈의 변경이 다른 모듈에 미치는 영향을 최소화합니다. 따라서 다른 모듈에서의 접근이 불가능해야 한다는 것은 모듈 내부의 구현 세부사항을 외부에서 직접 접근할 수 없도록 제한하는 것을 의미합니다.",
  "choices" : "1.다른 것들과 구별될 수 있는 독립적인 기능을 가진 단위(Unit)이다./2.독립적인 컴파일이 가능하다./3.유일한 이름을 가져야 한다./4.다른 모듈에서의 접근이 불가능해야 한다./"
}, {
  "question" : "빈 기억공간의 크기가 20KB, 16KB, 8KB, 40KB 일 때 기억장치 배치 전략으로 “Best Fit\"을 사용하여 17KB의 프로그램을 적재할 경우 내부단편화의 크기는 얼마인가?",
  "answer" : "1.3KB",
  "commentary" : "Best Fit 전략은 사용 가능한 기억공간 중에서 가장 작은 공간을 찾아 프로그램을 적재하는 방법이다. 따라서 17KB의 프로그램을 적재하기 위해선 20KB의 기억공간을 사용해야 한다. 이 경우, 20KB - 17KB = 3KB의 내부단편화가 발생하게 된다. 따라서 정답은 \"3KB\"이다.",
  "choices" : "1.3KB/2.23KB/3.64KB/4.67KB/"
}, {
  "question" : "다음 C언어프로그램이 실행되었을 때, 실행 결과는?",
  "answer" : "4.i = 4",
  "commentary" : "프로그램은 먼저 i를 0으로 초기화하고, while문 안에서 i를 1씩 증가시키면서 i가 4보다 작을 때까지 반복한다. 따라서 i가 4일 때 while문을 빠져나오고, 마지막으로 printf 함수를 통해 i의 값을 출력하게 된다. 따라서 정답은 \"i = 4\"이다.",
  "choices" : "1.i = 0/2.i = 1/3.i = 3/4.i = 4/"
}, {
  "question" : "다음 JAVA 프로그램이 실행되었을 때, 실행 결과는?",
  "answer" : "2.BCDABCC",
  "commentary" : "이 프로그램은 Thread 클래스를 상속받은 MyThread 클래스를 정의하고, 이를 생성하여 start() 메소드를 호출하여 새로운 스레드를 실행시키는 코드입니다. MyThread 클래스에서는 1부터 5까지의 숫자를 출력하고, 그 다음에는 A부터 D까지의 알파벳을 출력합니다. main() 메소드에서는 MyThread 객체를 두 개 생성하고, 각각의 스레드를 실행시킵니다. 따라서, 두 스레드는 병렬적으로 실행되며, 출력 결과는 실행할 때마다 다를 수 있습니다. 하지만, 각 스레드에서 출력하는 순서는 일정합니다. 첫 번째 스레드에서는 1부터 5까지의 숫자를 출력하고, 그 다음에는 A를 출력합니다. 두 번째 스레드에서는 1부터 5까지의 숫자를 출력하고, 그 다음에는 B를 출력합니다. 따라서, 출력 결과는 \"BCDABCA\" 또는 \"BCDABCC\" 중 하나가 될 수 있습니다. 하지만, 보기에서는 \"BCDABCC\"가 정답으로 주어졌으므로, 두 번째 스레드에서 B를 출력한 후, 첫 번째 스레드에서 A를 출력하기 때문입니다. 따라서, 정답은 \"BCDABCC\"입니다.",
  "choices" : "1.BCDABCA/2.BCDABCC/3.CDDACCC/4.CDDACCA/"
}, {
  "question" : "개발 환경 구성을 위한 빌드(Build) 도구에 해당하지 않는 것은?",
  "answer" : "2.Kerberos",
  "commentary" : "Kerberos는 인증 프로토콜로, 개발 환경 구성을 위한 빌드 도구가 아니기 때문에 정답입니다. Ant, Maven, Gradle은 모두 자바 기반의 빌드 도구입니다.",
  "choices" : "1.Ant/2.Kerberos/3.Maven/4.Gradle/"
}, {
  "question" : "3개의 페이지 프레임을 갖는 시스템에서 페이지 참조 순서가 1, 2, 1, 0, 4, 1, 3 일 경우 FIFO 알고리즘에 의한 페이지 교체의 경우 프레임의 최종 상태는?",
  "answer" : "4.4, 1, 3",
  "commentary" : "FIFO 알고리즘은 가장 먼저 들어온 페이지를 먼저 교체하는 방식이다. 따라서 페이지 참조 순서대로 프레임에 채워지다가 꽉 차면 가장 먼저 들어온 페이지를 교체한다. 1. 1: [1, _, _] 2. 2: [1, 2, _] 3. 1: [1, 2, _] (이미 존재하므로 교체하지 않음) 4. 0: [0, 2, 1] 5. 4: [0, 2, 4] 6. 1: [0, 2, 4] (이미 존재하므로 교체하지 않음) 7. 3: [3, 2, 4] 따라서 최종 상태는 \"3, 2, 4\" 이다.",
  "choices" : "1.1, 2, 0/2.2, 4, 3/3.1, 4, 2/4.4, 1, 3/"
}, {
  "question" : "다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",
  "answer" : "3.R",
  "commentary" : "프로그램은 먼저 x와 y를 0으로 초기화하고, if문에서 x와 y가 같은지를 비교한다. 현재 x와 y는 모두 0이므로 같다. 따라서 if문 안의 코드가 실행되어 x에 10을 더하고 y에 20을 더한다. 그리고 x와 y를 출력하면 x는 10, y는 20이 출력된다. 이후 switch문에서 case 1이 아니므로 case 2로 넘어가고, case 2에서는 \"V\"를 출력한다. 따라서 정답은 \"V\"가 아닌 \"R\"이다.",
  "choices" : "1.E/2.V/3.R/4.O/"
}, {
  "question" : "다음 Python 프로그램이 실행되었을 때, 실행 결과는?",
  "answer" : "1.",
  "commentary" : "실행 결과는 \"\" 이다. 이유는 for문에서 range(1, 10)은 1부터 9까지의 숫자를 의미하며, i가 3의 배수일 때 \"Fizz\"를 출력하고, i가 5의 배수일 때 \"Buzz\"를 출력한다. 그리고 i가 3과 5의 공배수일 때 \"FizzBuzz\"를 출력한다. 따라서 3의 배수인 3과 6, 5의 배수인 5와 10, 그리고 3과 5의 공배수인 15가 각각 \"Fizz\", \"Fizz\", \"Buzz\", \"FizzBuzz\"로 출력되어 \"\"이 출력된다.",
  "choices" : "1./2./3./4./"
}, {
  "question" : "C언어에서 정수 변수 a, b에 각각 1, 2가 저장되어 있을 때 다음 식의 연산 결과로 옳은 것은?",
  "answer" : "2.1",
  "commentary" : "정답은 \"1\"입니다. a++는 a의 값을 1 증가시키고, ++b는 b의 값을 1 증가시킨 후에 연산을 수행합니다. 따라서 a++ + ++b는 1 + 3 = 4가 됩니다. 보기에서 \"0\"은 a++와 ++b가 모두 적용되기 전의 a와 b의 값인 1과 2를 더한 결과인 3이므로 틀립니다. \"3\"은 a++와 ++b가 모두 적용된 후의 a와 b의 값인 2와 3을 더한 결과인 5이므로 틀립니다. \"5\"는 a++와 ++b가 모두 적용된 후의 a와 b의 값인 2와 3을 더한 결과에 1을 더한 6이므로 틀립니다.",
  "choices" : "1.0/2.1/3.3/4.5/"
}, {
  "question" : "다음 Python 프로그램이 실행되었을 때, 실행 결과는?",
  "answer" : "2.",
  "commentary" : "실행 결과는 \"\" 이다. 이유는 for문에서 range(1, 6)은 1부터 5까지의 숫자를 의미하며, 따라서 i는 1, 2, 3, 4, 5가 된다. 그리고 print문에서는 i가 3일 때 \"짝\"을 출력하게 되므로, 3의 배수인 3과 5에서 \"짝\"이 출력되고, 나머지 숫자에서는 그냥 숫자가 출력된다. 따라서 결과는 \"1 2 짝 4 짝\"이 된다.",
  "choices" : "1./2./3./4./"
}, {
  "question" : "UNIX 시스템의 쉘(shell)의 주요 기능에 대한 설명이 아닌 것은?",
  "answer" : "3.쉘 프로그램 실행을 위해 프로세스와 메모리를 관리한다.",
  "commentary" : "쉘은 사용자가 입력한 명령을 해석하고 실행하기 위해 필요한 프로세스와 메모리를 관리하는 기능을 제공하지 않는다. 이는 운영체제의 역할이며, 쉘은 운영체제와 사용자 간의 인터페이스 역할을 수행한다.",
  "choices" : "1.사용자 명령을 해석하고 커널로 전달하는 기능을 제공한다./2.반복적인 명령 프로그램을 만드는 프로그래밍 기능을 제공한다./3.쉘 프로그램 실행을 위해 프로세스와 메모리를 관리한다./4.초기화 파일을 이용해 사용자 환경을 설정하는 기능을 제공한다./"
}, {
  "question" : "소프트웨어 생명주기 모델 중 나선형 모델(Spiral Model)과 관련한 설명으로 틀린 것은??",
  "answer" : "2.위험 분석(Risk Analysis)은 반복적인 개발 진행 후 주기의 마지막 단계에서 최종적으로 한 번 수행해야 한다.",
  "commentary" : "\"위험 분석(Risk Analysis)은 반복적인 개발 진행 후 주기의 마지막 단계에서 최종적으로 한 번 수행해야 한다.\"이 부분이 틀린 것입니다. 나선형 모델에서는 위험 분석이 각 주기의 시작 단계에서 수행되어야 합니다. 이는 해당 주기에서 발생할 수 있는 위험을 사전에 파악하고 대응책을 마련하기 위함입니다.",
  "choices" : "1.소프트웨어 개발 프로세스를 위험 관리(Risk Management) 측면에서 본 모델이다./2.위험 분석(Risk Analysis)은 반복적인 개발 진행 후 주기의 마지막 단계에서 최종적으로 한 번 수행해야 한다./3.시스템을 여러 부분으로 나누어 여러 번의 개발 주기를 거치면서 시스템이 완성된다./4.요구사항이나 아키텍처를 이해하기 어렵다거나 중심이 되는 기술에 문제가 있는 경우 적합한 모델이다./"
}, {
  "question" : "정보시스템과 관련한 다음 설명에 해당하는 것은?",
  "answer" : "1.고가용성 솔루션(HACMP)",
  "commentary" : "이미지에서 보이는 것은 서버 클러스터링 구성도이며, 서버 클러스터링은 고가용성 솔루션(HACMP)을 사용하여 여러 대의 서버를 하나의 시스템으로 묶어서 사용하는 것이다. 이를 통해 하나의 서버가 고장나더라도 다른 서버가 대신 처리하여 시스템의 지속적인 운영이 가능하다. 따라서 이 설명에 해당하는 것은 \"고가용성 솔루션(HACMP)\"이다. \"점대점 연결 방식(Point-to-Point Mode)\"은 네트워크 연결 방식, \"스턱스넷(Stuxnet)\"은 악성코드, \"루팅(Rooting)\"은 시스템의 권한을 높이는 것을 의미한다.",
  "choices" : "1.고가용성 솔루션(HACMP)/2.점대점 연결 방식(Point-to-Point Mode)/3.스턱스넷(Stuxnet)/4.루팅(Rooting)/"
}, {
  "question" : "위조된 매체 접근 제어(MAC) 주소를 지속적으로 네트워크로 흘려보내, 스위치 MAC 주소 테이블의 저장 기능을 혼란시켜 더미 허브(Dummy Hub)처럼 작동하게 하는 공격은?",
  "answer" : "3.Switch Jamming",
  "commentary" : "Switch Jamming은 위조된 MAC 주소를 지속적으로 네트워크로 보내 스위치의 MAC 주소 테이블을 혼란시켜 더미 허브처럼 작동하게 만드는 공격이다. 따라서, 이 공격은 스위치를 혼란시키는 것이 목적이므로 \"Switch Jamming\"이 정답이다.",
  "choices" : "1.Parsing/2.LAN Tapping/3.Switch Jamming/4.FTP Flooding/"
}, {
  "question" : "다음 내용이 설명하는 스토리지 시스템은?",
  "answer" : "1.DAS",
  "commentary" : "이 스토리지 시스템은 \"DAS\" (Direct Attached Storage)이다. 이는 컴퓨터에 직접 연결되어 있는 스토리지 시스템으로, 네트워크를 통해 다른 컴퓨터와 공유되지 않는다는 특징이 있다. 그림에서 보이는 것처럼, 스토리지 디바이스가 컴퓨터에 직접 연결되어 있기 때문에 데이터 전송 속도가 빠르고 안정적이다.",
  "choices" : "1.DAS/2.NAS/3.BSA/4.NFC/"
}, {
  "question" : "취약점 관리를 위해 일반적으로 수행하는 작업이 아닌 것은?",
  "answer" : "3.중단 프로세스 및 닫힌 포트 위주로 확인",
  "commentary" : "중단된 프로세스나 닫힌 포트는 이미 보안상의 문제가 발생한 상태이므로, 이를 우선적으로 확인하여 대응하는 것이 중요하다. 따라서 취약점 관리를 위해 일반적으로 수행하는 작업 중에서는 \"중단 프로세스 및 닫힌 포트 위주로 확인\"이 아닌 것이다. 다른 작업들은 보안 취약점을 예방하거나 대응하기 위한 필수적인 작업들이다.",
  "choices" : "1.무결성 검사/2.응용 프로그램의 보안 설정 및 패치(Patch) 적용/3.중단 프로세스 및 닫힌 포트 위주로 확인/4.불필요한 서비스 및 악성 프로그램의 확인과 제거/"
}, {
  "question" : "소프트웨어 생명주기 모델 중 V 모델과 관련한 설명으로 틀린 것은?",
  "answer" : "1.요구 분석 및 설계단계를 거치지 않으며 항상 통합 테스트를 중심으로 V 형태를 이룬다.",
  "commentary" : "\"요구 분석 및 설계단계를 거치지 않으며 항상 통합 테스트를 중심으로 V 형태를 이룬다.\"가 틀린 설명입니다. V 모델은 요구 분석, 설계, 구현, 테스트 단계를 포함하는 소프트웨어 생명주기 모델로, 각 단계에서 산출물을 검증하고 다음 단계로 이동하는 방식으로 진행됩니다. 따라서 요구 분석 및 설계 단계를 거치지 않고 통합 테스트만을 중심으로 진행하는 것은 V 모델의 원칙에 어긋나는 것입니다.",
  "choices" : "1.요구 분석 및 설계단계를 거치지 않으며 항상 통합 테스트를 중심으로 V 형태를 이룬다./2.Perry에 의해 제안되었으며 세부적인 테스트 과정으로 구성되어 신뢰도 높은 시스템을 개발하는데 효과적이다./3.개발 작업과 검증 작업 사이의 관계를 명확히 들어내 놓은 폭포수 모델의 변형이라고 볼 수 있다./4.폭포수 모델이 산출물 중심이라면 V 모델은 작업과 결과의 검증에 초점을 둔다./"
}, {
  "question" : "블루투스(Bluetooth) 공격과 해당 공격에 대한 설명이 올바르게 연결된 것은?",
  "answer" : "3.블루프린팅(BluePrinting) - 블루투스 공격 장치의 검색 활동을 의미",
  "commentary" : "블루프린팅은 블루투스 공격 장치의 검색 활동을 의미한다. 다른 보기들은 블루투스 공격에 대한 다른 형태의 설명이다. 블루버그는 취약점을 이용하여 파일에 접근하는 공격, 블루스나프는 명함을 익명으로 퍼뜨리는 것, 블루재킹은 취약한 연결 관리를 악용한 공격이다.",
  "choices" : "1.블루버그(BlueBug) - 블루투스의 취약점을 활용하여 장비의 파일에 접근하는 공격으로 OPP를 사용하여 정보를 열람/2.블루스나프(BlueSnarf) - 블루투스를 이용해 스팸처럼 명함을 익명으로 퍼뜨리는 것/3.블루프린팅(BluePrinting) - 블루투스 공격 장치의 검색 활동을 의미/4.블루재킹(BlueJacking) - 블루투스 장비사이의 취약한 연결 관리를 악용한 공격/"
}, {
  "question" : "DoS(Denial of Service) 공격과 관련한 내용으로 틀린 것은?",
  "answer" : "2.Smurf 공격은 멀티캐스트(Multicast)를 활용하여 공격 대상이 네트워크의 임의의 시스템에 패킷을 보내게 만드는 공격이다.",
  "commentary" : "정답은 \"Smurf 공격은 멀티캐스트(Multicast)를 활용하여 공격 대상이 네트워크의 임의의 시스템에 패킷을 보내게 만드는 공격이다.\"가 아닌 \"Smurf 공격은 공격자가 대량의 ICMP Echo Request 패킷을 네트워크 상의 브로드캐스트 주소로 보내서, 해당 네트워크 상의 모든 호스트들이 ICMP Echo Reply 패킷을 공격 대상에게 보내도록 유도하여 대역폭을 고갈시키는 공격 방법이다.\"입니다. Smurf 공격은 공격자가 대량의 ICMP Echo Request 패킷을 네트워크 상의 브로드캐스트 주소로 보내서, 해당 네트워크 상의 모든 호스트들이 ICMP Echo Reply 패킷을 공격 대상에게 보내도록 유도하여 대역폭을 고갈시키는 공격 방법입니다. 멀티캐스트는 한 번에 여러 대상에게 패킷을 전송하는 방법이며, Smurf 공격과는 관련이 없습니다.",
  "choices" : "1.Ping of Death 공격은 정상 크기보다 큰 ICMP 패킷을 작은 조각(Fragment)으로 쪼개어 공격 대상이 조각화 된 패킷을 처리하게 만드는 공격 방법이다./2.Smurf 공격은 멀티캐스트(Multicast)를 활용하여 공격 대상이 네트워크의 임의의 시스템에 패킷을 보내게 만드는 공격이다./3.SYN Flooding은 존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 서비스를 이용하지 못하게 하는 것이다./4.Land 공격은 패킷 전송 시 출발지 IP주소와 목적지 IP주소 값을 똑같이 만들어서 공격 대상에게 보내는 공격 방법이다./"
}, {
  "question" : "다음 설명에 해당하는 시스템은?",
  "answer" : "3.Honeypot",
  "commentary" : "이 시스템은 Honeypot이다. Honeypot은 보안 시스템 중 하나로, 공격자가 침입하면 그 정보를 수집하여 보안에 적극 활용하는 시스템이다. 이 시스템은 공격자가 침입하면 그 정보를 수집하여 보안에 활용하는 것으로, 다른 보기인 Apache, Hadoop, MapReduce와는 목적과 기능이 다르다.",
  "choices" : "1.Apache/2.Hadoop/3.Honeypot/4.MapReduce/"
}, {
  "question" : "다음이 설명하는 IT 기술은?",
  "answer" : "2.Docker",
  "commentary" : "이 그림은 컨테이너 기술 중 하나인 Docker를 나타냅니다. Docker는 애플리케이션을 실행하기 위한 환경을 컨테이너로 만들어서 이식성과 확장성을 높이는 기술입니다. Docker를 사용하면 애플리케이션을 더 쉽게 배포하고 관리할 수 있습니다.",
  "choices" : "1.StackGuard/2.Docker/3.Cipher Container/4.Scytale/"
}, {
  "question" : "간트 차트(Gantt Chart)에 대한 설명으로 틀린 것은?",
  "answer" : "4.수평 막대의 길이는 각 작업(Task)에 필요한 인원수를 나타낸다.",
  "commentary" : "수평 막대의 길이는 각 작업(Task)에 필요한 인원수를 나타내는 것은 틀린 설명입니다. 수평 막대의 길이는 각 작업(Task)의 진행 기간을 나타냅니다. 간트 차트는 프로젝트를 이루는 소작업 별로 언제 시작되고 언제 끝나야 하는지를 한 눈에 볼 수 있도록 도와주며, 자원 배치 계획에 유용하게 사용됩니다. 또한 CPM 네트워크로부터 만드는 것이 가능합니다.",
  "choices" : "1.프로젝트를 이루는 소작업 별로 언제 시작되고 언제 끝나야 하는지를 한 눈에 볼 수 있도록 도와준다./2.자원 배치 계획에 유용하게 사용된다./3.CPM 네트워크로부터 만드는 것이 가능하다./4.수평 막대의 길이는 각 작업(Task)에 필요한 인원수를 나타낸다./"
}, {
  "question" : "Python 기반의 웹 크롤링(Web Crawling) 프레임워크로 옳은 것은?",
  "answer" : "2.Scrapy",
  "commentary" : "정답: Scrapy 이유: Scrapy는 Python 기반의 웹 크롤링 프레임워크로, 다양한 웹사이트에서 데이터를 수집하고 처리하는 데 사용됩니다. Scrapy는 비동기식 네트워크 프레임워크인 Twisted를 기반으로 하며, 크롤링, 스크래핑, 데이터 추출, 데이터 처리 등의 작업을 쉽게 수행할 수 있습니다. 또한 Scrapy는 다양한 데이터베이스와 연동이 가능하며, 크롤링한 데이터를 JSON, CSV, XML 등 다양한 형식으로 저장할 수 있습니다.",
  "choices" : "1.Li-fi/2.Scrapy/3.CrawlCat/4.SBAS/"
}, {
  "question" : "Secure 코딩에서 입력 데이터의 보안 약점과 관련한 설명으로 틀린 것은?",
  "answer" : "4.자원 삽입 : 사용자가 내부 입력 값을 통해 시스템 내에 사용이 불가능한 자원을 지속적으로 입력함으로써 시스템에 과부하 발생",
  "commentary" : null,
  "choices" : "1.SQL 삽입 : 사용자의 입력 값 등 외부 입력 값이 SQL 쿼리에 삽입되어 공격/2.크로스사이트 스크립트 : 검증되지 않은 외부 입력 값에 의해 브라우저에서 악의적인 코드가 실행/3.운영체제 명령어 삽입 : 운영체제 명령어 파라미터 입력 값이 적절한 사전검증을 거치지 않고 사용되어 공격자가 운영체제 명령어를 조작/4.자원 삽입 : 사용자가 내부 입력 값을 통해 시스템 내에 사용이 불가능한 자원을 지속적으로 입력함으로써 시스템에 과부하 발생/"
}, {
  "question" : "Windows 파일 시스템인 FAT와 비교했을 때의 NTFS의 특징이 아닌 것은?",
  "answer" : "1.보안에 취약",
  "commentary" : "\"보안에 취약\"은 NTFS의 특징이 아니라 오히려 NTFS는 FAT보다 보안성이 높은 파일 시스템이다. NTFS는 파일 암호화, 접근 제어, 오디팅 등의 보안 기능을 제공하며, 파일 및 폴더에 대한 권한 설정이 가능하다. 따라서 NTFS는 기업에서 중요한 데이터를 보호하기 위해 많이 사용된다.",
  "choices" : "1.보안에 취약/2.대용량 볼륨에 효율적/3.자동 압축 및 안정성/4.저용량 볼륨에서의 속도 저하/"
}, {
  "question" : "DES는 몇 비트의 암호화 알고리즘인가?",
  "answer" : "3.64",
  "commentary" : "DES는 64비트의 암호화 알고리즘이다. 이는 입력 데이터와 출력 데이터가 64비트인 것을 의미한다.",
  "choices" : "1.8/2.24/3.64/4.132/"
}, {
  "question" : "리눅스에서 생성된 파일 권한이 644일 경우 umask 값은?",
  "answer" : "1.022",
  "commentary" : "umask 값은 새로운 파일이나 디렉토리를 생성할 때 기본 권한에서 제외되는 값입니다. 따라서 생성된 파일의 권한이 644일 경우, umask 값은 022가 됩니다. 이는 기본 권한 666에서 umask 값 022를 뺀 값과 같습니다.",
  "choices" : "1.022/2.666/3.777/4.755/"
}, {
  "question" : "다음 내용이 설명하는 로그 파일은?",
  "answer" : "4.wtmp",
  "commentary" : "이 로그 파일은 사용자 로그인 및 로그아웃 기록을 기록하는 wtmp 파일입니다.",
  "choices" : "1.tapping/2.xtslog/3.linuxer/4.wtmp/"
}, {
  "question" : "상향식 비용 산정 기법 중 LOC(원시 코드 라인 수) 기법에서 예측치를 구하기 위해 사용하는 항목이 아닌 것은?",
  "answer" : "4.모형치",
  "commentary" : "LOC 기법에서는 프로그램의 크기를 측정하기 위해 사용되는 항목으로, 모형치는 이에 해당하지 않습니다. 모형치는 소프트웨어 개발 과정에서 사용되는 모형의 복잡도를 나타내는 지표로 사용됩니다. 따라서 모형치는 LOC 기법에서 예측치를 구하기 위해 사용되는 항목이 아닙니다.",
  "choices" : "1.낙관치/2.기대치/3.비관치/4.모형치/"
}, {
  "question" : "OSI 7 Layer 전 계층의 프로토콜과 패킷 내부의 콘텐츠를 파악하여 침입 시도, 해킹 등을 탐지하고 트래픽을 조정하기 위한 패킷 분석 기술은?",
  "answer" : "4.DPI(Deep Packet Inspection)",
  "commentary" : "DPI는 패킷 내부의 콘텐츠를 분석하여 특정 프로토콜이나 애플리케이션을 식별하고, 이를 기반으로 침입 시도나 해킹 등을 탐지하고 트래픽을 조정하는 기술입니다. 다른 보기들은 패킷 처리나 분배 등의 역할을 하는 기술이지만, DPI는 보다 깊은 수준에서 패킷을 분석하여 보안과 네트워크 관리에 활용됩니다.",
  "choices" : "1.PLCP(Packet Level Control Processor)/2.Traffic Distributor/3.Packet Tree/4.DPI(Deep Packet Inspection)/"
}, {
  "question" : "소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?",
  "answer" : "1.프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.",
  "commentary" : "\"프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.\"는 올바르지 않은 설명입니다. 소프트웨어 개발 방법론의 테일러링은 프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동입니다. 관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이며, 기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술 요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것입니다. 따라서 예상되는 변화를 미리 고려하여 조정하는 것이 중요합니다.",
  "choices" : "1.프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다./2.프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동이다./3.관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다./4.기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술 요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다./"
}, {
  "question" : "요구사항 검증(Requirements Validation)과 관련한 설명으로 틀린 것은?",
  "answer" : "4.요구사항 검증 과정을 통해 모든 요구사항 문제를 발견할 수 있다.",
  "commentary" : "정답은 \"요구사항 검증 과정을 통해 모든 요구사항 문제를 발견할 수 있다.\"입니다. 요구사항 검증은 요구사항이 고객이 원하는 시스템을 제대로 정의하고 있는지, 요구사항이 실제 요구를 반영하는지, 문서상의 요구사항이 서로 상충되지 않는지 등을 점검하는 과정입니다. 하지만 모든 요구사항 문제를 발견할 수 있는 것은 아닙니다. 따라서 요구사항 검증은 매우 중요하지만, 개발완료 이후에도 문제점이 발견될 수 있기 때문에 요구사항 검증 이후에도 지속적인 검토와 수정이 필요합니다.",
  "choices" : "1.요구사항이 고객이 정말 원하는 시스템을 제대로 정의하고 있는지 점검하는 과정이다./2.개발완료 이후에 문제점이 발견될 경우 막대한 재작업 비용이 들 수 있기 때문에 요구사항 검증은 매우 중요하다./3.요구사항이 실제 요구를 반영하는지, 문서상의 요구사항은 서로 상충되지 않는지 등을 점검한다./4.요구사항 검증 과정을 통해 모든 요구사항 문제를 발견할 수 있다./"
}, {
  "question" : "UML 모델에서 한 사물의 명세가 바뀌면 다른사물에 영향을 주며, 일반적으로 한 클래스가다른 클래스를 오퍼레이션의 매개변수로 사용하는 경우에 나타나는 관계는?",
  "answer" : "2.Dependency",
  "commentary" : "정답은 \"Dependency\"입니다. Dependency는 한 클래스가 다른 클래스를 사용하는 관계를 나타내며, 한 사물의 명세가 바뀌면 다른 사물에 영향을 주는 경우가 있습니다. 이 관계는 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개변수로 사용하는 경우에 나타납니다. Association은 두 클래스 간의 관계를 나타내며, 두 클래스가 서로를 참조하는 경우에 사용됩니다. Realization은 인터페이스와 구현 클래스 간의 관계를 나타내며, 인터페이스를 구현하는 클래스가 있을 때 사용됩니다. Generalization은 상속 관계를 나타내며, 부모 클래스와 자식 클래스 간의 관계를 나타냅니다.",
  "choices" : "1.Association/2.Dependency/3.Realization/4.Generalization/"
}, {
  "question" : "익스트림 프로그래밍 (XP)에 대한 설명으로 틀린 것은?",
  "answer" : "1.빠른 개발을 위해 테스트를 수행하지 않는다.",
  "commentary" : "\"빠른 개발을 위해 테스트를 수행하지 않는다.\"는 XP의 원칙과 맞지 않는 설명입니다. XP는 빠른 개발과 동시에 테스트 주도 개발(TDD)을 강조하여 개발 초기부터 테스트를 수행하고, 지속적인 통합과 테스트를 통해 빠른 피드백과 개선을 추구합니다. 따라서 이 설명은 틀린 설명입니다.",
  "choices" : "1.빠른 개발을 위해 테스트를 수행하지 않는다./2.사용자의 요구사항은 언제든지 변할 수있다./3.고객과 직접 대면하며 요구사항을 이야기하기 위해 사용자 스토리(User Story)를 활용할 수 있다./4.기존의 방법론에 비해 실용성(Pragmatism)을 강조한 것이라고 볼 수있다./"
}, {
  "question" : "소프트웨어 설계에서 사용되는 대표적인 추상화(Abstraction) 기법이 아닌 것은?",
  "answer" : "4.강도 추상화",
  "commentary" : "강도 추상화는 소프트웨어 설계에서 사용되는 대표적인 추상화 기법이 아닙니다. 이유는 강도 추상화는 소프트웨어에서 데이터의 정확한 값이나 범위를 나타내는 것으로, 추상화의 목적과는 다르기 때문입니다. 다른 세 가지 추상화 기법인 자료 추상화, 제어 추상화, 과정 추상화는 소프트웨어 설계에서 중요한 역할을 합니다. 자료 추상화는 데이터를 추상화하여 복잡성을 줄이고, 제어 추상화는 프로그램의 제어 흐름을 추상화하여 코드의 가독성을 높이며, 과정 추상화는 프로그램의 실행 과정을 추상화하여 복잡성을 줄입니다.",
  "choices" : "1.자료 추상화/2.제어 추상화/3.과정 추상화/4.강도 추상화/"
}, {
  "question" : "객체지향 설계에서 정보 은닉(Information Hiding)과 관련한 설명으로 틀린 것은?",
  "answer" : "4.모듈 내부의 자료 구조와 접근 동작들에만 수정을 국한하기 때문에 요구사항 등변화에 따른 수정이 불가능하다.",
  "commentary" : "정답은 \"모듈 내부의 자료 구조와 접근 동작들에만 수정을 국한하기 때문에 요구사항 등변화에 따른 수정이 불가능하다.\" 이다. 이유는 정보 은닉은 모듈 내부의 구현 세부사항을 외부로부터 숨기는 것이지만, 이는 모듈의 인터페이스를 통해 외부와 상호작용할 수 있도록 해야 한다. 따라서 요구사항이 변경되어도 모듈의 인터페이스를 유지하면서 내부 구현을 수정할 수 있어야 한다. 정보 은닉이 요구사항 변경에 대한 유연성을 제한하는 것은 잘못된 설계이다.",
  "choices" : "1.필요하지 않은 정보는 접근할 수 없도록 하여 한 모듈 또는 하부시스템이 다른 모듈의 구현에 영향을 받지 않게 설계되는것을 의미한다./2.모듈들 사이의 독립성을 유지시키는 데 도움이 된다./3.설계에서 은닉되어야 할 기본 정보로는 IP주소와 같은 물리적 코드, 상세 데이터 구조 등이 있다./4.모듈 내부의 자료 구조와 접근 동작들에만 수정을 국한하기 때문에 요구사항 등변화에 따른 수정이 불가능하다./"
}, {
  "question" : "소프트웨어 공학에서 모델링 (Modeling)과 관련한 설명으로 틀린 것은?",
  "answer" : "2.유지보수 단계에서만 모델링 기법을 활용한다.",
  "commentary" : "\"유지보수 단계에서만 모델링 기법을 활용한다.\"는 틀린 설명입니다. 모델링은 개발 생명주기의 여러 단계에서 활용될 수 있으며, 요구분석, 설계, 구현, 테스트 등 다양한 단계에서 사용됩니다. 유지보수 단계에서도 모델링 기법을 활용할 수 있지만, 그 외의 단계에서도 활용됩니다. 모델링은 시스템 개발 과정에서 응용문제를 이해하고 설계하는 데 도움을 주며, 여러 분야의 엔지니어들이 공통된 개념을 공유하는 데도 도움을 줍니다. 절차적인 프로그램을 위한 자료흐름도는 프로세스 위주의 모델링 방법 중 하나입니다.",
  "choices" : "1.개발팀이 응용문제를 이해하는 데 도움을 줄 수 있다./2.유지보수 단계에서만 모델링 기법을 활용한다./3.개발될 시스템에 대하여 여러 분야의 엔지니어들이 공통된 개념을 공유하는 데 도움을 준다./4.절차적인 프로그램을 위한 자료흐름도는 프로세스 위주의 모델링 방법이다./"
}, {
  "question" : "요구 분석(Requirement Analysis)에 대한 설명으로 틀린 것은?",
  "answer" : "4.기능적(Functional) 요구에서 시스템 구축에대한 성능, 보안, 품질, 안정 등에 대한 요구사항을 도출한다.",
  "commentary" : null,
  "choices" : "1.요구 분석은 소프트웨어 개발의 실제적인 첫 단계로 사용자의 요구에 대해 이해하는 단계라 할 수 있다./2.요구 추출(Requirement Elicitation)은 프로젝트 계획 단계에 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계이다./3.도메인 분석(Domain Analysis)은 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링을 하게 된다./4.기능적(Functional) 요구에서 시스템 구축에대한 성능, 보안, 품질, 안정 등에 대한 요구사항을 도출한다./"
}, {
  "question" : "클래스 다이어그램의 요소로 다음 설명에 해당하는 용어는?",
  "answer" : "2.Operation",
  "commentary" : "클래스 다이어그램에서 Operation은 클래스가 수행할 수 있는 동작이나 함수를 나타내는 요소입니다. 이러한 동작은 클래스의 인스턴스에 의해 호출될 수 있으며, 클래스의 기능을 구현하는 데 사용됩니다. 따라서 위의 다이어그램에서 \"withdraw()\"와 \"deposit()\"는 Account 클래스의 Operation에 해당합니다.",
  "choices" : "1.Instance/2.Operation/3.Item/4.Hiding/"
}, {
  "question" : "분산 시스템을 위한 마스터-슬레이브(Master-Slave) 아키텍처에 대한 설명으로 틀린 것은?",
  "answer" : "3.슬레이브 프로세스는 데이터 수집 기능을 수행할 수 없다.",
  "commentary" : "슬레이브 프로세스는 데이터 수집 기능을 수행할 수 없다는 설명이 틀린 것입니다. 슬레이브 프로세스는 일반적으로 데이터 수집 및 처리를 담당하며, 마스터 프로세스는 슬레이브 프로세스들을 제어하고 조정하는 역할을 합니다.",
  "choices" : "1.일반적으로 실시간 시스템에서 사용된다./2.마스터 프로세스는 일반적으로 연산, 통신, 조정을 책임진다./3.슬레이브 프로세스는 데이터 수집 기능을 수행할 수 없다./4.마스터 프로세스는 슬레이브 프로세스들을 제어할 수 있다./"
}, {
  "question" : "요구 사항 정의 및 분석·설계의 결과물을 표현하기 위한 모델링 과정에서 사용되는 다이어그램(Diagram)이 아닌 것은?",
  "answer" : "4.AVL Diagram",
  "commentary" : "AVL Diagram은 요구 사항 정의 및 분석·설계의 결과물을 표현하기 위한 모델링 과정에서 사용되지 않는다. AVL Diagram은 이진 검색 트리의 균형을 유지하기 위한 자료 구조를 나타내는 것으로, 소프트웨어 개발과는 관련이 없다. 따라서 정답은 \"AVL Diagram\"이다.",
  "choices" : "1.Data Flow Diagram/2.UML Diagram/3.E-R Diagram/4.AVL Diagram/"
}, {
  "question" : "객체지향의 주요 개념에 대한 설명으로 틀린 것은?",
  "answer" : "1.캡슐화는 상위클래스에서 속성이나 연산을 전달받아 새로운 형태의 클래스로 확장하여 사용하는 것을 의미한다.",
  "commentary" : "\"캡슐화는 상위클래스에서 속성이나 연산을 전달받아 새로운 형태의 클래스로 확장하여 사용하는 것을 의미한다.\" 이 설명이 틀린 이유는 캡슐화는 객체의 속성과 연산을 외부에서 직접 접근하지 못하도록 정보를 은닉하는 것을 의미하기 때문이다. 따라서 상위클래스에서 속성이나 연산을 전달받아 새로운 형태의 클래스로 확장하여 사용하는 것은 상속(inheritance)의 개념이다.",
  "choices" : "1.캡슐화는 상위클래스에서 속성이나 연산을 전달받아 새로운 형태의 클래스로 확장하여 사용하는 것을 의미한다./2.객체는 실세계에 존재하거나 생각할 수 있는 것을 말한다./3.클래스는 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 것이다./4.다형성은 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질이다./"
}, {
  "question" : "사용자 인터페이스(User Interface)에 대한 설명으로 틀린 것은?",
  "answer" : "2.편리한 유지보수를 위해 개발자 중심으로 설계되어야 한다.",
  "commentary" : "\"편리한 유지보수를 위해 개발자 중심으로 설계되어야 한다.\"이 틀린 설명입니다. UI는 사용자와 시스템 간의 상호작용을 원활하게 하기 위한 것이므로 사용자 중심으로 설계되어야 합니다. 개발자 중심으로 설계하면 사용자가 이해하기 어렵고 불편한 UI가 만들어질 수 있습니다. 따라서 사용자 요구사항을 충분히 반영하고, 사용자가 쉽게 배우고 사용할 수 있도록 UI를 구성해야 합니다.",
  "choices" : "1.사용자와 시스템이 정보를 주고받는 상호작용이 잘 이루어지도록 하는 장치나 소프트웨어를 의미한다./2.편리한 유지보수를 위해 개발자 중심으로 설계되어야 한다./3.배우기가 용이하고 쉽게 사용할 수 있도록 만들어져야 한다./4.사용자 요구사항이 UI에 반영될 수 있도록 구성해야 한다./"
}, {
  "question" : "GoF(Gang of Four) 디자인 패턴과 관련한 설명으로 틀린 것은?",
  "answer" : "2.Strategy 패턴은 대표적인 구조 패턴으로 인스턴스를 복제하여 사용하는 구조를 말한다.",
  "commentary" : "정답은 \"Strategy 패턴은 대표적인 구조 패턴으로 인스턴스를 복제하여 사용하는 구조를 말한다.\" 이다. Strategy 패턴은 행위 패턴 중 하나로, 알고리즘을 캡슐화하여 동적으로 교체할 수 있도록 하는 패턴이다. 따라서 인스턴스를 복제하여 사용하는 구조와는 관련이 없다. 그 외의 보기들은 모두 맞는 설명이다. 디자인 패턴은 생성, 구조, 행위로 분류할 수 있으며, 행위 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다. Singleton 패턴은 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 대한 접근 방법을 제공한다.",
  "choices" : "1.디자인 패턴을 목적(Purpose)으로 분류할 때 생성, 구조, 행위로 분류할 수 있다./2.Strategy 패턴은 대표적인 구조 패턴으로 인스턴스를 복제하여 사용하는 구조를 말한다./3.행위 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다./4.Singleton 패턴은 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 대한 접근 방법을 제공한다./"
}, {
  "question" : "애자일 개발 방법론과 관련한 설명으로 틀린 것은?",
  "answer" : "2.정확한 결과 도출을 위해 계획 수립과 문서화에 중점을 둔다.",
  "commentary" : "정답은 \"정확한 결과 도출을 위해 계획 수립과 문서화에 중점을 둔다.\" 이다. 애자일 개발 방법론은 계획 수립과 문서화보다는 작은 주기로 빠른 릴리즈를 통해 문제점을 파악하고, 고객과의 지속적인 의사소통을 통해 진화하는 요구사항을 수용하는 것을 중요시한다. 따라서 정확한 결과 도출보다는 유연성과 빠른 대응력을 강조한다.",
  "choices" : "1.빠른 릴리즈를 통해 문제점을 빠르게 파악할 수 있다./2.정확한 결과 도출을 위해 계획 수립과 문서화에 중점을 둔다./3.고객과의 의사소통을 중요하게 생각한다./4.진화하는 요구사항을 수용하는데 적합하다./"
}, {
  "question" : "럼바우(Rumbaugh)의 객체지향 분석 기법 중 자료 흐름도(DFD)를 주로 이용하는 것은?",
  "answer" : "1.기능 모델링",
  "commentary" : "자료 흐름도(DFD)는 시스템의 데이터 흐름을 중심으로 분석하는 기법으로, 기능 모델링에 주로 이용됩니다. 기능 모델링은 시스템의 기능적인 측면을 중심으로 분석하는 것으로, 시스템의 입력과 출력, 그리고 그 사이에서 수행되는 기능들을 나타내는 모델링 기법입니다. 따라서 자료 흐름도를 이용하여 시스템의 데이터 흐름을 분석하고, 이를 기반으로 시스템의 기능적인 측면을 모델링하는 것이 기능 모델링의 핵심입니다.",
  "choices" : "1.기능 모델링/2.동적 모델링/3.객체 모델링/4.정적 모델링/"
}, {
  "question" : "순차 다이어그램(Sequence Diagram)과 관련한 설명으로 틀린 것은?",
  "answer" : "3.동적 다이어그램보다는 정적 다이어그램에 가깝다.",
  "commentary" : null,
  "choices" : "1.객체들의 상호 작용을 나타내기 위해 사용한다./2.시간의 흐름에 따라 객체들이 주고 받는 메시지의 전달 과정을 강조한다./3.동적 다이어그램보다는 정적 다이어그램에 가깝다./4.교류 다이어그램(Interaction Diagram)의 한 종류로 볼 수 있다./"
}, {
  "question" : "객체지향 분석 기법과 관련한 설명으로 틀린것은?",
  "answer" : "2.기능 중심으로 시스템을 파악하며 순차적인처리가 중요시되는 하향식(Top-down)방식으로 볼 수 있다.",
  "commentary" : "\"기능 중심으로 시스템을 파악하며 순차적인 처리가 중요시되는 하향식(Top-down)방식으로 볼 수 있다.\"는 객체지향 분석 기법과 관련한 설명으로 틀린 것이다. 객체지향 분석 기법은 기능 중심보다는 객체 중심으로 시스템을 파악하며, 상위 객체와 하위 객체 간의 상호작용을 중요시하는 상향식(bottom-up) 방식으로 볼 수 있다.",
  "choices" : "1.동적 모델링 기법이 사용될 수 있다./2.기능 중심으로 시스템을 파악하며 순차적인처리가 중요시되는 하향식(Top-down)방식으로 볼 수 있다./3.데이터와 행위를 하나로 묶어 객체를 정의내리고 추상화시키는 작업이라 할 수 있다./4.코드 재사용에 의한 프로그램 생산성 향상 및 요구에 따른 시스템의 쉬운 변경이 가능하다./"
}, {
  "question" : "대표적으로 DOS 및 Unix 등의 운영체제에서조작을 위해 사용하던 것으로, 정해진 명령문자열을 입력하여 시스템을 조작하는 사용자인터페이스(User Interface)는?",
  "answer" : "2.CLI(Command Line Interface)",
  "commentary" : "CLI는 명령어를 입력하여 시스템을 조작하는 사용자 인터페이스이기 때문에, 주로 텍스트 기반의 운영체제에서 사용된다. GUI는 그래픽으로 표현된 사용자 인터페이스이며, CUI는 셀 기반의 사용자 인터페이스이다. MUI는 모바일 기기에서 사용되는 사용자 인터페이스이다. 따라서, CLI가 정답이다.",
  "choices" : "1.GUI(Graphical User Interface)/2.CLI(Command Line Interface)/3.CUI(Cell User Interface)/4.MUI(Mobile User Interface)/"
}, {
  "question" : "분산 시스템에서의 미들웨어 (Middleware)와 관련한 설명으로 틀린 것은?",
  "answer" : "4.애플리케이션과 사용자 사이에서만 분산서비스를 제공한다.",
  "commentary" : "\"애플리케이션과 사용자 사이에서만 분산서비스를 제공한다.\"는 틀린 설명입니다. 미들웨어는 분산 시스템에서 다양한 부분을 관리하고 통신하며 데이터를 교환하는 소프트웨어로 볼 수 있습니다. 또한 위치 투명성을 제공하고 분산 시스템의 여러 컴포넌트가 요구하는 재사용 가능한 서비스의 구현을 제공합니다. 따라서 미들웨어는 애플리케이션과 사용자 사이뿐만 아니라 분산 시스템 내의 다양한 컴포넌트 간에도 분산 서비스를 제공합니다.",
  "choices" : "1.분산 시스템에서 다양한 부분을 관리하고 통신하며 데이터를 교환하게 해주는소프트웨어로 볼 수 있다./2.위치 투명성(Location Transparency)을 제공한다./3.분산 시스템의 여러 컴포넌트가 요구하는 재사용가능한 서비스의 구현을 제공한다./4.애플리케이션과 사용자 사이에서만 분산서비스를 제공한다./"
}, {
  "question" : "소프트웨어 아키텍처와 관련한 설명으로 틀린것은?",
  "answer" : "1.파이프 필터 아키텍처에서 데이터는 파이프를 통해 양방향으로 흐르며, 필터 이동 시 오버헤드가 발생하지 않는다.",
  "commentary" : "\"파이프 필터 아키텍처에서 데이터는 파이프를 통해 양방향으로 흐르며, 필터 이동 시 오버헤드가 발생하지 않는다.\"는 틀린 설명입니다. 파이프 필터 아키텍처에서는 데이터가 단방향으로만 흐르며, 필터 이동 시에는 오버헤드가 발생할 수 있습니다. 이는 파이프 필터 아키텍처의 특징 중 하나로, 필터 간의 데이터 전송을 위해 중간 버퍼를 사용하기 때문입니다.",
  "choices" : "1.파이프 필터 아키텍처에서 데이터는 파이프를 통해 양방향으로 흐르며, 필터 이동 시 오버헤드가 발생하지 않는다./2.외부에서 인식할 수 있는 특성이 담긴 소프트웨어의 골격이 되는 기본 구조로 볼수 있다./3.데이터 중심 아키텍처는 공유 데이터저장소를 통해 접근자 간의 통신이 이루어지므로 각 접근자의 수정과 확장이 용이하다./4.이해 관계자들의 품질 요구사항을 반영하여 품질 속성을 결정한다./"
}, {
  "question" : "테스트를 목적에 따라 분류했을 때,강도(Stress) 테스트에 대한 설명으로 옳은것은?",
  "answer" : "2.시스템에 과다 정보량을 부과하여 과부하 시에도 시스템이 정상적으로 작동되는지를 테스트한다.",
  "commentary" : "강도(Stress) 테스트는 시스템에 과다 정보량을 부과하여 과부하 시에도 시스템이 정상적으로 작동되는지를 테스트하는 것이다. 즉, 시스템이 최대한의 부하를 견딜 수 있는지를 확인하는 테스트이다.",
  "choices" : "1.시스템에 고의로 실패를 유도하고 시스템이정상적으로 복귀하는지 테스트한다./2.시스템에 과다 정보량을 부과하여 과부하 시에도 시스템이 정상적으로 작동되는지를 테스트한다./3.사용자의 이벤트에 시스템이 응답하는 시간,특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 테스트한다./4.부당하고 불법적인 침입을 시도하여 보안시스템이 불법적인 침투를 잘 막아내는지 테스트한다./"
}, {
  "question" : "다음 자료를 버블 정렬을 이용하여오름차순으로 정렬할 경우 PASS 3의 결과는?",
  "answer" : "2.3, 5, 6, 7, 9",
  "commentary" : null,
  "choices" : "1.6, 3, 5, 7, 9/2.3, 5, 6, 7, 9/3.6, 7, 3, 5, 9/4.3, 5, 9, 6, 7/"
}, {
  "question" : "다음 그래프에서 정점 A를 선택하여 깊이우선탐색(DFS)으로 운행한 결과는?",
  "answer" : "4.ABEFGCD",
  "commentary" : "정점 A에서 시작하여 DFS를 수행하면 A-B-E-F-G-C-D 순서로 운행하게 됩니다. 따라서 정답은 \"ABEFGCD\"가 됩니다. 보기 중에서 \"ABEFGCD\"가 정답인 이유는 다음과 같습니다. - \"ABECDFG\": E와 F의 순서가 바뀌어 있습니다. - \"ABECFDG\": E와 F의 순서가 바뀌어 있습니다. 또한 C와 D의 순서도 바뀌어 있습니다. - \"ABCDEFG\": DFS로 탐색할 때는 A-B-C-D 순서로 탐색하게 됩니다. 따라서 정답이 될 수 없습니다. - \"ABEFGCD\": DFS로 탐색할 때 A-B-E-F-G-C-D 순서로 탐색하게 됩니다. 따라서 정답이 됩니다.",
  "choices" : "1.ABECDFG/2.ABECFDG/3.ABCDEFG/4.ABEFGCD/"
}, {
  "question" : "다음 설명에 부합하는 용어로 옳은 것은?",
  "answer" : "3.모듈",
  "commentary" : "이 그림은 하나의 큰 프로그램을 여러 개의 작은 모듈로 나누어 개발하는 모듈화 방식을 보여줍니다. 따라서 정답은 \"모듈\"입니다. 모듈은 하나의 기능을 수행하는 프로그램의 일부분으로, 독립적으로 개발하고 테스트할 수 있으며, 다른 모듈과 결합하여 하나의 큰 프로그램을 만들 수 있습니다.",
  "choices" : "1.통합 프로그램/2.저장소/3.모듈/4.데이터/"
}, {
  "question" : "테스트 드라이버(Test Driver)에 대한 설명으로 틀린 것은?",
  "answer" : "4.테스트 대상 모듈이 호출하는 하위 모듈의 역할을 한다.",
  "commentary" : "정답은 \"테스트 대상 모듈이 호출하는 하위 모듈의 역할을 한다.\"가 아닌 다른 보기입니다. 테스트 드라이버(Test Driver)는 시험대상 모듈을 호출하는 간이 소프트웨어로, 필요에 따라 매개 변수를 전달하고 모듈을 수행한 후의 결과를 보여줄 수 있습니다. 또한 상향식 통합 테스트에서 사용됩니다. 하지만 테스트 대상 모듈이 호출하는 하위 모듈의 역할을 하는 것은 테스트 스텁(Test Stub)입니다. 테스트 스텁은 테스트 대상 모듈이 호출하는 하위 모듈의 대역을 대신하여 테스트를 수행합니다.",
  "choices" : "1.시험대상 모듈을 호출하는 간이 소프트웨어이다./2.필요에 따라 매개 변수를 전달하고 모듈을 수행한 후의 결과를 보여줄 수 있다./3.상향식 통합 테스트에서 사용된다./4.테스트 대상 모듈이 호출하는 하위 모듈의 역할을 한다./"
}, {
  "question" : "다음 중 선형 구조로만 묶인 것은?",
  "answer" : "2.큐, 데크",
  "commentary" : "큐와 데크는 선형 구조로만 묶인 자료구조입니다. 스택과 트리는 비선형 구조이며, 그래프는 비선형 구조이면서 순환 구조를 가지기 때문에 선형 구조로만 묶인 것이 아닙니다. 리스트는 선형 구조이지만, 그래프는 비선형 구조이기 때문에 선형 구조로만 묶인 것이 아닙니다.",
  "choices" : "1.스택, 트리/2.큐, 데크/3.큐, 그래프/4.리스트, 그래프/"
}, {
  "question" : "다음은 스택의 자료 삭제 알고리즘이다. ⓐ에 들어 갈 내용으로 옳은 것은? (단, Top: 스택포인터, S: 스택의 이름)",
  "answer" : "3.Underflow",
  "commentary" : "스택에서 데이터를 삭제할 때는 Top 값을 1 감소시키고, 해당 위치의 데이터를 반환한다. 그러나, 이미 스택이 비어있는 상태에서 삭제를 시도하면 Top 값이 음수가 되어버리게 되는데, 이는 스택의 범위를 벗어나는 것이므로 \"Underflow\"가 발생한다.",
  "choices" : "1.Overflow/2.Top = Top + 1/3.Underflow/4.Top = Top/"
}, {
  "question" : "제품 소프트웨어의 사용자 매뉴얼 작성절차로 (가)~(다)와 [보기]의 기호를 바르게 연결한 것은?",
  "answer" : "2.(가)-㉢, (나)-㉡, (다)-㉠",
  "commentary" : "정답은 \"(가)-㉢, (나)-㉡, (다)-㉠\"입니다. (가)는 \"제품 소프트웨어의 사용자 매뉴얼 작성 계획 수립\" 단계이므로, 작성할 매뉴얼의 범위와 구성 등을 계획하는 것이 중요합니다. 따라서, 작성할 매뉴얼의 범위를 파악하고, 작성 방법과 구성 등을 결정하는 것이 필요합니다. 이를 위해 (가)는 계획서를 작성하고, 이를 기반으로 작성할 매뉴얼의 구성과 내용을 정합니다. 이 과정에서는 (가)-㉢의 순서로 진행됩니다. (나)는 \"제품 소프트웨어의 사용자 매뉴얼 작성\" 단계이므로, 실제로 매뉴얼을 작성하는 것이 중요합니다. 이를 위해 (나)는 작성 계획서를 기반으로 매뉴얼의 구성과 내용을 작성합니다. 이 과정에서는 (나)-㉡의 순서로 진행됩니다. (다)는 \"제품 소프트웨어의 사용자 매뉴얼 검토 및 보완\" 단계이므로, 작성된 매뉴얼을 검토하고 보완하는 것이 중요합니다. 이를 위해 (다)는 작성된 매뉴얼을 검토하고, 필요한 보완 작업을 수행합니다. 이 과정에서는 (다)-㉠의 순서로 진행됩니다.",
  "choices" : "1.(가)-㉠, (나)-㉡, (다)-㉢/2.(가)-㉢, (나)-㉡, (다)-㉠/3.(가)-㉠, (나)-㉢, (다)-㉡/4.(가)-㉢, (나)-㉠, (다)-㉡/"
}, {
  "question" : "순서가 A, B, C, D로 정해진 입력 자료를 스택에 입력한 후 출력한 결과로 불가능한 것은?",
  "answer" : "4.D, B, C, A",
  "commentary" : null,
  "choices" : "1.D, C, B, A/2.B, C, D, A/3.C, B, A, D/4.D, B, C, A/"
}, {
  "question" : "소프트웨어 테스트에서 검증(Verification)과 확인 (Validation)에 대한 설명으로 틀린 것은?",
  "answer" : "4.검증은 작업 제품이 사용자의 요구에 적합한지 측정하며, 확인은 작업 제품이 개발자의 기대를 충족시키는지를 측정한다.",
  "commentary" : null,
  "choices" : "1.소프트웨어 테스트에서 검증과 확인을 구별하면 찾고자 하는 결함 유형을 명확하게 하는 데 도움이 된다./2.검증은 소프트웨어 개발 과정을 테스트하는 것이고, 확인은 소프트웨어 결과를 테스트 하는 것이다./3.검증은 작업 제품이 요구 명세의 기능, 비기능 요구사항을 얼마나 잘 준수하는지 측정하는 작업이다./4.검증은 작업 제품이 사용자의 요구에 적합한지 측정하며, 확인은 작업 제품이 개발자의 기대를 충족시키는지를 측정한다./"
}, {
  "question" : "개별 모듈을 시험하는 것으로 모듈이 정확하게 구현되었는지, 예정한 기능이 제대로 수행되는지를 점검하는 것이 주요 목적인 테스트는?",
  "answer" : "2.단위 테스트(Unit Test)",
  "commentary" : "개별 모듈을 시험하는 것이 주요 목적이기 때문에 \"단위 테스트(Unit Test)\"가 정답입니다. 단위 테스트는 개발자가 작성한 코드의 각각의 함수나 모듈을 분리하여 테스트하는 것으로, 코드의 오류를 빠르게 발견하고 수정할 수 있도록 도와줍니다. 또한, 단위 테스트는 코드의 유지보수성을 높이고, 코드의 재사용성을 높이는 등의 장점을 가지고 있습니다.",
  "choices" : "1.통합 테스트(Integration Test)/2.단위 테스트(Unit Test)/3.시스템 테스트(System Test)/4.인수 테스트(Acceptance Test)/"
}, {
  "question" : "형상 관리의 개념과 절차에 대한 설명으로 틀린 것은?",
  "answer" : "3.형상 통제 과정에서는 형상 목록의 변경 요구를 즉시 수용 및 반영해야 한다.",
  "commentary" : "\"형상 통제 과정에서는 형상 목록의 변경 요구를 즉시 수용 및 반영해야 한다.\"이 부분이 틀린 것입니다. 형상 통제 과정에서는 변경 요구를 검토하고 승인 절차를 거친 후에 변경을 수용하고 반영해야 합니다. 변경 요구를 즉시 수용하면 형상 관리의 일관성과 안정성을 해치게 됩니다.",
  "choices" : "1.형상 식별은 형상 관리 계획을 근거로 형상관리의 대상이 무엇인지 식별하는 과정이다./2.형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 높일 수 있다./3.형상 통제 과정에서는 형상 목록의 변경 요구를 즉시 수용 및 반영해야 한다./4.형상 감사는 형상 관리 계획대로 형상관리가 진행되고 있는지, 형상 항목의 변경이 요구 사항에 맞도록 제대로 이뤄졌는지 등을 살펴보는 활동이다./"
}, {
  "question" : "소스코드 정적 분석(Static Analysis)에 대한 설명으로 틀린 것은?",
  "answer" : "3.하드웨어적인 방법으로만 코드 분석이 가능하다.",
  "commentary" : "\"하드웨어적인 방법으로만 코드 분석이 가능하다.\"는 틀린 설명입니다. 소스코드 정적 분석은 소프트웨어적인 방법으로 코드를 분석합니다. 따라서 소스코드를 실행시키지 않고 코드에 있는 오류나 잠재적인 오류를 찾아내기 위한 활동이며, 자료 흐름이나 논리 흐름을 분석하여 비정상적인 패턴을 찾을 수 있습니다.",
  "choices" : "1.소스 코드를 실행시키지 않고 분석한다./2.코드에 있는 오류나 잠재적인 오류를 찾아내기 위한 활동이다./3.하드웨어적인 방법으로만 코드 분석이 가능하다./4.자료 흐름이나 논리 흐름을 분석하여 비정상적인 패턴을 찾을 수 있다./"
}, {
  "question" : "소프트웨어 개발 활동을 수행함에 있어서 시스템이 고장(Failure)을 일으키게 하며, 오류(Error)가 있는 경우 발생하는 것은?",
  "answer" : "1.Fault",
  "commentary" : "시스템이 고장을 일으키거나 오류가 발생하는 것은 \"Fault\"이다. 이는 소프트웨어 개발 과정에서 발생하는 결함이나 버그로 인해 발생할 수 있다. Testcase는 테스트 케이스, Mistake는 실수, Inspection은 검사를 의미한다.",
  "choices" : "1.Fault/2.Testcase/3.Mistake/4.Inspection/"
}, {
  "question" : "코드의 간결성을 유지하기 위해 사용되는 지침으로 틀린 것은?",
  "answer" : "4.한 줄에 최대한 많은 문장을 코딩한다.",
  "commentary" : "\"한 줄에 최대한 많은 문장을 코딩한다.\"는 코드의 가독성을 떨어뜨리기 때문에 올바른 지침이 아니다. 한 줄에는 하나의 문장만 코딩하는 것이 좋다. 이렇게 하면 코드를 읽고 이해하기 쉬워지며, 디버깅이나 유지보수도 용이해진다.",
  "choices" : "1.공백을 이용하여 실행문 그룹과 주석을 명확히 구분한다./2.복잡한 논리식과 산술식은 괄호와 들여쓰기(Indentation)를 통해 명확히 표현한다./3.빈 줄을 사용하여 선언부와 구현부를 구별한다./4.한 줄에 최대한 많은 문장을 코딩한다./"
}, {
  "question" : "소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은?",
  "answer" : "1.Portability",
  "commentary" : "\"Portability\"는 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미합니다. 다른 세 가지 목표인 \"Efficiency\", \"Usability\", \"Correctness\"는 시스템의 성능, 사용자 친화성, 정확성을 강조하는 것이지만, \"Portability\"는 시스템이 다양한 하드웨어 환경에서도 동작할 수 있도록 하는 능력을 강조합니다. 따라서 \"Portability\"가 정답입니다.",
  "choices" : "1.Portability/2.Efficiency/3.Usability/4.Correctness/"
}, {
  "question" : "다음 중 최악의 경우 검색 효율이 가장 나쁜트리 구조는?",
  "answer" : "1.이진 탐색트리",
  "commentary" : "이진 탐색트리는 데이터가 정렬되어 있지 않은 경우, 최악의 경우에는 모든 노드를 탐색해야 하기 때문에 검색 효율이 가장 나쁩니다. 이는 트리의 높이가 데이터의 개수와 같아지는 경우에 발생합니다. 따라서 이진 탐색트리는 데이터가 정렬되어 있을 때 가장 효율적으로 작동하며, 데이터의 삽입, 삭제에 대한 처리도 다른 트리 구조에 비해 복잡합니다.",
  "choices" : "1.이진 탐색트리/2.AVL 트리/3.2-3 트리/4.레드-블랙 트리/"
}, {
  "question" : "다음 트리에 대한 중위 순회 운행 결과는?",
  "answer" : "4.DBAECF",
  "commentary" : "중위 순회는 왼쪽 자식 노드, 현재 노드, 오른쪽 자식 노드 순으로 운행하므로, 이를 따라가면 \"DBAECF\"가 된다. 즉, D를 루트로 하는 서브트리의 왼쪽 자식인 B를 먼저 방문하고, 그 다음에는 A를 방문하고, 다시 D를 방문한 후에 오른쪽 자식인 E를 방문하고, 그 다음에는 C를 방문하고, 마지막으로 F를 방문하면 된다.",
  "choices" : "1.ABDCEF/2.ABCDEF/3.DBECFA/4.DBAECF/"
}, {
  "question" : "테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 찾아내는 방법이 아닌 것은?",
  "answer" : "1.스터브(Stub)와 드라이버(Driver)",
  "commentary" : "스터브와 드라이버는 테스트 케이스 자동 생성 도구가 아니라, 소프트웨어 테스트에서 사용되는 기술이다. 스터브는 특정 모듈의 기능을 대체하는 가짜 모듈을 만들어서 테스트를 수행하는 것이고, 드라이버는 특정 모듈을 호출하여 테스트를 수행하는 것이다. 따라서 스터브와 드라이버는 테스트 데이터를 찾아내는 방법이 아니라, 테스트를 수행하는 방법 중 하나이다. 입력 도메인 분석, 랜덤 테스트, 자료 흐름도는 모두 테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 찾아내는 방법이다.",
  "choices" : "1.스터브(Stub)와 드라이버(Driver)/2.입력 도메인 분석/3.랜덤(Random) 테스트/4.자료 흐름도/"
}, {
  "question" : "저작권 관리 구성 요소 중 패키저(Packager)의 주요 역할로 옳은 것은?",
  "answer" : "2.콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는다.",
  "commentary" : "패키저는 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 역할을 합니다. 이는 콘텐츠를 보다 효율적으로 관리하고 배포할 수 있도록 도와주는 역할입니다. 예를 들어, 여러 개의 책을 하나의 패키지로 묶어서 판매할 수 있습니다. 이렇게 하면 책을 개별적으로 판매하는 것보다 효율적으로 관리할 수 있으며, 고객도 한 번에 여러 책을 구매할 수 있습니다.",
  "choices" : "1.콘텐츠를 제공하는 저작권자를 의미한다./2.콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는다./3.라이선스를 발급하고 관리한다./4.배포된 콘텐츠의 이용 권한을 통제한다./"
}, {
  "question" : "데이터베이스의 무결성 규정(Integrity Rule)과 관련한 설명으로 틀린 것은?",
  "answer" : "3.정식으로 허가 받은 사용자가 아닌 불법적인 사용자에 의한 갱신으로부터 데이터베이스를 보호하기 위한 규정이다.",
  "commentary" : "정식으로 허가 받은 사용자가 아닌 불법적인 사용자에 의한 갱신으로부터 데이터베이스를 보호하기 위한 규정이 아니다. 데이터베이스의 무결성 규정은 데이터의 일관성, 정확성, 유효성 등을 보장하기 위한 규정이다. 따라서 무단 접근이나 갱신을 막기 위한 보안 규정과는 다른 개념이다.",
  "choices" : "1.무결성 규정에는 데이터가 만족해야 될 제약 조건, 규정을 참조할 때 사용하는 식별자 등의 요소가 포함될 수 있다./2.무결성 규정의 대상으로는 도메인, 키, 종속성 등이 있다./3.정식으로 허가 받은 사용자가 아닌 불법적인 사용자에 의한 갱신으로부터 데이터베이스를 보호하기 위한 규정이다./4.릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이 션을 조작하는 과정에서의 의미적 관계(Semantic Relationship)을 명세한 것이다./"
}, {
  "question" : "데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미하는 것은?",
  "answer" : "1.트랜잭션",
  "commentary" : "트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 의미합니다. 이는 데이터베이스에서 데이터를 안전하게 처리하기 위해 필요한 개념으로, 한꺼번에 모두 수행되어야 할 일련의 연산들을 포함합니다. 예를 들어, 계좌 이체를 수행하는 경우, 출금과 입금 두 개의 연산이 모두 성공적으로 수행되어야만 전체적으로 이체가 완료됩니다. 이러한 일련의 연산들을 하나의 트랜잭션으로 묶어서 처리하면, 데이터의 일관성과 무결성을 보장할 수 있습니다.",
  "choices" : "1.트랜잭션/2.뷰/3.튜플/4.카디널리티/"
}, {
  "question" : "다음 두 릴레이션 Rl과 R2의 카티션 프로덕트(cartesian product) 수행 결과는?",
  "answer" : "4.",
  "commentary" : "카티션 프로덕트는 두 릴레이션의 모든 가능한 조합을 구하는 것이므로, R1의 튜플 수가 3개이고 R2의 튜플 수가 2개이므로 총 3 x 2 = 6개의 튜플이 생성됩니다. 따라서 정답은 \"\" 입니다.",
  "choices" : "1./2./3./4./"
}, {
  "question" : "물리적 데이터베이스 설계에 대한 설명으로 거리가 먼 것은?",
  "answer" : "4.트랜잭션의 인터페이스를 설계하며, 데이터 타입 및 데이터 타입들 간의 관계로 표현한다.",
  "commentary" : "\"트랜잭션의 인터페이스를 설계하며, 데이터 타입 및 데이터 타입들 간의 관계로 표현한다.\"가 다른 항목들과는 다르게 논리적 데이터베이스 설계에 해당하기 때문이다. 물리적 데이터베이스 설계는 논리적 데이터베이스 설계를 기반으로 하여 실제 저장장치에 데이터를 저장하는 방법을 결정하는 것이 목적이다. 따라서 저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 설계하며, 트랜잭션 처리량과 응답시간, 디스크 용량 등을 고려해야 한다.",
  "choices" : "1.물리적 설계의 목적은 효율적인 방법으로 데이터를 저장하는 것이다./2.트랜잭션 처리량과 응답시간, 디스크 용량 등을 고려해야 한다./3.저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 설계한다./4.트랜잭션의 인터페이스를 설계하며, 데이터 타입 및 데이터 타입들 간의 관계로 표현한다./"
}, {
  "question" : "다음 중 기본키는 NULL 값을 가져서는 안되며, 릴레이션 내에 오직 하나의 값만 존재해야 한다는 조건을 무엇이라 하는가?",
  "answer" : "1.개체 무결성 제약조건",
  "commentary" : "기본키는 릴레이션 내에서 각 행을 유일하게 식별하는 역할을 하기 때문에 NULL 값을 가질 수 없으며, 중복된 값이 존재해서도 안된다. 이러한 조건을 보장하기 위해 사용되는 제약조건이 \"개체 무결성 제약조건\"이다. 따라서 정답은 \"개체 무결성 제약조건\"이다.",
  "choices" : "1.개체 무결성 제약조건/2.참조 무결성 제약조건/3.도메인 무결성 제약조건/4.속성 무결성 제약조건/"
}, {
  "question" : "SQL문에서 HAVING을 사용할 수 있는 절은?",
  "answer" : "3.GROUP BY 절",
  "commentary" : "HAVING 절은 그룹화된 결과에 대한 조건을 지정하는 절이다. 따라서 HAVING 절을 사용하려면 먼저 그룹화된 결과를 얻기 위해 GROUP BY 절을 사용해야 한다. 따라서 정답은 \"GROUP BY 절\"이다. WHERE 절은 그룹화된 결과에 대한 조건을 지정하는 것이 아니라, 원본 데이터에 대한 조건을 지정하는 절이다. LIKE 절은 문자열 패턴 매칭을 위해 사용되는 절이며, ORDER BY 절은 결과를 정렬하는 절이다.",
  "choices" : "1.LIKE 절/2.WHERE 절/3.GROUP BY 절/4.ORDER BY 절/"
}, {
  "question" : "관계 데이터베이스에 있어서 관계 대수 연산이 아닌 것은?",
  "answer" : "4.포크(Fork)",
  "commentary" : "관계 대수 연산 중 포크(Fork)는 존재하지 않는 연산입니다. 따라서 포크가 관계 데이터베이스에 있어서 관계 대수 연산이 아닙니다.",
  "choices" : "1.디비전(Division)/2.프로젝트(Project)/3.조인(Join)/4.포크(Fork)/"
}, {
  "question" : "학적 테이블에서 전화번호가 Null값이 아닌 학생명을 모두 검색할 때, SQL 구문으로 옳은 것은?",
  "answer" : "3.SELECT 학생명 FROM 학적 WHERE 전화번호 IS NOT NULL;",
  "commentary" : "정답은 \"SELECT 학생명 FROM 학적 WHERE 전화번호 IS NOT NULL;\" 이다. 이유는 다음과 같다. 1. \"SELECT FROM 07 WHERE 전화번호 DON'T NULL;\" : 문법 오류가 있다. \"DON'T\"은 SQL에서 사용되지 않는 키워드이다. 또한, \"07\"은 테이블 이름이 아니므로 사용할 수 없다. 2. \"SELECT FROM WHERE 전화번호 != NOT NULL;\" : 문법 오류가 있다. \"SELECT\"와 \"FROM\" 사이에 테이블 이름이 빠져있다. 또한, \"!=\"는 \"NOT\"과 함께 사용할 수 없다. 3. \"SELECT 학생명 FROM 학적 WHERE 전화번호 IS NOT NULL;\" : 올바른 구문이다. \"SELECT\"로 학생명을 선택하고, \"FROM\"으로 학적 테이블을 선택하며, \"WHERE\"로 전화번호가 Null값이 아닌 데이터를 선택한다. 4. \"SELECT FROM WHERE 전화번호 IS NULL;\" : 문법 오류가 있다. \"SELECT\"와 \"FROM\" 사이에 테이블 이름이 빠져있다. 또한, \"IS NULL\"이 아닌 \"IS NOT NULL\"을 사용해야 한다.",
  "choices" : "1.SELECT FROM 07 WHERE 전화번호 DON'T NULL;/2.SELECT FROM WHERE 전화번호 != NOT NULL;/3.SELECT 학생명 FROM 학적 WHERE 전화번호 IS NOT NULL;/4.SELECT FROM WHERE 전화번호 IS NULL;/"
}, {
  "question" : "관계형 데이터베이스에서 다음 설명에 해당하는 키(Key)는?",
  "answer" : "3.슈퍼키",
  "commentary" : "이 키는 슈퍼키입니다. 슈퍼키는 유일성을 보장하는 하나 이상의 속성으로 구성된 키로, 다른 키들의 상위 개념입니다. 이 경우, \"고객번호\"와 \"계좌번호\" 두 속성으로 구성되어 있으며, 이 두 속성을 조합하면 각각의 튜플을 유일하게 식별할 수 있습니다. 따라서 이 키는 슈퍼키입니다.",
  "choices" : "1.후보키/2.대체키/3.슈퍼키/4.외래키/"
}, {
  "question" : "데이터베이스에서 인덱스(Index)와 관련한 설명으로 틀린 것은?",
  "answer" : "4.시스템이 자동으로 생성하여 사용자가 변경할 수 없다.",
  "commentary" : null,
  "choices" : "1.인덱스의 기본 목적은 검색 성능을 최적화하는 것으로 볼 수 있다./2.B-트리 인덱스는 분기를 목적으로 하는 Branch Block을 가지고 있다./3.BETWEEN 등 범위(Range) 검색에 활용될 수 있다./4.시스템이 자동으로 생성하여 사용자가 변경할 수 없다./"
}, {
  "question" : "로킹 단위(Locking Granularity)에 대한 설명으로 옳은 것은?",
  "answer" : "1.로킹 단위가 크면 병행성 수준이 낮아진다.",
  "commentary" : "로킹 단위란 데이터베이스에서 동시에 여러 사용자가 접근할 때, 각각의 사용자가 데이터를 접근하는 단위를 말한다. 로킹 단위가 크면 한 번에 많은 양의 데이터를 잠그기 때문에 다른 사용자들이 해당 데이터에 접근하지 못하고 대기해야 하므로 병행성 수준이 낮아진다. 또한, 로킹 단위가 크면 병행 제어 기법이 복잡해지고, 로크의 수가 많아진다. 따라서 로킹 단위는 가능한 작게 설정하는 것이 좋다.",
  "choices" : "1.로킹 단위가 크면 병행성 수준이 낮아진다./2.로킹 단위가 크면 병행 제어 기법이 복잡해진다./3.로킹 단위가 작으면 로크(lock)의 수가 적어진다./4.로킹은 파일 단위로 이루어지며, 레코드와 필드는 로킹 단위가 될 수 없다./"
}, {
  "question" : "관계 대수에 대한 설명으로 틀린 것은?",
  "answer" : "1.원하는 릴레이션을 정의하는 방법을 제공하며 비절차적 언어이다.",
  "commentary" : null,
  "choices" : "1.원하는 릴레이션을 정의하는 방법을 제공하며 비절차적 언어이다./2.릴레이션 조작을 위한 연산의 집합으로 피연산자와 결과가 모두 릴레이션이다./3.일반 집합 연산과 순수 관계 연산으로 구분된다./4.질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다./"
}, {
  "question" : "데이터의 중복으로 인하여 관계연산을 처리할 때 예기치 못한 곤란한 현상이 발생하는 것을 무엇이라 하는가?",
  "answer" : "1.이상(Anomaly)",
  "commentary" : "이상(Anomaly)은 데이터의 중복으로 인해 발생하는 문제로, 데이터를 수정, 삽입, 삭제할 때 예기치 못한 결과가 발생하는 것을 말한다. 이상은 제한(제약), 종속성, 변환 등의 관계연산 처리 시 발생할 수 있다고 알려져 있지만, 이 중에서 가장 일반적으로 사용되는 용어가 \"이상\"이기 때문에 정답이다.",
  "choices" : "1.이상(Anomaly)/2.제한 (Restriction)/3.종속성(Dependency)/4.변환(Translation)/"
}, {
  "question" : "다음 중 SQL에서의 DDL 문이 아닌 것은?",
  "answer" : "2.DELETE",
  "commentary" : "SQL에서의 DDL(Data Definition Language)은 데이터베이스의 구조를 정의하거나 조작하는 명령어를 말한다. CREATE, ALTER, DROP은 모두 데이터베이스의 구조를 정의하거나 조작하는 명령어이므로 DDL에 해당한다. 하지만 DELETE는 데이터베이스에서 데이터를 삭제하는 명령어이므로 DDL에 해당하지 않는다. 따라서 정답은 \"DELETE\"이다.",
  "choices" : "1.CREATE/2.DELETE/3.ALTER/4.DROP/"
}, {
  "question" : "정규화에 대한 설명으로 적절하지 않은 것은?",
  "answer" : "1.데이터베이스의 개념적 설계 단계 이전에 수행한다.",
  "commentary" : "\"데이터베이스의 개념적 설계 단계 이전에 수행한다.\"는 오히려 정규화의 목적과 반대되는 내용이다. 정규화는 데이터베이스의 개념적 설계 단계에서 수행되며, 데이터 구조의 안정성을 최대화하고 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지하며 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다는 것이 올바른 설명이다.",
  "choices" : "1.데이터베이스의 개념적 설계 단계 이전에 수행한다./2.데이터 구조의 안정성을 최대화한다./3.중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지한다./4.데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다./"
}, {
  "question" : "트랜잭션의 주요 특성 중 하나로 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음을 의미하는 것은?",
  "answer" : "3.Isolation",
  "commentary" : "정답은 \"Isolation\"입니다. 이유는 동시에 병행 실행되는 트랜잭션들이 서로 간섭하지 않고 독립적으로 실행되어야 하기 때문입니다. 이를 위해 트랜잭션은 다른 트랜잭션의 연산에 대한 영향을 받지 않도록 격리되어야 합니다. 이를 트랜잭션의 격리성(Isolation)이라고 합니다.",
  "choices" : "1.Log/2.Consistency/3.Isolation/4.Durability/"
}, {
  "question" : "SQL의 논리 연산자가 아닌 것은?",
  "answer" : "2.OTHER",
  "commentary" : "\"OTHER\"는 SQL에서 사용되지 않는 연산자이기 때문에 정답입니다. SQL에서는 다른 논리 연산자인 \"AND\", \"OR\", \"NOT\"을 사용하여 쿼리를 작성합니다.",
  "choices" : "1.AND/2.OTHER/3.OR/4.NOT/"
}, {
  "question" : "동시성 제어를 위한 직렬화 기법으로 트랜잭션 간의 처리 순서를 미리 정하는 방법은?",
  "answer" : "2.타임스탬프 기법",
  "commentary" : "타임스탬프 기법은 각 트랜잭션마다 고유한 타임스탬프를 부여하고, 이를 이용하여 트랜잭션 간의 처리 순서를 미리 정하는 방법입니다. 이 방법은 트랜잭션마다 순서를 정해주기 때문에 동시성 제어를 위한 직렬화 기법으로 사용됩니다. 따라서 정답은 \"타임스탬프 기법\"입니다.",
  "choices" : "1.로킹 기법/2.타임스탬프 기법/3.검증 기법/4.배타 로크 기법/"
}, {
  "question" : "이전 단계의 정규형을 만족하면서 후보키를 통하지 않는 조인 종속(JD : Join Dependency) 제거해야 만족하는 정규형은?",
  "answer" : "3.제5정규형",
  "commentary" : "제5정규형은 모든 조인 종속을 제거하여 만족하는 정규형이다. 이는 후보키를 통하지 않는 조인 종속까지 모두 제거하므로, 이전 단계의 정규형을 만족하면서 후보키를 통하지 않는 조인 종속을 제거하는 것이 목표인 이 문제에 적합하다. 따라서 정답은 \"제5정규형\"이다.",
  "choices" : "1.제3정규형/2.제4정규형/3.제5정규형/4.제6정규형/"
}, {
  "question" : "어떤 릴레이션 R에서 X와 Y를 각각 R의 애트리뷰트 집합의 부분 집합이라고 할 경우 애트리뷰트 X의 값 각각에 대해 시간에 관계없이 항상 애트리뷰트 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수 종속이라고 한다. 이 함수 종속의 표기로 옳은 것은?",
  "answer" : "3.X → Y",
  "commentary" : "정답은 \"X → Y\"이다. 이유는 X가 주어졌을 때 Y의 값이 항상 유일하게 결정되기 때문이다. 즉, X의 값이 변하면 Y의 값도 변할 수 있지만, Y의 값이 변하면 X의 값은 변하지 않는다. 따라서 X가 Y에 함수적으로 종속되어 있다고 말할 수 있다. 예를 들어, 학생의 성적 정보가 담긴 R에서 학생의 이름 X와 학생의 학번 Y가 있다고 가정해보자. 이때, 학번은 학생의 이름에 함수적으로 종속되어 있다. 즉, 학생의 이름이 주어졌을 때 학번은 항상 유일하게 결정된다. 하지만 학번이 주어졌을 때 학생의 이름은 유일하게 결정되지 않는다. 따라서 이 경우에는 \"Y → X\"가 아닌 \"X → Y\"로 표기한다.",
  "choices" : "1.Y → X/2.Y ⊂ X/3.X → Y/4.X ⊂ Y/"
}, {
  "question" : "모듈 내 구성 요소들이 서로 다른 기능을 같은 시간대에 함께 실행하는 경우의 응집도(Cohesion)는?",
  "answer" : "1.Temporal Cohesion",
  "commentary" : "\"Temporal Cohesion\"은 모듈 내 구성 요소들이 서로 다른 기능을 같은 시간대에 함께 실행하는 경우의 응집도를 의미한다. 즉, 모듈 내의 구성 요소들이 시간적으로 연관되어 있어서 함께 실행되어야 하는 경우를 말한다. 이는 모듈 내의 구성 요소들이 서로 독립적인 기능을 수행하지 않고, 서로 연관된 기능을 수행하는 경우에 해당한다. 예를 들어, 파일을 읽고 쓰는 기능이 함께 실행되는 경우가 Temporal Cohesion에 해당한다.",
  "choices" : "1.Temporal Cohesion/2.Logical Cohesion/3.Coincidental Cohesion/4.Sequential Cohesion/"
}, {
  "question" : "오류 제어에 사용되는 자동반복 요청방식(ARQ)이 아닌 것은?",
  "answer" : "4.Non-Acknowledge ARQ",
  "commentary" : "Non-Acknowledge ARQ는 수신 측에서 패킷을 받았음에도 불구하고 응답을 보내지 않는 방식으로 오류 제어를 수행합니다. 따라서 이 방식은 자동반복 요청방식(ARQ)이 아닙니다. Stop-and-wait ARQ, Go-back-N ARQ, Selective-Repeat ARQ은 모두 자동반복 요청방식(ARQ)입니다.",
  "choices" : "1.Stop-and-wait ARQ/2.Go-back-N ARQ/3.Selective-Repeat ARQ/4.Non-Acknowledge ARQ/"
}, {
  "question" : "다음 파이썬(Python) 프로그램이 실행되었을 때의 결과는?",
  "answer" : "3.66",
  "commentary" : "이 프로그램은 리스트 [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]에서 5의 개수를 세어서 출력하는 것이다. 리스트에서 5는 총 3개이므로, 결과는 3이 된다. 그러나 이 결과를 2배한 후 6을 더하면 12가 되고, 이 값이 리스트 [\"45\", \"55\", \"66\", \"78\"]의 인덱스로 사용되어 \"66\"이 출력된다. 따라서 정답은 \"66\"이 된다.",
  "choices" : "1.45/2.55/3.66/4.78/"
}, {
  "question" : "다음 C언어 프로그램이 실행되었을 때의 결과는?",
  "answer" : "2.nationalter",
  "commentary" : "프로그램은 문자열 \"nationalter\"를 출력한다. 이는 배열 arr[10]에 문자열 \"national\"을 저장하고, strcat 함수를 사용하여 \"ter\"를 추가한 후 출력한 결과이다. 따라서 보기에서 정답은 \"nationalter\"이다.",
  "choices" : "1.nation/2.nationalter/3.alter/4.alternation/"
}, {
  "question" : "JAVA에서 힙(Heap)에 남아있으나 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?",
  "answer" : "2.Garbage Collector",
  "commentary" : "Garbage Collector는 JAVA에서 더 이상 사용되지 않는 객체를 제거해주는 모듈로, Heap에 남아있는 객체 중에서 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어진 객체를 자동으로 제거해줍니다. 따라서 정답은 \"Garbage Collector\"입니다.",
  "choices" : "1.Heap Collector/2.Garbage Collector/3.Memory Collector/4.Variable Collector/"
}, {
  "question" : "다음 C언어 프로그램이 실행되었을 때의 결과는?",
  "answer" : "3.2",
  "commentary" : "프로그램은 배열 arr의 크기를 4로 지정하고, 각각의 인덱스에 0, 1, 2, 3을 할당합니다. 그리고 반복문을 통해 배열의 인덱스를 0부터 3까지 증가시키면서 해당 인덱스의 값을 출력합니다. 따라서 출력 결과는 \"0 1 2 3\"이 됩니다. 이 중에서 정답은 \"2\"입니다.",
  "choices" : "1.0/2.1/3.2/4.3/"
}, {
  "question" : "다음 중 JAVA에서 우선순위가 가장 낮은 연산자는?",
  "answer" : "4.=",
  "commentary" : "JAVA에서 우선순위가 가장 낮은 연산자는 \"=\"입니다. 이는 대입 연산자로, 변수에 값을 할당하는 역할을 합니다. 다른 연산자들은 대입 연산자보다 우선순위가 높기 때문에, 대입 연산자는 가장 마지막에 실행됩니다. 예를 들어, a = b + c는 b와 c를 더한 값을 a에 할당하는 것을 의미합니다. 이때, 덧셈 연산자 \"+\"가 대입 연산자 \"=\"보다 우선순위가 높기 때문에, b와 c를 더한 값이 먼저 계산되고, 그 결과가 a에 할당됩니다.",
  "choices" : "1.--/2.%/3.&/4.=/"
}, {
  "question" : "사용자가 요청한 디스크 입·출력 내용이 다음과 같은 순서로 큐에 들어 있을 때 SSTF 스케쥴링을 사용한 경우의 처리 순서는? (단, 현재 헤드 위치는 53 이고, 제일 안쪽이 1번, 바깥쪽이 200번 트랙이다.)",
  "answer" : "1.53-65-67-37-14-98-122-124-183",
  "commentary" : "SSTF 스케쥴링은 현재 헤드 위치에서 가장 가까운 디스크를 우선적으로 처리하는 방식이다. 따라서, 처음에는 53에서 가장 가까운 65를 처리하고, 그 다음으로는 67을 처리한다. 그 다음으로는 37을 처리하고, 그 다음으로는 14를 처리한다. 이후에는 14에서 가장 가까운 98을 처리하고, 그 다음으로는 122를 처리한다. 그 다음으로는 124를 처리하고, 마지막으로 183을 처리한다. 이렇게 처리하면 디스크 헤드의 이동 거리가 최소화되므로 효율적인 스케쥴링이 된다.",
  "choices" : "1.53-65-67-37-14-98-122-124-183/2.53-98-183-37-122-14-124-65-67/3.53-37-14-65-67-98-122-124-183/4.53-67-65-124-14-122-37-183-98/"
}, {
  "question" : "192.168.1.0/24 네트워크를 FLSM 방식을 이용하여 4개의 Subnet으로 나누고 IP Subnet-zero를 적용했다. 이 때 Subnetting 된 네트워크 중 4번째 네트워크의 4번째 사용가능한 IP는 무엇인가?",
  "answer" : "3.192.168.1.196",
  "commentary" : "FLSM 방식을 이용하여 4개의 Subnet으로 나누었으므로, 2비트를 Subnet ID로 사용하고, 6비트를 호스트 ID로 사용한다. 따라서, 각 Subnet은 64개의 호스트를 가질 수 있다. Subnet 1: 192.168.1.0/26 (Subnet ID: 192.168.1.0, Broadcast: 192.168.1.63) Subnet 2: 192.168.1.64/26 (Subnet ID: 192.168.1.64, Broadcast: 192.168.1.127) Subnet 3: 192.168.1.128/26 (Subnet ID: 192.168.1.128, Broadcast: 192.168.1.191) Subnet 4: 192.168.1.192/26 (Subnet ID: 192.168.1.192, Broadcast: 192.168.1.255) 4번째 Subnet의 첫번째 호스트 IP는 192.168.1.193이고, 네번째 호스트 IP는 192.168.1.196이다. 따라서, 정답은 \"192.168.1.196\"이다.",
  "choices" : "1.192.168.1.192/2.192.168.1.195/3.192.168.1.196/4.192.168.1.198/"
}, {
  "question" : "C Class에 속하는 IP address는?",
  "answer" : "1.200.168.30.1",
  "commentary" : "C Class에 속하는 IP address는 첫 번째 옥텟이 192~223인 주소이다. 따라서 \"200.168.30.1\"은 C Class에 속하는 IP address이다.",
  "choices" : "1.200.168.30.1/2.10.3.2.1 4/3.225.2.4.1/4.172.16.98.3/"
}, {
  "question" : "다음 C언어 프로그램이 실행되었을 때의 결과는?",
  "answer" : "3.8",
  "commentary" : "프로그램은 0부터 3까지의 인덱스를 가진 배열 arr을 선언하고, 각 인덱스에 4를 곱한 값을 할당한다. 따라서 arr[0]은 0*4=0, arr[1]은 1*4=4, arr[2]는 2*4=8, arr[3]은 3*4=12가 된다. 그리고 arr[2]의 값을 출력하므로 결과는 8이 된다.",
  "choices" : "1.0/2.4/3.8/4.12/"
}, {
  "question" : "귀도 반 로섬(Guido van Rossum)이 발표한 언어로 인터프리터 방식이자 객체지향적이며, 배우기 쉽고 이식성이 좋은 것이 특징인 스크립트 언어는?",
  "answer" : "4.Python",
  "commentary" : "Python은 귀도 반 로섬(Guido van Rossum)이 개발한 스크립트 언어로, 인터프리터 방식이며 객체지향적이고 배우기 쉽고 이식성이 좋은 특징을 가지고 있습니다. 따라서 이 문제에서 정답은 Python입니다.",
  "choices" : "1.C++/2.JAVA/3.C#/4.Python/"
}, {
  "question" : "다음 JAVA 프로그램이 실행되었을 때의 결과를 쓰시오.",
  "answer" : "3.34",
  "commentary" : "이유는 fibonacci(9)를 호출하면서 fibonacci(8)과 fibonacci(7)을 호출하게 되는데, 이때 fibonacci(8)을 호출하면서 fibonacci(7)과 fibonacci(6)을 호출하게 된다. 이런식으로 계속해서 호출하다가 fibonacci(1)과 fibonacci(2)를 호출하면 각각 1을 반환하고, 이를 이용하여 fibonacci(3)부터 fibonacci(9)까지의 값을 계산하게 된다. 따라서 fibonacci(9)의 값은 34이 되고, 이 값이 출력되게 된다.",
  "choices" : "1.13/2.21/3.34/4.55/"
}, {
  "question" : "프로세스와 관련한 설명으로 틀린 것은?",
  "answer" : "4.프로세스는 스레드(Thread) 내에서 실행되는 흐름의 단위이며, 스레드와 달리 주소 공간에 실행 스택(Stack)이 없다.",
  "commentary" : "프로세스는 스레드(Thread) 내에서 실행되는 흐름의 단위이며, 스레드와 달리 주소 공간에 실행 스택(Stack)이 없다. 이 설명이 틀린 것이다. 프로세스는 스레드와 달리 각각 독립된 주소 공간을 가지며, 각각의 주소 공간에는 실행 스택(Stack)이 존재한다.",
  "choices" : "1.프로세스가 준비 상태에서 프로세서가 배당되어 실행 상태로 변화하는 것을 디스패치(Dispatch)라고 한다./2.프로세스 제어 블록(PCB, Process Control Block)은 프로세스 식별자, 프로세스 상태 등의 정보로 구성된다./3.이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하는 과정을 문맥 교환(Context Switching)이라고 한다./4.프로세스는 스레드(Thread) 내에서 실행되는 흐름의 단위이며, 스레드와 달리 주소 공간에 실행 스택(Stack)이 없다./"
}, {
  "question" : "모듈의 독립성을 높이기 위한 결합도(Coupling)와 관련한 설명으로 틀린 것은?",
  "answer" : "3.모듈들이 변수를 공유하여 사용하게 하거나 제어 정보를 교류하게 함으로써 결합도를 낮추어야 한다.",
  "commentary" : "\"모듈들이 변수를 공유하여 사용하게 하거나 제어 정보를 교류하게 함으로써 결합도를 낮추어야 한다.\"는 오히려 결합도를 높이는 방법이므로 틀린 설명입니다. 모듈들이 공유하는 변수나 제어 정보가 많을수록 모듈 간의 의존도가 높아지고, 오류 발생 시 전파되어 다른 모듈에 영향을 미치는 파문 효과가 커집니다. 따라서 모듈 간의 데이터 교류는 최소화하고, 필요한 경우에는 매개변수를 사용하는 것이 좋습니다.",
  "choices" : "1.오류가 발생했을 때 전파되어 다른 오류의 원인이 되는 파문 효과(Ripple Effect)를 최소화해야 한다./2.인터페이스가 정확히 설정되어 있지 않을 경우 불필요한 인터페이스가 나타나 모듈 사이의 의존도는 높아지고 결합도가 증가한다./3.모듈들이 변수를 공유하여 사용하게 하거나 제어 정보를 교류하게 함으로써 결합도를 낮추어야 한다./4.다른 모듈과 데이터 교류가 필요한 경우 전역변수(Global Variable)보다는 매개변수(Parameter)를 사용하는 것이 결합도를 낮추는 데 도움이 된다./"
}, {
  "question" : "TCP헤더와 관련한 설명으로 틀린 것은?",
  "answer" : "4.윈도우 크기는 송수신 측의 버퍼 크기로 최대크기는 32767bit 이다.",
  "commentary" : "윈도우 크기는 송수신 측의 버퍼 크기로 최대크기는 32767bit 이라는 설명이 틀립니다. 실제로는 최대크기가 65535bit입니다. 순서번호는 전달하는 바이트마다 번호가 부여되어 데이터의 순서를 유지합니다. 수신번호확인은 상대편 호스트에서 받으려는 바이트의 번호를 정의하여 데이터의 손실 여부를 확인합니다. 체크섬은 데이터를 포함한 세그먼트의 오류를 검사하여 데이터의 무결성을 보장합니다. 윈도우 크기는 송수신 측의 버퍼 크기를 나타내며, 데이터의 흐름 제어를 위해 사용됩니다.",
  "choices" : "1.순서번호(Sequence Number)는 전달하는 바이트마다 번호가 부여된다./2.수신번호확인(Acknowledgement Number)은 상대편 호스트에서 받으려는 바이트의 번호를 정의한다./3.체크섬(Checksum)은 데이터를 포함한 세그먼트의 오류를 검사한다./4.윈도우 크기는 송수신 측의 버퍼 크기로 최대크기는 32767bit 이다./"
}, {
  "question" : "모듈화(Modularity)와 관련한 설명으로 틀린 것은?",
  "answer" : "2.모듈의 수가 증가하면 상대적으로 각 모듈의 크기가 커지며, 모듈 사이의 상호교류가 감소하여 과부하(Overload) 현상이 나타난다.",
  "commentary" : "모듈의 수가 증가하면 상대적으로 각 모듈의 크기가 커지며, 모듈 사이의 상호교류가 감소하여 과부하(Overload) 현상이 나타난다. - 이 설명이 틀린 것이다. 모듈의 수가 증가하면 상대적으로 각 모듈의 크기가 작아지며, 모듈 사이의 상호교류가 증가하여 유지보수와 수정이 용이해진다.",
  "choices" : "1.소프트웨어의 모듈은 프로그래밍 언어에서 Subroutine, Function 등으로 표현될 수 있다./2.모듈의 수가 증가하면 상대적으로 각 모듈의 크기가 커지며, 모듈 사이의 상호교류가 감소하여 과부하(Overload) 현상이 나타난다./3.모듈화는 시스템을 지능적으로 관리할 수 있도록 해주며, 복잡도 문제를 해결하는 데 도움을 준다./4.모듈화는 시스템의 유지보수와 수정을 용이하게 한다./"
}, {
  "question" : "다음 중 페이지 교체(Page Replacement)알고리즘이 아닌 것은?",
  "answer" : "2.LUF(Least Used First)",
  "commentary" : "LUF(Least Used First)는 페이지 교체 알고리즘이 아닙니다. LUF는 캐시 교체 알고리즘으로, 가장 적게 사용된 캐시 라인을 교체하는 방식입니다. 페이지 교체 알고리즘은 FIFO, Optimal, LRU 등이 있습니다.",
  "choices" : "1.FIFO(First-In-First-Out)/2.LUF(Least Used First)/3.Optimal/4.LRU(Least Recently Used)/"
}, {
  "question" : "C언어에서의 변수 선언으로 틀린 것은?",
  "answer" : "1.int else;",
  "commentary" : "정답은 \"int else;\"이다. 이유는 \"else\"는 C언어에서 예약어(reserved word)로 사용되기 때문에 변수명으로 사용할 수 없다. 따라서 \"int else;\"는 올바른 변수 선언이 아니다.",
  "choices" : "1.int else;/2.int Test2;/3.int pc;/4.int True;/"
}, {
  "question" : "파일 디스크립터(File Descriptor)에 대한 설명으로 틀린 것은?",
  "answer" : "3.사용자가 파일 디스크립터를 직접 참조할 수 있다.",
  "commentary" : "정답은 \"사용자가 파일 디스크립터를 직접 참조할 수 있다.\"이다. 파일 디스크립터는 시스템 내부에서 파일을 관리하기 위해 사용되는 추상화된 개념으로, 사용자는 파일 디스크립터를 직접적으로 참조할 수 없다. 파일 디스크립터는 파일을 열고 닫는 등의 작업을 수행할 때 시스템 호출 함수를 통해 사용되며, 이 함수들은 파일 디스크립터를 반환한다.",
  "choices" : "1.파일 관리를 위해 시스템이 필요로 하는 정보를 가지고 있다./2.보조기억장치에 저장되어 있다가 파일이 개방(open)되면 주기억장치로 이동된다./3.사용자가 파일 디스크립터를 직접 참조할 수 있다./4.파일 제어 블록(File Control Block)이라고도 한다./"
}, {
  "question" : "침입탐지 시스템(IDS : Intrusion Detection System)과 관련한 설명으로 틀린 것은?",
  "answer" : "1.이상 탐지 기법(Anomaly Detection)은 Signature Base나 Knowledge Base라고도 불리며 이미 발견되고 정립된 공격 패턴을 입력해두었다가 탐지 및 차단한다.",
  "commentary" : "이상 탐지 기법은 이미 발견되지 않은 새로운 공격 패턴을 탐지하기 위해 사용되며, Signature Base나 Knowledge Base와는 다른 방식으로 동작한다. 이상 탐지 기법은 정상적인 네트워크 트래픽 패턴을 학습하고, 이와 다른 패턴을 감지하여 이상을 탐지한다. 따라서 \"이상 탐지 기법(Anomaly Detection)은 Signature Base나 Knowledge Base라고도 불리며 이미 발견되고 정립된 공격 패턴을 입력해두었다가 탐지 및 차단한다.\"는 틀린 설명이다.",
  "choices" : "1.이상 탐지 기법(Anomaly Detection)은 Signature Base나 Knowledge Base라고도 불리며 이미 발견되고 정립된 공격 패턴을 입력해두었다가 탐지 및 차단한다./2.HIDS(Host-Based Intrusion Detection)는 운영체제에 설정된 사용자 계정에 따라 어떤 사용자가 어떤 접근을 시도하고 어떤 작업을 했는지에 대한 기록을 남기고 추적한다./3.NIDS(Network-Based Intrusion Detection System)로는 대표적으로 Snort가 있다./4.외부 인터넷에 서비스를 제공하는 서버가 위치하는 네트워크인 DMZ(Demilitarized Zone)에는 IDS가 설치될 수 있다./"
}, {
  "question" : "정보 시스템 내에서 어떤 주체가 특정 개체에 접근하려 할 때 양쪽의 보안 레이블(Security Label)에 기초하여 높은 보안 수준을 요구하는 정보(객체)가 낮은 보안 수준의 주체에게 노출되지 않도록 하는 접근 제어 방법은?",
  "answer" : "1.Mandatory Access Control",
  "commentary" : "정보 시스템 내에서 접근 제어를 위해 사용되는 방법 중 \"Mandatory Access Control\"은 보안 레이블에 기초하여 접근 권한을 부여하는 방법입니다. 이 방법은 주체와 객체의 보안 레이블을 비교하여, 주체가 객체에 접근할 수 있는지 여부를 결정합니다. 이때, 주체의 보안 레이블이 객체의 보안 레이블보다 높은 경우에만 접근이 허용되며, 그렇지 않은 경우에는 접근이 거부됩니다. 이러한 방식으로 높은 보안 수준을 요구하는 정보가 낮은 보안 수준의 주체에게 노출되지 않도록 보호할 수 있습니다.",
  "choices" : "1.Mandatory Access Control/2.User Access Control/3.Discretionary Access Control/4.Data-Label Access Control/"
}, {
  "question" : "구글의 구글 브레인 팀이 제작하여 공개한 기계 학습(Machine Leaming)을 위한 오픈소스 소프트웨어 라이브러리는?",
  "answer" : "4.텐서플로(TensorFlow)",
  "commentary" : "구글 브레인 팀이 제작한 기계 학습을 위한 오픈소스 소프트웨어 라이브러리인 텐서플로는 다양한 기능과 높은 성능을 제공하며, 다양한 플랫폼에서 사용이 가능하고 커뮤니티에서 지속적인 업데이트와 개선이 이루어지고 있기 때문에 선택할 수 있는 가장 좋은 옵션 중 하나이다.",
  "choices" : "1.타조(Tajo)/2.원 세그(One Seg)/3.포스퀘어(Foursquare)/4.텐서플로(TensorFlow)/"
}, {
  "question" : "국내 IT 서비스 경쟁력 강화를 목표로 개발되었으며 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼은?",
  "answer" : "2.PaaS-TA",
  "commentary" : "PaaS-TA는 Platform as a Service-Total Automation으로, 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영환경 등 다양한 환경을 제공하여 개발자들이 쉽게 애플리케이션을 개발하고 배포할 수 있도록 도와주는 개방형 클라우드 컴퓨팅 플랫폼입니다. 따라서 국내 IT 서비스 경쟁력 강화를 위해 개발된 이 플랫폼이 정답입니다.",
  "choices" : "1.N20S/2.PaaS-TA/3.KAWS/4.Metaverse/"
}, {
  "question" : "정보 보안을 위한 접근 제어(Access Control)과 관련한 설명으로 틀린 것은?",
  "answer" : "3.DBMS에 보안 정책을 적용하는 도구인 XDMCP를 통해 데이터베이스에 대한 접근제어를 수행할 수 있다.",
  "commentary" : "\"DBMS에 보안 정책을 적용하는 도구인 XDMCP를 통해 데이터베이스에 대한 접근제어를 수행할 수 있다.\"가 틀린 설명입니다. XDMCP는 X 윈도 시스템에서 사용되는 원격 디스플레이 프로토콜로, DBMS에 대한 접근 제어와는 직접적인 연관성이 없습니다. DBMS에 대한 접근 제어는 DBMS 자체에서 제공하는 인증 및 권한 관리 기능을 사용하여 수행됩니다.",
  "choices" : "1.적절한 권한을 가진 인가자만 특정 시스템이나 정보에 접근할 수 있도록 통제하는 것이다./2.시스템 및 네트워크에 대한 접근 제어의 가장 기본적인 수단은 IP와 서비스 포트로 볼 수 있다./3.DBMS에 보안 정책을 적용하는 도구인 XDMCP를 통해 데이터베이스에 대한 접근제어를 수행할 수 있다./4.네트워크 장비에서 수행하는 IP에 대한 접근 제어로는 관리 인터페이스의 접근제어와 ACL(Access Control List) 등 있다./"
}, {
  "question" : "소프트웨어 개발 프레임워크와 관련한 설명으로 틀린 것은?",
  "answer" : "3.라이브러리와 달리 사용자 코드가 직접호출하여 사용하기 때문에 소프트웨어 개발프레임워크가 직접 코드의 흐름을 제어할수 없다.",
  "commentary" : "\"라이브러리와 달리 사용자 코드가 직접호출하여 사용하기 때문에 소프트웨어 개발프레임워크가 직접 코드의 흐름을 제어할수 없다.\"이 설명이 틀린 것이다. 소프트웨어 개발 프레임워크는 사용자 코드를 호출하고 제어할 수 있다. 이것이 바로 프레임워크의 핵심 기능 중 하나이다. 프레임워크는 사용자 코드를 호출하고 제어하여 일관된 동작을 보장하고, 개발자가 코드를 작성하는 방법을 지정하여 일관성을 유지할 수 있도록 도와준다.",
  "choices" : "1.반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장 받을 수 있게하는 개발 소프트웨어이다./2.개발해야 할 애플리케이션의 일부분이 이미구현되어 있어 동일한 로직 반복을 줄일 수있다./3.라이브러리와 달리 사용자 코드가 직접호출하여 사용하기 때문에 소프트웨어 개발프레임워크가 직접 코드의 흐름을 제어할수 없다./4.생산성 향상과 유지보수성 향상 등의장점이 있다./"
}, {
  "question" : "물리적 배치와 상관없이 논리적으로 LAN을구성하여 Broadcast Domain을 구분할 수있게 해주는 기술로 접속된 장비들의 성능향상 및 보안성 증대 효과가 있는 것은?",
  "answer" : "1.VLAN",
  "commentary" : "VLAN은 가상 LAN을 구성하여 물리적 배치와 상관없이 논리적으로 네트워크를 분할하는 기술이다. 이를 통해 Broadcast Domain을 구분할 수 있어서 네트워크 성능 향상과 보안성 증대 효과가 있다.",
  "choices" : "1.VLAN/2.STP/3.L2AN/4.ARP/"
}, {
  "question" : "SQL Injection 공격과 관련한 설명으로 틀린것은?",
  "answer" : "3.DBMS의 종류와 관계없이 SQL Injection공격 기법은 모두 동일하다.",
  "commentary" : "\"DBMS의 종류와 관계없이 SQL Injection공격 기법은 모두 동일하다.\"라는 설명이 틀립니다. 각 DBMS마다 SQL 구문의 문법과 기능이 다르기 때문에, SQL Injection 공격 기법도 DBMS마다 차이가 있을 수 있습니다. 예를 들어, MySQL과 Oracle에서 사용되는 SQL 구문의 문법이 다르기 때문에, SQL Injection 공격 기법도 각각 다를 수 있습니다.",
  "choices" : "1.SQL Injection은 임의로 작성한 SQL 구문을 애플리케이션에 삽입하는 공격방식이다./2.SQL Injection 취약점이 발생하는 곳은 주로웹 애플리케이션과 데이터베이스가 연동되는 부분이다./3.DBMS의 종류와 관계없이 SQL Injection공격 기법은 모두 동일하다./4.로그인과 같이 웹에서 사용자의 입력 값을 받아 데이터베이스 SQL문으로 데이터를요청하는 경우 SQL Injection을 수행할 수 있다./"
}, {
  "question" : "비대칭 암호화 방식으로 소수를 활용한암호화 알고리즘은?",
  "answer" : "4.RSA",
  "commentary" : "RSA는 공개키 암호화 방식으로, 소수를 이용하여 암호화와 복호화를 수행합니다. 이 알고리즘은 두 개의 소수를 곱한 값을 이용하여 암호화를 수행하며, 이 소수를 알고 있어야만 복호화가 가능합니다. 이러한 소수의 특성을 이용하여 안전하고 효율적인 암호화를 수행할 수 있습니다.",
  "choices" : "1.DES/2.AES/3.SMT/4.RSA/"
}, {
  "question" : "다음에서 설명하는 IT 스토리지 기술은?",
  "answer" : "1.Software Defined Storage",
  "commentary" : "위 그림에서 보이는 IT 스토리지 기술은 \"Software Defined Storage\"이다. 이는 소프트웨어를 이용하여 스토리지를 관리하고 제어하는 기술로, 하드웨어와는 독립적으로 동작하며 가상화 기술을 활용하여 스토리지 자원을 효율적으로 관리할 수 있다. 따라서 유연성과 확장성이 뛰어나며, 비용 효율적인 스토리지 관리가 가능하다.",
  "choices" : "1.Software Defined Storage/2.Distribution Oriented Storage/3.Network Architected Storage/4.Systematic Network Storage/"
}, {
  "question" : "Cocomo model 중 기관 내부에서 개발된 중소규모의 소프트웨어로 일괄 자료 처리나 과학기술계산용, 비즈니스 자료 처리용으로 5만 라인이하의 소프트웨어를 개발하는 유형은?",
  "answer" : "2.Organic",
  "commentary" : "Organic 모델은 기관 내부에서 개발된 중소규모의 소프트웨어로 일괄 자료 처리나 과학기술계산용, 비즈니스 자료 처리용으로 5만 라인이하의 소프트웨어를 개발하는 유형이다. 이 모델은 작은 규모의 프로젝트이기 때문에 개발자들 간의 의사소통이 원활하고, 개발 환경이 안정적이며, 기술적인 복잡도가 낮아 개발 비용이 적게 든다는 특징이 있다. 따라서 이 유형은 Organic 모델에 해당한다.",
  "choices" : "1.Embeded/2.Organic/3.Semi-detached/4.Semi-embeded/"
}, {
  "question" : "다음 내용이 설명하는 것은?",
  "answer" : "2.Ransomware",
  "commentary" : "이 그림은 Ransomware를 설명하고 있습니다. Ransomware는 악성코드 중 하나로, 사용자의 파일을 암호화하고 복원을 위해 금전적 보상을 요구하는 악성 소프트웨어입니다. 이 그림에서는 \"Your files have been encrypted\"이라는 메시지와 함께 금전적 보상을 요구하는 모습이 그려져 있습니다.",
  "choices" : "1.Format String/2.Ransomware/3.Buffer overflow/4.Adware/"
}, {
  "question" : "생명주기 모형 중 가장 오래된 모형으로 많은적용 사례가 있지만 요구사항의 변경이어렵고 각 단계의 결과가 확인 되어야 다음단계로 넘어갈 수 있는 선형 순차적, 고전적생명 주기 모형이라고도 하는 것은?",
  "answer" : "1.Waterfall Model",
  "commentary" : "Waterfall Model은 각 단계가 선형적으로 진행되어야 하며, 이전 단계의 결과물이 다음 단계의 입력으로 사용되는 모델이다. 따라서 요구사항이 변경되면 이전 단계를 다시 수행해야 하므로 변경이 어렵다. 또한 각 단계의 결과물이 확인되어야 다음 단계로 넘어갈 수 있기 때문에 개발 속도가 느리다는 단점이 있다. 이러한 특징으로 인해 Waterfall Model은 고전적 생명주기 모형이라고도 불린다.",
  "choices" : "1.Waterfall Model/2.Prototype Model/3.Cocomo Model/4.Spiral Model/"
}, {
  "question" : "소프트웨어 생명주기 모형 중 Spiral Model에 대한 설명으로 틀린 것은?",
  "answer" : "4.계획, 설계, 개발, 평가의 개발 주기가 한번만 수행된다.",
  "commentary" : "\"계획, 설계, 개발, 평가의 개발 주기가 한번만 수행된다.\"는 틀린 설명입니다. Spiral Model은 계속해서 주기적으로 개발 주기를 수행하며, 위험 분석과 평가를 통해 개발 과정을 개선하는 것이 목적입니다. 따라서, 계획, 설계, 개발, 평가의 개발 주기가 여러 번 수행됩니다.",
  "choices" : "1.비교적 대규모 시스템에 적합하다./2.개발 순서는 계획 및 정의, 위험 분석, 공학적 개발, 고객 평가 순으로 진행된다./3.소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 한다./4.계획, 설계, 개발, 평가의 개발 주기가 한번만 수행된다./"
}, {
  "question" : "특정 사이트에 매우 많은 ICMP Echo를 보내면, 이에 대한 응답(Respond)을 하기 위해 시스템 자원을 모두 사용해버려 시스템이 정상적으로 동작하지 못하도록 하는 공격방법은?",
  "answer" : "2.Ping Flood",
  "commentary" : "Ping Flood는 대량의 ICMP Echo를 보내 시스템 자원을 고갈시켜 시스템이 정상적으로 동작하지 못하도록 하는 공격방법이다. 따라서 이 문제에서 정답은 Ping Flood이다.",
  "choices" : "1.Role-Based Access Control/2.Ping Flood/3.Brute-Force/4.Trojan Horses/"
}, {
  "question" : "TCP/IP 기반 네트워크에서 동작하는 발행-구독 기반의 메시징 프로토콜로 최근 IoT 환경에서 자주 사용되고 있는 프로토콜은?",
  "answer" : "2.MQTT",
  "commentary" : "MQTT는 경량 메시징 프로토콜로, IoT 디바이스와 서버 간의 효율적인 통신을 가능하게 합니다. TCP/IP 기반의 네트워크에서 동작하며, 발행-구독 모델을 사용하여 메시지를 전송합니다. 이를 통해 IoT 디바이스에서 발생하는 대량의 데이터를 효율적으로 처리할 수 있습니다.",
  "choices" : "1.MLFQ/2.MQTT/3.Zigbee/4.MTSP/"
}, {
  "question" : "시스템이 몇 대가 되어도 하나의 시스템에서 인증에 성공하면 다른 시스템에 대한 접근권한도 얻는 시스템을 의미하는 것은?",
  "answer" : "3.SSO",
  "commentary" : "SSO는 Single Sign-On의 약자로, 한 번의 로그인으로 여러 시스템에 접근할 수 있는 시스템을 의미합니다. 따라서 시스템이 몇 대가 되어도 인증에 성공하면 다른 시스템에 대한 접근권한도 얻을 수 있습니다. SOS, SBO, SOA는 SSO와는 다른 시스템이므로 정답은 SSO입니다.",
  "choices" : "1.SOS/2.SBO/3.SSO/4.SOA/"
}, {
  "question" : "시스템에 저장되는 패스워드들은 Hash 또는 암호화 알고리즘의 결과 값으로 저장된다. 이때 암호공격을 막기 위해 똑같은 패스워드들이 다른 암호 값으로 저장되도록 추가되는 값을 의미하는 것은?",
  "answer" : "4.Salt",
  "commentary" : "Salt는 암호화 알고리즘에 추가되는 임의의 값으로, 같은 패스워드라도 다른 Salt 값을 사용하면 다른 암호 값으로 저장되어 암호 공격을 어렵게 만든다. 따라서 Salt가 정답이다.",
  "choices" : "1.Pass flag/2.Bucket/3.Opcode/4.Salt/"
}, {
  "question" : "S/W 각 기능의 원시 코드 라인수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?",
  "answer" : "4.LOC기법",
  "commentary" : "원시 코드 라인수를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은 LOC기법이다. 이는 소프트웨어 개발의 기본 단위인 코드 라인수를 측정하여 개발에 필요한 시간과 비용을 예측하는 방법으로, 비관치, 낙관치, 기대치를 고려하여 예측치를 도출한다. 이 방법은 비교적 간단하고 직관적이며, 개발자들이 코드 라인수를 쉽게 파악할 수 있기 때문에 널리 사용되고 있다.",
  "choices" : "1.Effort Per Task기법/2.전문가 감정 기법/3.델파이기법/4.LOC기법/"
}, {
  "question" : "오픈소스 웹 애플리케이션 보안 프로젝트로서 주로 웹을 통한 정보 유출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하는 곳은?",
  "answer" : "2.OWASP",
  "commentary" : "OWASP는 Open Web Application Security Project의 약자로, 오픈소스 웹 애플리케이션 보안 프로젝트를 주도하는 단체이다. OWASP는 웹을 통한 정보 유출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하고 이를 해결하기 위한 가이드라인과 도구를 제공한다. 따라서 OWASP는 웹 보안 분야에서 국제적으로 인정받는 단체 중 하나이다.",
  "choices" : "1.WWW/2.OWASP/3.WBSEC/4.ITU/"
}, {
  "question" : "시스템의 구성요소로 볼 수 없는 것은?",
  "answer" : "3.Maintenance",
  "commentary" : "유지보수는 시스템의 운영과는 별개로 시스템을 유지하고 개선하기 위한 활동이므로 시스템의 구성요소로 볼 수 없습니다. 따라서 정답은 \"Maintenance\"입니다.",
  "choices" : "1.Process/2.Feedback/3.Maintenance/4.Control/"
}, {
  "question" : "유스케이스(Usecase)에 대한 설명 중 옳은 것은?",
  "answer" : "2.액터는 대상 시스템과 상호 작용하는 사람이나 다른 시스템에 의한 역할이다.",
  "commentary" : "정답은 \"액터는 대상 시스템과 상호 작용하는 사람이나 다른 시스템에 의한 역할이다.\"이다. 이유는 액터는 유스케이스 다이어그램에서 시스템과 상호작용하는 대상을 나타내는데, 이 대상은 사람이나 다른 시스템일 수 있다. 따라서 액터는 시스템과 상호작용하는 역할을 하는 대상을 의미한다. 다른 보기들은 유스케이스 다이어그램과 관련된 내용이지만, 정확한 설명이 아니므로 오답이다.",
  "choices" : "1.유스케이스 다이어그램은 개발자의 요구를 추출하고 분석하기 위해 주로 사용한다./2.액터는 대상 시스템과 상호 작용하는 사람이나 다른 시스템에 의한 역할이다./3.사용자 액터는 본 시스템과 데이터를 주고받는 연동 시스템을 의미한다./4.연동의 개념은 일방적으로 데이터를 파일이나 정해진 형식으로 넘겨주는 것을 의미한다./"
}, {
  "question" : "요구사항 개발 프로세스의 순서로 옳은 것은?",
  "answer" : "1.㉠ - ㉡ - ㉢ - ㉣",
  "commentary" : "요구사항 개발 프로세스의 순서는 다음과 같다. 1. 요구사항 수집 (㉠) 2. 요구사항 분석 (㉡) 3. 요구사항 명세 (㉢) 4. 요구사항 검증 (㉣) 이 중에서도 요구사항 수집이 가장 먼저 이루어져야 한다. 이유는 요구사항 수집이 제대로 이루어지지 않으면 이후의 분석, 명세, 검증 과정에서 문제가 발생할 수 있기 때문이다. 따라서 정답은 \"㉠ - ㉡ - ㉢ - ㉣\"이다.",
  "choices" : "1.㉠ - ㉡ - ㉢ - ㉣/2.㉠ - ㉢ - ㉡ - ㉣/3.㉠ - ㉣ - ㉡ - ㉢/4.㉠ - ㉡ - ㉣ - ㉢/"
}, {
  "question" : "객체지향 기법에서 같은 클래스에 속한 각각의 객체를 의미하는 것은?",
  "answer" : "1.instance",
  "commentary" : "객체지향 기법에서 같은 클래스에 속한 각각의 객체를 의미하는 것은 \"instance\"이다. 이는 클래스를 기반으로 생성된 개별적인 객체를 의미하며, 각각의 인스턴스는 서로 다른 상태와 행동을 가지고 있다. 예를 들어, 클래스가 \"사람\"이라면, 인스턴스는 \"홍길동\", \"김철수\" 등의 구체적인 사람들을 의미한다.",
  "choices" : "1.instance/2.message/3.method/4.module/"
}, {
  "question" : "객체지향 설계에서 객체가 가지고 있는 속성과 오퍼레이션의 일부를 감추어서 객체의 외부에서는 접근이 불가능하게 하는 개념은? (문제 오류로 가답안 발표시 3번으로 발표되었지만 확정 답안 발표시 2, 3번이 정답처리 되었습니다. 여기서는 가답안인 3번을 누르면 정답 처리 됩니다.)",
  "answer" : "3.정보은닉(Infomation Hiding)",
  "commentary" : "정보은닉은 객체의 내부 구현을 외부에 감추어서 객체의 불필요한 접근을 막고, 객체의 안정성과 보안성을 높이기 위한 개념입니다. 이를 통해 객체의 내부 구현이 변경되더라도 외부에서는 영향을 받지 않고, 객체의 인터페이스만을 통해 상호작용할 수 있습니다. 이는 객체지향 설계의 중요한 원칙 중 하나로, 코드의 유지보수성과 재사용성을 높이는데 큰 역할을 합니다.",
  "choices" : "1.조직화(Organizing)/2.캡슐화(Encapsulation)/3.정보은닉(Infomation Hiding)/4.구조화(Structuralization)/"
}, {
  "question" : "GoF (Gangs of Four) 디자인 패턴에 대한 설명으로 틀린 것은?",
  "answer" : "3.bridge pattern은 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.",
  "commentary" : null,
  "choices" : "1.factory method pattern은 상위클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위클래스에서 인스턴스를 생성하도록 하는 방식이다./2.prototype pattern은 prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다./3.bridge pattern은 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다./4.mediator pattern은 객체간의 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해준다./"
}, {
  "question" : "요구사항 분석이 어려운 이유가 아닌 것은?",
  "answer" : "2.사용자의 요구는 예외가 거의 없어 열거와 구조화가 어렵지 않다.",
  "commentary" : "사용자의 요구는 예외가 거의 없어 열거와 구조화가 어렵지 않다는 것은 사용자가 요구하는 것이 명확하고 구체적이며 예외적인 경우가 드물어 요구사항을 명확하게 정의하고 구조화하기 쉽다는 것을 의미합니다. 따라서 이 경우에는 요구사항 분석이 어렵지 않습니다.",
  "choices" : "1.개발자와 사용자 간의 지식이나 표현의 차이가 커서 상호 이해가 쉽지 않다./2.사용자의 요구는 예외가 거의 없어 열거와 구조화가 어렵지 않다./3.사용자의 요구사항이 모호하고 불명확하다./4.소프트웨어 개발 과정 중에 요구사항이 계속 변할 수 있다./"
}, {
  "question" : "소프트웨어 아키텍처 설계에서 시스템 품질속성이 아닌 것은?",
  "answer" : "2.독립성 (Isolation)",
  "commentary" : "시스템 품질속성 중 독립성은 아키텍처 설계에서 고려되는 속성이 아닙니다. 독립성은 일반적으로 모듈화와 관련이 있으며, 모듈 간의 상호작용을 최소화하여 모듈의 독립성을 높이는 것을 의미합니다. 따라서 시스템 품질속성으로는 고려되지 않습니다.",
  "choices" : "1.가용성 (Availability)/2.독립성 (Isolation)/3.변경 용이성 (Modifiability)/4.사용성(Usability)/"
}, {
  "question" : "다음 설명에 해당하는 시스템으로 옳은 것은?",
  "answer" : "3.송신 시스템",
  "commentary" : "위 그림은 메시지 전송 과정을 나타내는 것으로, 메시지를 보내는 시스템을 \"송신 시스템\"이라고 부릅니다. 이 시스템은 메시지를 작성하고, 연계 서버를 통해 중계 서버로 메시지를 전송하며, 최종적으로 수신 시스템으로 메시지를 전달합니다. 따라서, 정답은 \"송신 시스템\"입니다.",
  "choices" : "1.연계 서버/2.중계 서버/3.송신 시스템/4.수신 시스템/"
}, {
  "question" : "CASE(Computer-Aided Software Engineering)의 원천 기술이 아닌 것은?",
  "answer" : "4.일괄처리 기술",
  "commentary" : "일괄처리 기술은 CASE의 원천 기술이 아닙니다. CASE는 소프트웨어 개발 과정에서 자동화된 도구와 기법을 사용하여 생산성을 높이고 품질을 향상시키는 방법론입니다. 일괄처리 기술은 데이터 처리를 위한 방법으로, CASE와는 관련이 없습니다.",
  "choices" : "1.구조적 기법/2.프로토타이핑 기술/3.정보 저장소 기술/4.일괄처리 기술/"
}, {
  "question" : "객체에게 어떤 행위를 하도록 지시하는 명령은?",
  "answer" : "4.Message",
  "commentary" : "객체에게 어떤 행위를 하도록 지시하는 명령은 \"Message\"이다. 이는 객체 지향 프로그래밍에서 객체 간의 상호작용을 위해 사용되는 개념으로, 객체가 다른 객체에게 메시지를 보내면 해당 객체는 그에 맞는 행동을 취하게 된다. 따라서 객체 간의 상호작용을 위해 필수적인 개념이며, 객체 지향 프로그래밍에서 중요한 역할을 한다.",
  "choices" : "1.Class/2.Package/3.Object/4.Message/"
}, {
  "question" : "서브시스템이 입력 데이터를 받아 처리하고 결과를 다른 시스템에 보내는 작업이 반복되는 아키텍처 스타일은?",
  "answer" : "4.파이프 필터 구조",
  "commentary" : "파이프 필터 구조는 입력 데이터를 여러 개의 필터를 거쳐 처리하고, 그 결과를 다른 시스템에 보내는 작업이 반복되는 아키텍처 스타일입니다. 이 구조에서는 각각의 필터가 입력 데이터를 받아 처리하고, 그 결과를 다음 필터로 전달하는 파이프라인이 형성됩니다. 이러한 구조는 데이터 처리 과정을 단계적으로 분리하여 유지보수와 확장성을 높일 수 있습니다. 따라서, 서브시스템이 입력 데이터를 받아 처리하고 결과를 다른 시스템에 보내는 작업이 반복되는 경우에는 파이프 필터 구조가 적합한 아키텍처 스타일입니다.",
  "choices" : "1.클라이언트 서버 구조/2.계층 구조/3.MVC 구조/4.파이프 필터 구조/"
}, {
  "question" : "럼바우(Rumbaugh)의 객체지향 분석에서 사용하는 분석 활동으로 옳은 것은?",
  "answer" : "2.객체 모델링, 동적 모델링, 기능 모델링",
  "commentary" : "객체 모델링은 시스템 내의 객체들을 식별하고 그들 간의 관계를 파악하는 활동입니다. 동적 모델링은 객체들 간의 상호작용을 분석하고 객체들의 동작을 모델링하는 활동입니다. 기능 모델링은 시스템이 제공하는 기능들을 파악하고 이를 객체들과 연결하여 시스템의 기능을 모델링하는 활동입니다. 따라서 정답은 \"객체 모델링, 동적 모델링, 기능 모델링\"입니다.",
  "choices" : "1.객체 모델링, 동적 모델링, 정적 모델링/2.객체 모델링, 동적 모델링, 기능 모델링/3.동적 모델링, 기능 모델링, 정적 모델링/4.정적 모델링, 객체 모델링, 기능 모델링/"
}, {
  "question" : "UML 다이어그램이 아닌 것은?",
  "answer" : "2.절차 다이어그램(Procedural diagram)",
  "commentary" : "절차 다이어그램은 UML의 공식 다이어그램이 아니며, 프로세스 흐름을 나타내는 다이어그램으로 사용됩니다. 따라서 정답은 \"절차 다이어그램(Procedural diagram)\"입니다.",
  "choices" : "1.액티비티 다이어그램(Activity diagram)/2.절차 다이어그램(Procedural diagram)/3.클래스 다이어그램(Class diagram)/4.시퀀스 다이어그램(Sequence diagram)/"
}, {
  "question" : "UML 모델에서 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계로 옳은 것은?",
  "answer" : "2.Realization",
  "commentary" : "\"Realization\"은 인터페이스를 구현하는 클래스와 같이, 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계입니다. 이 관계는 인터페이스와 구현체 사이의 관계를 나타내며, 인터페이스에서 정의된 메서드를 구현체에서 실제로 구현하여 사용할 수 있도록 합니다. 따라서 \"Realization\"이 정답입니다.",
  "choices" : "1.Dependency/2.Realization/3.Generalization/4.Association/"
}, {
  "question" : "다음 중 상위 CASE 도구가 지원하는 주요기능으로 볼 수 없는 것은?",
  "answer" : "2.전체 소스코드 생성 기능",
  "commentary" : "상위 CASE 도구는 모델링을 위한 도구로, 모델들 사이의 모순검사 기능, 모델의 오류검증 기능, 자료흐름도 작성 기능 등을 지원한다. 하지만 전체 소스코드 생성 기능은 CASE 도구의 주요기능 중 하나가 아니므로 정답은 \"전체 소스코드 생성 기능\"이다.",
  "choices" : "1.모델들 사이의 모순검사 기능/2.전체 소스코드 생성 기능/3.모델의 오류검증 기능/4.자료흐름도 작성 기능/"
}, {
  "question" : "요구사항 관리 도구의 필요성으로 틀린 것은?",
  "answer" : "2.기존 시스템과 신규 시스템의 성능 비교",
  "commentary" : "기존 시스템과 신규 시스템의 성능 비교는 요구사항 관리 도구의 필요성과는 직접적인 연관이 없습니다. 요구사항 관리 도구는 요구사항 변경으로 인한 비용 편익 분석, 요구사항 변경의 추적, 요구사항 변경에 따른 영향 평가 등을 수행하여 프로젝트의 효율성과 품질을 향상시키는 데 필요합니다.",
  "choices" : "1.요구사항 변경으로 인한 비용 편익 분석/2.기존 시스템과 신규 시스템의 성능 비교/3.요구사항 변경의 추적/4.요구사항 변경에 따른 영향 평가/"
}, {
  "question" : "애자일 개발 방법론이 아닌 것은?",
  "answer" : "4.하둡(Hadoop)",
  "commentary" : "하둡은 분산 시스템을 위한 오픈소스 프레임워크로, 애자일 개발 방법론과는 직접적인 연관성이 없습니다. 애자일 개발 방법론은 소프트웨어 개발 프로세스를 빠르고 유연하게 진행하기 위한 방법론으로, 스크럼, 익스트림 프로그래밍, 기능 주도 개발 등이 대표적인 예시입니다.",
  "choices" : "1.스크럼(Scrum)/2.익스트림 프로그래밍(XP, eXtreme Programming)/3.기능 주도 개발(FDD, Feature Driven Development)/4.하둡(Hadoop)/"
}, {
  "question" : "GoF(Gangs of Four) 디자인 패턴 중 생성패턴으로 옳은 것은?",
  "answer" : "1.singleton pattern",
  "commentary" : "정답은 \"singleton pattern\"입니다. Singleton pattern은 객체를 하나만 생성하도록 보장하는 패턴입니다. 이는 전역 변수를 사용하지 않고, 객체를 생성할 때마다 새로운 객체를 생성하는 것이 아니라, 이미 생성된 객체를 반환하여 메모리를 절약할 수 있습니다. 이 패턴은 많은 경우에 유용하며, 예를 들어 데이터베이스 연결, 로그 파일 등에서 사용됩니다.",
  "choices" : "1.singleton pattern/2.adapter pattern/3.decorator pattern/4.state pattern/"
}, {
  "question" : "사용자 인터페이스(UI)의 특징으로 틀린 것은?",
  "answer" : "2.사용자의 편의성을 높임으로써 작업시간을 증가시킨다.",
  "commentary" : "\"사용자의 편의성을 높임으로써 작업시간을 증가시킨다.\"는 틀린 설명입니다. 올바른 설명은 \"사용자의 편의성을 높임으로써 작업시간을 감소시킨다.\"입니다. UI는 사용자가 소프트웨어를 사용하는 과정에서 편리하고 쉽게 작업할 수 있도록 설계되어야 합니다. 이를 통해 사용자는 빠르고 정확하게 작업을 수행할 수 있으며, 작업 시간을 단축시킬 수 있습니다. 따라서 UI는 사용자의 편의성을 높이는 것이 중요합니다.",
  "choices" : "1.구현하고자 하는 결과의 오류를 최소화한다./2.사용자의 편의성을 높임으로써 작업시간을 증가시킨다./3.막연한 작업 기능에 대해 구체적인 방법을 제시하여 준다./4.사용자 중심의 상호 작용이 되도록 한다./"
}, {
  "question" : "힙 정렬(Heap Sort)에 대한 설명으로 틀린것은?",
  "answer" : "4.최악의 수행 시간은 O(2n4)이다.",
  "commentary" : null,
  "choices" : "1.정렬할 입력 레코드들로 힙을 구성하고 가장 큰 키 값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법이다./2.평균 수행 시간은 O(nlog2n)이다./3.완전 이진트리(complete binary tree)로 입력자료의 레코드를 구성한다./4.최악의 수행 시간은 O(2n4)이다./"
}, {
  "question" : "다음 중 단위 테스트를 통해 발견할 수 있는 오류가 아닌 것은?",
  "answer" : "3.모듈 간의 비정상적 상호작용으로 인한 원치 않는 결과",
  "commentary" : "모듈 간의 비정상적 상호작용으로 인한 원치 않는 결과는 단위 테스트로 발견하기 어려운 오류입니다. 이는 여러 모듈이 상호작용하면서 발생하는 문제로, 단일 모듈의 테스트로는 발견하기 어렵습니다. 따라서 이러한 문제는 통합 테스트나 시스템 테스트에서 발견될 가능성이 높습니다.",
  "choices" : "1.알고리즘 오류에 따른 원치 않는 결과/2.탈출구가 없는 반복문의 사용/3.모듈 간의 비정상적 상호작용으로 인한 원치 않는 결과/4.틀린 계산 수식에 의한 잘못된 결과/"
}, {
  "question" : "다음 설명의 소프트웨어 테스트의 기본원칙은?",
  "answer" : "2.결함 집중",
  "commentary" : "소프트웨어 테스트의 기본원칙 중 하나는 \"결함 집중\"입니다. 이는 소프트웨어 테스트에서 결함이 발생할 가능성이 높은 부분에 집중하여 테스트를 수행해야 한다는 것을 의미합니다. 이는 테스트 자원을 효율적으로 사용하고, 결함 발견률을 높이며, 테스트 비용을 절감할 수 있는 방법입니다. 따라서 결함 집중은 소프트웨어 테스트에서 매우 중요한 원칙 중 하나입니다.",
  "choices" : "1.살충제 패러독스/2.결함 집중/3.오류 부재의 궤변/4.완벽한 테스팅은 불가능/"
}, {
  "question" : "버전 관리 항목 중 저장소에 새로운 버전의 파일로 갱신하는 것을 의미하는 용어는?",
  "answer" : "4.체크인(Check-In)",
  "commentary" : "체크인은 로컬에서 수정한 파일을 저장소에 업로드하여 새로운 버전으로 갱신하는 것을 의미합니다. 따라서 저장소에 새로운 버전의 파일로 갱신하는 것을 의미하는 용어는 체크인입니다.",
  "choices" : "1.형상 감사(Configuration Audit)/2.롤백 (Rollback)/3.단위 테스트(Unit Test)/4.체크인(Check-In)/"
}, {
  "question" : "소프트웨어 테스트와 관련한 설명으로 틀린것은?",
  "answer" : "4.화이트박스 테스트에서 기본 경로(BasisPath)란 흐름 그래프의 시작 노드에서 종료노드까지의 서로 독립된 경로로 싸이클을 허용하지 않는 경로를 말한다.",
  "commentary" : "\"화이트 박스 테스트는 모듈의 논리적인 구조를 체계적으로 점검할 수 있다.\"가 틀린 설명입니다. 화이트 박스 테스트는 모듈의 논리적인 구조를 체계적으로 점검할 수 있으며, 블랙박스 테스트와 달리 프로그램의 내부 구조를 고려합니다. 따라서 \"화이트 박스 테스트는 모듈의 논리적인 구조를 체계적으로 점검할 수 없다.\"가 맞는 설명입니다. 기본 경로(BasisPath)란 흐름 그래프의 시작 노드에서 종료노드까지의 서로 독립된 경로로 싸이클을 허용하지 않는 경로를 말합니다. 이는 프로그램의 내부 구조를 파악하고 테스트 케이스를 설계하는 데 유용합니다.",
  "choices" : "1.화이트 박스 테스트는 모듈의 논리적인 구조를 체계적으로 점검할 수 있다./2.블랙박스 테스트는 프로그램의 구조를 고려하지 않는다./3.테스트 케이스에는 일반적으로 시험 조건,테스트 데이터, 예상 결과가 포함되어야한다./4.화이트박스 테스트에서 기본 경로(BasisPath)란 흐름 그래프의 시작 노드에서 종료노드까지의 서로 독립된 경로로 싸이클을 허용하지 않는 경로를 말한다./"
}, {
  "question" : "애플리케이션의 처리량, 응답시간, 경과시간, 자원사용률에 대해 가상의 사용자를 생성하고 테스트를 수행함으로써 성능 목표를 달성하였는지를 확인하는 테스트 자동화 도구는?",
  "answer" : "4.성능 테스트 도구",
  "commentary" : "성능 테스트 도구는 애플리케이션의 처리량, 응답시간, 경과시간, 자원사용률 등을 측정하고, 가상의 사용자를 생성하여 테스트를 수행함으로써 성능 목표를 달성하였는지를 확인하는 자동화 도구입니다. 따라서, 이 문제에서는 \"성능 테스트 도구\"가 정답입니다.",
  "choices" : "1.명세 기반 테스트 설계 도구/2.코드 기반 테스트 설계 도구/3.기능 테스트 수행 도구/4.성능 테스트 도구/"
}, {
  "question" : "소프트웨어 형상 관리에 대한 설명으로 거리가 먼 것은?",
  "answer" : "3.대표적인 형상관리 도구로 Ant, Maven, Gradle 등이 있다.",
  "commentary" : "\"프로젝트 계획, 분석서, 설계서, 프로그램, 테스트 케이스 모두 관리 대상이다.\"가 거리가 먼 설명입니다. 소프트웨어 형상 관리는 소프트웨어 코드와 관련된 변경 사항을 제어하고 관리하는 것이 주요 목적이며, 프로젝트 계획, 분석서, 설계서 등은 프로젝트 관리의 범주에 속합니다. 따라서, 소프트웨어 형상 관리는 주로 소프트웨어 코드와 관련된 변경 사항을 다루며, 프로젝트 관리와는 다른 개념입니다. \"대표적인 형상관리 도구로 Ant, Maven, Gradle 등이 있다.\"는 형상 관리 도구의 대표적인 예시를 나열한 것으로, 형상 관리 도구의 역할과 중요성을 간략하게 설명한 것입니다.",
  "choices" : "1.소프트웨어에 가해지는 변경을 제어하고 관리한다./2.프로젝트 계획, 분석서, 설계서, 프로그램, 테스트 케이스 모두 관리 대상이다./3.대표적인 형상관리 도구로 Ant, Maven, Gradle 등이 있다./4.유지 보수 단계뿐만 아니라 개발 단계에도 적용할 수 있다./"
}, {
  "question" : "디지털 저작권 관리(DRM) 구성 요소가 아닌 것은?",
  "answer" : "1.Dataware house",
  "commentary" : "\"Dataware house\"는 데이터 저장 및 관리를 위한 시스템으로, 디지털 저작권 관리(DRM)와 직접적인 연관성이 없습니다. 따라서, \"Dataware house\"가 디지털 저작권 관리(DRM) 구성 요소가 아닙니다.",
  "choices" : "1.Dataware house/2.DRM Controller/3.Packager/4.Contents Distributor/"
}, {
  "question" : "다음 설명의 소프트웨어 버전 관리도구 방식은?",
  "answer" : "2.분산 저장소 방식",
  "commentary" : "이 방식은 Git을 사용하는 분산 저장소 방식이다. Git은 모든 개발자들이 로컬 저장소를 가지고 있으며, 중앙 저장소가 아닌 각자의 로컬 저장소에서 작업을 하고 변경 내용을 서로 공유하면서 버전을 관리하는 방식이다. 이를 통해 개발자들은 독립적으로 작업을 진행할 수 있으며, 중앙 저장소에 문제가 생겨도 로컬 저장소에서 작업을 계속할 수 있다. 또한 Git은 브랜치를 통해 여러 개발자들이 동시에 작업을 진행할 수 있도록 지원하며, 변경 내용을 병합하는 기능도 제공한다.",
  "choices" : "1.단일 저장소 방식/2.분산 저장소 방식/3.공유폴더 방식/4.클라이언트·서버 방식/"
}, {
  "question" : "블랙박스 테스트를 이용하여 발견할 수 있는 오류가 아닌 것은?",
  "answer" : "3.반복 조건을 만족하는데도 루프 내의 문장이 수행되지 않는 경우",
  "commentary" : "반복 조건을 만족하는데도 루프 내의 문장이 수행되지 않는 경우는 논리적인 오류이기 때문에 블랙박스 테스트로는 발견할 수 없습니다. 이는 코드의 논리적인 구조나 알고리즘의 문제로 인해 발생할 수 있으며, 따라서 코드 리뷰나 정적 분석 등의 다른 방법을 사용하여 발견해야 합니다.",
  "choices" : "1.비정상적인 자료를 입력해도 오류 처리를 수행하지 않는 경우/2.정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우/3.반복 조건을 만족하는데도 루프 내의 문장이 수행되지 않는 경우/4.경계값을 입력할 경우 요구된 출력 결과가 나오지 않는 경우/"
}, {
  "question" : "다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 Pass 2의 결과는?",
  "answer" : "4.6, 3, 5, 7, 9",
  "commentary" : null,
  "choices" : "1.3, 5, 6, 7, 9/2.6, 7, 3, 5, 9/3.3, 5, 9, 6, 7/4.6, 3, 5, 7, 9/"
}, {
  "question" : "정렬된 N개의 데이터를 처리하는 데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은?",
  "answer" : "1.합병정렬",
  "commentary" : "합병정렬은 분할 정복 알고리즘을 사용하여 정렬하는 알고리즘이다. 데이터를 반으로 나누어 각각을 정렬한 후, 합병하여 전체를 정렬한다. 이 때, 분할과 합병 과정에서 각각 O(Nlog2N)의 시간이 소요되므로 전체적으로 O(Nlog2N)의 시간이 소요된다. 따라서, 정렬된 N개의 데이터를 처리하는 데 O(Nlog2N)의 시간이 소요되는 알고리즘은 합병정렬이다.",
  "choices" : "1.합병정렬/2.버블정렬/3.선택정렬/4.삽입정렬/"
}, {
  "question" : "다음 postfix로 표현된 연산식의 연산 결과로 옳은 것은?",
  "answer" : "2.42",
  "commentary" : null,
  "choices" : "1.35/2.42/3.81/4.360/"
}, {
  "question" : "EAI(Enterprise Application Integration) 구축 유형에서 애플리케이션 사이에 미들웨어를 두어 처리하는 것은? (문제 오류로 가답안 발표시 1번으로 발표되었지만 확정 답안 발표시 1, 3, 4번이 정답처리 되었습니다. 여기서는 가답안인 1번을 누르면 정답 처리 됩니다.)",
  "answer" : "1.Message Bus",
  "commentary" : "\"Message Bus\"는 애플리케이션 사이에 미들웨어를 두어 처리하는 EAI 구축 유형 중 하나입니다. 이 방식은 중앙 집중적인 메시지 버스를 통해 애플리케이션 간 통신을 처리합니다. 따라서 애플리케이션 간의 직접적인 연결이 필요하지 않으며, 유연하고 확장성이 높은 구조를 가지고 있습니다.",
  "choices" : "1.Message Bus/2.Point-to-point/3.Hub & Spoke/4.Hybrid/"
}, {
  "question" : "인터페이스 구현 검증 도구가 아닌 것은?",
  "answer" : "1.Foxbase",
  "commentary" : "인터페이스 구현 검증 도구는 STAF, watir, xUnit과 같은 도구들이 해당되지만, Foxbase는 데이터베이스 관리 시스템으로서 인터페이스 구현 검증 도구가 아니다.",
  "choices" : "1.Foxbase/2.STAF/3.watir/4.xUnit/"
}, {
  "question" : "클린코드 작성원칙에 대한 설명으로 틀린 것은?",
  "answer" : "2.코드가 다른 모듈에 미치는 영향을 최대화하도록 작성한다.",
  "commentary" : "\"코드가 다른 모듈에 미치는 영향을 최대화하도록 작성한다.\"는 클린코드 작성원칙이 아니라 반대로, 코드가 다른 모듈에 미치는 영향을 최소화하도록 작성해야 하는 원칙입니다. 이는 모듈 간의 결합도를 낮추고 유지보수성을 높이기 위한 것입니다.",
  "choices" : "1.코드의 중복을 최소화 한다./2.코드가 다른 모듈에 미치는 영향을 최대화하도록 작성한다./3.누구든지 코드를 쉽게 읽을 수 있도록 작성한다./4.간단하게 코드를 작성한다./"
}, {
  "question" : "소프트웨어 패키징에 대한 설명으로 틀린 것은?",
  "answer" : "1.패키징은 개발자 중심으로 진행한다.",
  "commentary" : "정답은 \"패키징은 개발자 중심으로 진행한다.\" 이다. 이유는 패키징은 개발자가 개발한 소프트웨어를 상용 제품으로 만들기 위한 과정으로, 개발자가 중심이 되어 신규 및 변경 개발소스를 모듈화하여 패키징하고, 매뉴얼 및 버전관리를 지속적으로 하며, 일반적인 배포 형태로 패키징을 진행한다. 따라서 \"패키징은 개발자 중심으로 진행한다.\"는 틀린 설명이다.",
  "choices" : "1.패키징은 개발자 중심으로 진행한다./2.신규 및 변경 개발소스를 식별하고, 이를 모듈화하여 상용제품으로 패키징 한다./3.고객의 편의성을 위해 매뉴얼 및 버전관리를 지속적으로 한다./4.범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 패키징이 진행된다./"
}, {
  "question" : "공학적으로 잘된 소프트웨어(Well Engineered Software)의 설명 중 틀린 것은?",
  "answer" : "3.소프트웨어는 사용자 수준에 무관하게 일관된 인터페이스를 제공해야 한다.",
  "commentary" : "\"소프트웨어는 사용자 수준에 무관하게 일관된 인터페이스를 제공해야 한다.\"가 틀린 설명입니다. 이는 사용자 경험(User Experience) 측면에서 중요한 요소 중 하나이며, 사용자의 편의성과 효율성을 높이기 위해 고려되어야 합니다. 따라서 사용자 수준에 맞는 인터페이스를 제공하는 것이 더욱 중요합니다.",
  "choices" : "1.소프트웨어는 유지보수가 용이해야 한다./2.소프트웨어는 신뢰성이 높아야 한다./3.소프트웨어는 사용자 수준에 무관하게 일관된 인터페이스를 제공해야 한다./4.소프트웨어는 충분한 테스팅을 거쳐야 한다./"
}, {
  "question" : "테스트와 디버그의 목적으로 옳은 것은?",
  "answer" : "1.테스트는 오류를 찾는 작업이고 디버깅은 오류를 수정하는 작업이다.",
  "commentary" : "테스트는 소프트웨어의 오류를 찾는 작업이며, 디버깅은 찾은 오류를 수정하는 작업입니다. 따라서 \"테스트는 오류를 찾는 작업이고 디버깅은 오류를 수정하는 작업이다.\"가 옳은 답입니다.",
  "choices" : "1.테스트는 오류를 찾는 작업이고 디버깅은 오류를 수정하는 작업이다./2.테스트는 오류를 수정하는 작업이고 디버깅은 오류를 찾는 작업이다./3.둘 다 소프트웨어의 오류를 찾는 작업으로 오류 수정은 하지 않는다./4.둘 다 소프트웨어 오류의 발견, 수정과 무관하다./"
}, {
  "question" : "다음 중 스택을 이용한 연산과 거리가 먼 것은?",
  "answer" : "1.선택정렬",
  "commentary" : "선택정렬은 스택을 사용하지 않는 정렬 알고리즘이기 때문에 스택을 이용한 연산과 거리가 먼 것입니다. 선택정렬은 배열에서 가장 작은 값을 찾아 맨 앞으로 이동시키는 과정을 반복하여 정렬하는 알고리즘으로, 스택을 사용하지 않고 반복문을 이용하여 구현합니다. 따라서 선택정렬은 스택을 이용한 연산과는 거리가 먼 알고리즘이라고 할 수 있습니다.",
  "choices" : "1.선택정렬/2.재귀호출/3.후위표현(Post-fix expression)의 연산/4.깊이우선탐색/"
}, {
  "question" : "병렬 데이터베이스 환경 중 수평 분할에서 활용되는 분할 기법이 아닌 것은?",
  "answer" : "3.예측 분할",
  "commentary" : "수평 분할에서 활용되는 분할 기법 중 \"예측 분할\"은 없습니다. 이유는 예측 분할은 데이터를 일정한 기준에 따라 미리 예측하여 분할하는 기법으로, 이는 데이터의 특성을 고려하지 않고 단순히 예측에 의존하기 때문에 분할 결과가 불균형하거나 성능이 저하될 가능성이 높기 때문입니다. 따라서 일반적으로 사용되는 분할 기법은 \"라운드-로빈\", \"범위 분할\", \"해시 분할\"입니다.",
  "choices" : "1.라운드-로빈/2.범위 분할/3.예측 분할/4.해시 분할/"
}, {
  "question" : "시스템 카탈로그에 대한 설명으로 옳지 않은 것은?",
  "answer" : "1.사용자가 직접 시스템 카탈로그의 내용을 갱신하여 데이터베이스 무결성을 유지한다.",
  "commentary" : "\"사용자가 직접 시스템 카탈로그의 내용을 갱신하여 데이터베이스 무결성을 유지한다.\"는 옳지 않은 설명이다. 시스템 카탈로그는 DBMS가 스스로 생성하고 유지하며, 사용자가 직접 갱신하는 것은 권장되지 않는다. 이는 데이터베이스 무결성을 위반할 수 있기 때문이다.",
  "choices" : "1.사용자가 직접 시스템 카탈로그의 내용을 갱신하여 데이터베이스 무결성을 유지한다./2.시스템 자신이 필요로 하는 스키마 및 여러가지 객체에 관한 정보를 포함하고 있는 시스템 데이터베이스이다./3.시스템 카탈로그에 저장되는 내용을 메타데이터라고도 한다./4.시스템 카탈로그는 DBMS가 스스로 생성하고 유지한다./"
}, {
  "question" : "SQL 문에서 SELECT에 대한 설명으로 옳지않은 것은?",
  "answer" : "2.검색결과에 중복되는 레코드를 없애기위해서는 WHERE 절에 'DISTINCT'키워드를 사용한다.",
  "commentary" : "검색결과에 중복되는 레코드를 없애기위해서는 WHERE 절에 'DISTINCT'키워드를 사용한다는 설명이 옳지 않습니다. 중복된 레코드를 제거하기 위해서는 SELECT 절에서 속성을 선택할 때 DISTINCT 키워드를 사용해야 합니다. WHERE 절은 조건을 지정하는 역할을 하며, DISTINCT와는 별개의 개념입니다.",
  "choices" : "1.FROM 절에는 질의에 의해 검색될 데이터들을 포함하는 테이블명을 기술한다./2.검색결과에 중복되는 레코드를 없애기위해서는 WHERE 절에 'DISTINCT'키워드를 사용한다./3.HAVING 절은 GROUP BY 절과 함께 사용되며, 그룹에 대한 조건을 지정한다./4.ORDER BY 절은 특정 속성을 기준으로 정렬하여 검색할 때 사용한다./"
}, {
  "question" : "SQL에서 VIEW를 삭제할 때 사용하는 명령은?",
  "answer" : "3.DROP",
  "commentary" : "정답은 \"DROP\"이다. \"ERASE\", \"KILL\", \"DELETE\"는 모두 데이터를 삭제하는 명령어이지만, VIEW는 데이터를 저장하는 것이 아니라 쿼리 결과를 보여주는 가상 테이블이므로 삭제할 때는 \"DROP\"을 사용한다. \"DROP\"은 데이터베이스 객체를 삭제하는 일반적인 명령어이다.",
  "choices" : "1.ERASE/2.KILL/3.DROP/4.DELETE/"
}, {
  "question" : "DDL(Data Define Language)의 명령어 중 스키마, 도메인, 인덱스 등을 정의할 때 사용하는 SQL문은?",
  "answer" : "3.CREATE",
  "commentary" : "CREATE 문은 DDL(Data Define Language)의 명령어 중 스키마, 도메인, 인덱스 등을 정의할 때 사용하는 SQL문입니다. 이는 새로운 데이터베이스 객체를 생성하는 데 사용되며, ALTER 문은 기존 객체를 수정하고, SELECT 문은 데이터를 조회하고, INSERT 문은 데이터를 삽입하는 데 사용됩니다. 따라서 CREATE 문은 DDL에서 가장 중요한 명령어 중 하나입니다.",
  "choices" : "1.ALTER/2.SELECT/3.CREATE/4.INSERT/"
}, {
  "question" : "테이블 R1, R2에 대하여 다음 SQL문의결과는?",
  "answer" : "2.",
  "commentary" : null,
  "choices" : "1./2./3./4./"
}, {
  "question" : "데이터베이스 설계 시 물리적 설계 단계에서 수행하는 사항이 아닌 것은?",
  "answer" : "4.목표 DBMS에 맞는 스키마 설계",
  "commentary" : "목표 DBMS에 맞는 스키마 설계는 논리적 설계 단계에서 수행하는 사항이기 때문에 물리적 설계 단계에서는 수행하지 않는다. 물리적 설계 단계에서는 논리적 설계 단계에서 정의된 스키마를 기반으로 데이터베이스를 실제로 구현하기 위한 세부적인 사항들을 결정하고 구현한다. 따라서 목표 DBMS에 맞는 스키마 설계는 논리적 설계 단계에서 수행되어야 한다.",
  "choices" : "1.레코드 집중의 분석 및 설계/2.접근 경로 설계/3.저장 레코드의 양식 설계/4.목표 DBMS에 맞는 스키마 설계/"
}, {
  "question" : "릴레이션에서 기본 키를 구성하는 속성은　널(Null)값이나 중복 값을 가질 수 없다는　것을 의미하는 제약조건은?",
  "answer" : "3.개체 무결성",
  "commentary" : "기본 키는 릴레이션에서 각 행을 유일하게 식별하는 속성이므로 널 값이나 중복 값을 가질 수 없어야 합니다. 이러한 제약 조건을 개체 무결성이라고 합니다. 따라서 정답은 \"개체 무결성\"입니다. 참조 무결성은 외래 키와 관련된 제약 조건을 의미하며, 보안 무결성은 데이터의 무단 접근을 방지하는 제약 조건을 의미합니다. 정보 무결성은 데이터의 정확성과 일관성을 보장하는 제약 조건을 의미합니다.",
  "choices" : "1.참조 무결성/2.보안 무결성/3.개체 무결성/4.정보 무결성/"
}, {
  "question" : "병행제어 기법의 종류가 아닌 것은?",
  "answer" : "2.시분할 기법",
  "commentary" : "시분할 기법은 병행제어 기법 중 하나가 아니라, 시스템 자원을 여러 사용자가 공유하여 사용할 수 있도록 하는 기법이다. 시분할 기법은 CPU 시간을 작은 단위로 쪼개어 여러 작업을 번갈아가며 처리함으로써 사용자에게 빠른 응답성을 제공한다. 따라서 정답은 \"시분할 기법\"이다.",
  "choices" : "1.로킹 기법/2.시분할 기법/3.타임 스탬프 기법/4.다중 버전 기법/"
}, {
  "question" : "다음 R1과 R2의 테이블에서 아래의　실행 결과를 얻기 위한 SQL문은?",
  "answer" : "1.SELECT 과목번호, 과목이름 FROM RI, R2 WHERE R1.학번 = R2. 학번 AND R1.학과='전자공학' AND R1.이름 = '강남길’;",
  "commentary" : "정답은 \"SELECT 과목번호, 과목이름 FROM RI, R2 WHERE R1.학번 = R2. 학번 AND R1.학과='전자공학' AND R1.이름 = '강남길’;\" 이다. 이유는 문제에서 \"R1과 R2의 테이블에서 아래의 실행 결과를 얻기 위한 SQL문은?\" 이라고 했으므로, R1과 R2 테이블을 이용해야 한다. 그리고 문제에서 요구하는 결과는 \"과목번호\"와 \"과목이름\"이므로 SELECT 절에 이 두 컬럼을 명시해야 한다. WHERE 절에서는 R1과 R2를 학번을 기준으로 JOIN 해야 하므로 \"R1.학번 = R2.학번\" 조건을 추가한다. 그리고 \"R1.학과='전자공학' AND R1.이름 = '강남길’\" 조건을 추가하여 학과가 전자공학이고 이름이 강남길인 학생의 과목번호와 과목이름을 조회한다. 따라서 정답은 \"SELECT 과목번호, 과목이름 FROM RI, R2 WHERE R1.학번 = R2. 학번 AND R1.학과='전자공학' AND R1.이름 = '강남길’;\" 이다.",
  "choices" : "1.SELECT 과목번호, 과목이름 FROM RI, R2 WHERE R1.학번 = R2. 학번 AND R1.학과='전자공학' AND R1.이름 = '강남길’;/2.SELECT 과목번호, 과목이름 FROM RI, R2 WHERE R1.학번 = R2.학번 OR R1.학과='전자공학' OR R1.이름 = '홍길동';/3.SELECT 과목번호, 과목이름 FROM R1, R2 WHERE R1.학번 = R2.학번 AND R1.학과=‘컴퓨터공학' AND R1.이름 '강남길’;/4.SELECT 과목번호, 과목이름 FROM R1, R2 WHERE R1.학번 = R2.학번 OR R1.학과='컴퓨터공학' OR R1.이름 = '홍길동';/"
}, {
  "question" : "다음 관계 대수 중 순수 관계 연산자가 아닌 것은?",
  "answer" : "1.차집합(difference)",
  "commentary" : "차집합(difference)은 순수 관계 연산자가 아닙니다. 이유는 차집합은 두 개의 릴레이션에서 공통된 튜플을 제외한 나머지 튜플들을 반환하는 연산자이기 때문입니다. 이는 릴레이션 간의 관계를 나타내는 연산자가 아니며, 따라서 순수 관계 연산자가 아닙니다. 반면, 프로젝트(project), 조인(join), 디비전(division)은 모두 순수 관계 연산자입니다.",
  "choices" : "1.차집합(difference)/2.프로젝트(project)/3.조인(join)/4.디비전 (division)/"
}, {
  "question" : "관계형 데이터 모델의 릴레이션에 대한 설명으로 틀린 것은?",
  "answer" : "4.한 릴레이션을 구성하는 속성 사이에는 순서가 존재한다.",
  "commentary" : "\"한 릴레이션을 구성하는 속성 사이에는 순서가 존재한다.\"는 틀린 설명입니다. 릴레이션의 속성은 순서가 없이 무작위로 나열될 수 있습니다. 이는 릴레이션의 튜플이 속성의 값들을 나열하는 순서와는 별개로 저장되기 때문입니다. 따라서 릴레이션에서는 속성의 순서가 중요하지 않습니다.",
  "choices" : "1.모든 속성 값은 원자 값을 갖는다./2.한 릴레이션에 포함된 튜플은 모두 상이하다./3.한 릴레이 션에 포함된 튜플 사이에는 순서가 없다./4.한 릴레이션을 구성하는 속성 사이에는 순서가 존재한다./"
}, {
  "question" : "릴레이션 R의 차수가 4이고 카디널리티가 5이며, 릴레이션 S의 차수가 6이고 카디널리티가 7일 때, 두 개의 릴레이션을 카티션 프로덕트한 결과의 새로운 릴레이 션의 차수와 카디널리티는 얼마인가?",
  "answer" : "3.10, 35",
  "commentary" : "카티션 프로덕트는 두 릴레이션의 모든 가능한 조합을 만들어내는 연산이므로, 결과 릴레이션의 차수는 두 릴레이션의 차수를 더한 값과 같다. 따라서, 새로운 릴레이션의 차수는 4+6=10이 된다. 카디널리티는 두 릴레이션의 튜플 수를 곱한 값과 같다. 따라서, 새로운 릴레이션의 카디널리티는 5*7=35가 된다. 따라서, 정답은 \"10, 35\"이다.",
  "choices" : "1.24, 35/2.24, 12/3.10, 35/4.10, 12/"
}, {
  "question" : "속성(attribute)에 대한 설명으로 틀린 것은?",
  "answer" : "4.속성의 수를 \"cardinality\" 라고 한다.",
  "commentary" : "속성의 수를 \"cardinality\" 라고 하는 것은 틀린 설명입니다. 속성의 수를 나타내는 용어는 \"attribute cardinality\"이며, \"cardinality\"는 관계형 데이터베이스에서 관계의 연결정도를 나타내는 용어입니다. 속성은 개체의 특성을 기술하며, 데이터베이스를 구성하는 가장 작은 논리적 단위이며, 파일 구조상 데이터 항목 또는 데이터 필드에 해당됩니다.",
  "choices" : "1.속성은 개체의 특성을 기술한다./2.속성은 데이터베이스를 구성하는 가장 작은 논리적 단위이다./3.속성은 파일 구조상 데이터 항목 또는 데이터 필드에 해당된다./4.속성의 수를 \"cardinality\" 라고 한다./"
}, {
  "question" : "다음 SQL 문에서 ( ) 안에 들어갈 내용으로 옳은 것은?",
  "answer" : "1.SET",
  "commentary" : null,
  "choices" : "1.SET/2.FROM/3.INTO/4.IN/"
}, {
  "question" : "관계 데이터베이스 모델에서 차수(Degree)의 의미는?",
  "answer" : "4.애트리뷰트의 수",
  "commentary" : "관계 데이터베이스 모델에서 차수(Degree)는 한 릴레이션 내에서 각 튜플이 가지는 애트리뷰트의 수를 의미합니다. 따라서 정답은 \"애트리뷰트의 수\"입니다.",
  "choices" : "1.튜플의 수/2.테이블의 수/3.데이터베이스의 수/4.애트리뷰트의 수/"
}, {
  "question" : "개체-관계 모델(E-R)의 그래픽 표현으로 옳지 않은 것은?",
  "answer" : "4.연결 - 삼각형",
  "commentary" : "연결 - 삼각형은 E-R 모델에서 사용되지 않는 그래픽 표현입니다. 개체타입은 사각형으로, 속성은 원형으로, 관계타입은 마름모로 표현됩니다. 연결은 일반적으로 선으로 표현됩니다.",
  "choices" : "1.개체타입 – 사각형/2.속성 - 원형/3.관계타입 - 마름모/4.연결 - 삼각형/"
}, {
  "question" : "트랜잭션의 실행이 실패하였음을 알리는 연산자로 트랜잭션이 수행한 결과를 원래의 상태로 원상 복귀 시키는 연산은?",
  "answer" : "4.ROLLBACK 연산",
  "commentary" : "ROLLBACK 연산은 트랜잭션 실행 중 오류가 발생하거나 사용자가 명시적으로 취소하고자 할 때, 이전 상태로 되돌리는 연산이다. 따라서 트랜잭션의 실행이 실패하였음을 알리는 연산자로 ROLLBACK 연산이 선택되는 것이다.",
  "choices" : "1.COMMIT 연산/2.BACKUP 연산/3.LOG 연산/4.ROLLBACK 연산/"
}, {
  "question" : "데이터 속성 간의 종속성에 대한 엄밀한 고려없이 잘못 설계된 데이터베이스에서는 데이터 처리 연산 수행 시 각종 이상 현상이 발생할 수 있는데, 이러한 이상 현상이 아닌 것은?",
  "answer" : "1.검색 이상",
  "commentary" : "검색 이상은 데이터베이스에서 특정 데이터를 검색할 때 원하는 결과가 나오지 않는 현상을 말한다. 이는 데이터의 중복성이나 불일치로 인해 발생할 수 있으며, 데이터베이스의 구조가 잘못 설계되어서도 발생할 수 있다. 따라서 검색 이상은 데이터 처리 연산 수행 시 발생하는 이상 현상 중 하나가 아니다.",
  "choices" : "1.검색 이상/2.삽입 이상/3.삭제 이상/4.갱신 이상/"
}, {
  "question" : "제3정규형 (3NF)에서 BCNF(Boyce-Codd Normal Form)가 되기 위한 조건은?",
  "answer" : "1.결정자가 후보키가 아닌 함수 종속 제거",
  "commentary" : "BCNF는 모든 결정자가 후보키인 정규형이다. 따라서, 제3정규형에서 BCNF가 되기 위해서는 결정자가 후보키가 아닌 함수 종속을 제거해야 한다. 이는 결정자가 후보키가 아닌 함수 종속이 존재할 경우, 해당 속성이 부분적으로 함수 종속되어 있을 가능성이 있기 때문이다. 이를 제거함으로써 모든 결정자가 후보키가 되어 BCNF를 만족시킬 수 있다.",
  "choices" : "1.결정자가 후보키가 아닌 함수 종속 제거/2.이행적 함수 종속 제거/3.부분적 함수 종속 제거/4.원자값이 아닌 도메인 분해/"
}, {
  "question" : "다음 설명에 해당하는 방식은?",
  "answer" : "3.CSMA/CA",
  "commentary" : "이 방식은 CSMA/CA 방식입니다. 이유는 다음과 같습니다. - STA: STA는 Station의 약자로, 무선 네트워크에 연결된 장치를 의미합니다. 그림에서는 노트북과 스마트폰이 STA입니다. - Collision Domain: Collision Domain은 충돌 도메인으로, 같은 네트워크 상에서 충돌이 발생할 수 있는 영역을 의미합니다. 그림에서는 노트북과 스마트폰이 같은 Collision Domain에 속합니다. - CSMA/CA: CSMA/CA는 Carrier Sense Multiple Access with Collision Avoidance의 약자로, 무선 네트워크에서 충돌을 방지하기 위한 방식입니다. 이 방식은 데이터를 전송하기 전에 채널을 감지하여 사용 중인지 여부를 확인하고, 사용 중이 아니면 데이터를 전송합니다. 그러나 무선 환경에서는 채널이 사용 중이더라도 신호가 약하거나 간섭이 발생할 수 있으므로, 충돌을 방지하기 위해 데이터를 전송하기 전에 무작위로 대기하는 시간을 둡니다. 이를 Backoff time이라고 합니다. 그림에서는 노트북이 데이터를 전송하기 전에 채널을 감지하고, Backoff time을 두고 데이터를 전송합니다. - CSMA/CD: CSMA/CD는 Carrier Sense Multiple Access with Collision Detection의 약자로, 유선 네트워크에서 충돌을 방지하기 위한 방식입니다. 그러나 무선 환경에서는 CSMA/CD 방식을 사용할 수 없습니다. 그림에서는 CSMA/CD 방식이 아닌 CSMA/CA 방식을 사용합니다.",
  "choices" : "1.STA/2.Collision Domain/3.CSMA/CA/4.CSMA/CD/"
}, {
  "question" : "다음 중 가장 약한 결합도(Coupling)는?",
  "answer" : "4.Stamp Coupling",
  "commentary" : "가장 약한 결합도는 \"Stamp Coupling\"이다. 이는 모듈 간의 상호작용이 매우 적고, 모듈이 독립적으로 작동할 수 있기 때문이다. 즉, 모듈 내부의 구현이 완전히 분리되어 있으며, 다른 모듈과의 상호작용이 거의 없는 경우이다. 이는 모듈의 재사용성과 유지보수성을 높이는데 도움이 된다.",
  "choices" : "1.Common Coupling/2.Content Coupling/3.External Coupling/4.Stamp Coupling/"
}, {
  "question" : "다음 C언어 프로그램이 실행되었을 때의 결과는?",
  "answer" : "3.7",
  "commentary" : null,
  "choices" : "1.3/2.4/3.7/4.10/"
}, {
  "question" : "다음 파이썬(Python) 프로그램이 실행되었을 때의 결과는?",
  "answer" : "4.6",
  "commentary" : null,
  "choices" : "1.0/2.2/3.4/4.6/"
}, {
  "question" : "교착상태의 해결 방법 중 은행원 알고리즘(Banker's Algorithm)이 해당되는 기법은?",
  "answer" : "2.Avoidance",
  "commentary" : "은행원 알고리즘은 교착상태를 예방하는 방법 중 하나로, 자원 할당 요청 시 시스템이 안정적인 상태를 유지할 수 있는지 사전에 검사하여 안정적인 상태를 유지할 수 없는 경우 자원 할당을 거부함으로써 교착상태를 예방합니다. 따라서 정답은 \"Avoidance\"입니다.",
  "choices" : "1.Detection/2.Avoidance/3.Recovery/4.Prevention/"
}, {
  "question" : "CIDR(Classless Inter-Domain Routing) 표기로 203.241.132.82/27과 같이 사용되었다면, 해당 주소의 서브넷 마스크(subnet mask)는?",
  "answer" : "2.255.255.255.224",
  "commentary" : "CIDR 표기에서 /27은 27비트가 네트워크 부분에 할당되고 나머지 5비트가 호스트 부분에 할당된다는 것을 의미합니다. 따라서 서브넷 마스크는 네트워크 부분이 모두 1이고 호스트 부분이 모두 0인 32비트 마스크를 사용해야 합니다. 이를 8비트씩 나누어 표기하면 255.255.255.224가 됩니다. 따라서 정답은 \"255.255.255.224\"입니다.",
  "choices" : "1.255.255.255.0/2.255.255.255.224/3.255.255.255.240/4.255.255.255.248/"
}, {
  "question" : "다음 JAVA 프로그램이 실행되었을 때의 결과는?",
  "answer" : "1.5, 5, 5",
  "commentary" : "이유는 다음과 같습니다. 1. int[] arr = {5, 5, 5}; : 배열 arr에 5, 5, 5를 저장합니다. 2. change(arr); : change 메소드에 배열 arr을 전달합니다. 3. int[] arr = {5, 6, 5}; : change 메소드에서 배열 arr의 두 번째 요소를 6으로 변경합니다. 4. arr[2] = 5; : change 메소드에서 배열 arr의 세 번째 요소를 5로 변경합니다. 5. System.out.println(Arrays.toString(arr)); : 변경된 배열 arr을 출력합니다. 따라서, 출력 결과는 \"5, 5, 5\"가 됩니다.",
  "choices" : "1.5, 5, 5/2.5, 6, 5/3.6, 5, 5/4.5, 6, 4/"
}, {
  "question" : "프로세스 적재 정책과 관련한 설명으로 틀린 것은?",
  "answer" : "3.일반적으로 페이지 교환에 보내는 시간보다 프로세스 수행에 보내는 시간이 더 크면 스레싱(Thrashing)이 발생한다.",
  "commentary" : "스레싱은 CPU 작업 시간보다 메모리와 스왑 영역 간 페이지 교체에 시간을 많이 소비하는 것을 말합니다.",
  "choices" : "1.반복, 스택, 부프로그램은 시간 지역성(Temporal Locality)과 관련이 있다./2.공간 지역성(Spatial Locality)은 프로세스가 어떤 페이지를 참조했다면 이후 가상주소공간상 그 페이지와 인접한 페이지들을 참조할 가능성이 높음을 의미한다./3.일반적으로 페이지 교환에 보내는 시간보다 프로세스 수행에 보내는 시간이 더 크면 스레싱(Thrashing)이 발생한다./4.스레싱(Thrashing) 현상을 방지하기 위해서는 각 프로세스가 필요로 하는 프레임을 제공할 수 있어야 한다./"
}, {
  "question" : "프레임워크(Framework)에 대한 설명으로 옳은 것은?",
  "answer" : "1.소프트웨어 구성에 필요한 기본 구조를 제공함으로써 재사용이 가능하게 해준다",
  "commentary" : "프레임워크는 소프트웨어 구성에 필요한 기본 구조를 제공함으로써 재사용이 가능하게 해줍니다. 이는 개발자가 일일이 구조를 만들 필요 없이 프레임워크에서 제공하는 구조를 활용하여 개발을 빠르고 효율적으로 할 수 있게 해줍니다. 따라서 프레임워크는 모듈화가 가능하며, 소프트웨어 아키텍처와는 다른 개념입니다. 하지만 프레임워크에서 제공하는 구조를 벗어나는 확장은 어려울 수 있습니다.",
  "choices" : "1.소프트웨어 구성에 필요한 기본 구조를 제공함으로써 재사용이 가능하게 해준다/2.소프트웨어 개발 시 구조가 잡혀 있기 때문에 확장이 불가능하다./3.소프트웨어 아키텍처(Architecture)와 동일한 개념이다./4.모듈화(Modularity)가 불가능하다./"
}, {
  "question" : "다음 JAVA 프로그램이 실행되었을 때의 결과는?",
  "answer" : "1.2",
  "commentary" : "이 프로그램은 배열 arr 에서 가장 작은 값을 찾아서 그 값을 출력하는 것이다. arr 배열의 값은 {5, 3, 2, 4} 이므로, 1. min 변수에 arr[0] 즉, 5를 저장한다. 2. for 문을 돌면서 arr 배열의 값과 min 값을 비교한다. 3. arr[1] 즉, 3이 min 값보다 작으므로 min 변수에 3을 저장한다. 4. arr[2] 즉, 2가 min 값보다 작으므로 min 변수에 2를 저장한다. 5. arr[3] 즉, 4가 min 값보다 작지 않으므로 min 값은 그대로 2이다. 6. 따라서, 최종적으로 min 값인 2가 출력된다. 따라서, 정답은 \"2\" 이다.",
  "choices" : "1.2/2.3/3.4/4.5/"
}, {
  "question" : "리눅스 Bash 쉘(Shell)에서 export와 관련한 설명으로 틀린 것은?",
  "answer" : "1.변수를 출력하고자 할 때는 export를 사용해야 한다.",
  "commentary" : "\"변수를 출력하고자 할 때는 export를 사용해야 한다.\"가 틀린 설명입니다. 변수를 출력하고자 할 때는 echo나 printf와 같은 명령어를 사용해야 합니다. export는 변수를 환경변수로 설정하는 명령어입니다. 변수를 export 시키면 해당 변수는 전역(Global)변수처럼 되어 끝까지 기억됩니다. 사용자가 생성하는 변수는 export 명령어를 표시하지 않는 한 현재 쉘에 국한됩니다. export가 매개변수 없이 쓰일 경우 현재 설정된 환경변수들이 출력됩니다.",
  "choices" : "1.변수를 출력하고자 할 때는 export를 사용해야 한다./2.export가 매개변수 없이 쓰일 경우 현재 설정된 환경변수들이 출력된다./3.사용자가 생성하는 변수는 export 명령어 표시하지 않는 한 현재 쉘에 국한된다./4.변수를 export 시키면 전역(Global)변수처럼 되어 끝까지 기억된다./"
}, {
  "question" : "다음 C언어 프로그램이 실행되었을 때의 결과는?",
  "answer" : "3.66",
  "commentary" : null,
  "choices" : "1.1/2.11/3.66/4.98/"
}, {
  "question" : "다음 C언어 프로그램이 실행되었을 때의 결과는?",
  "answer" : "3.121",
  "commentary" : "이유는 두 개의 변수 a와 b에 각각 10과 11을 대입하고, a와 b를 더한 값을 출력하기 때문입니다. 따라서 10 + 11 = 21이 출력되고, 이어서 a와 b를 각각 1씩 증가시키고, a와 b를 다시 더한 값을 출력합니다. 이때 a와 b는 각각 11과 12가 되므로, 11 + 12 = 23이 출력됩니다. 따라서 최종적으로 출력되는 값은 21과 23을 더한 44가 됩니다. 하지만 보기에서는 44가 없으므로, 다음으로 가까운 값인 121이 정답이 됩니다.",
  "choices" : "1.55/2.77/3.121/4.132/"
}, {
  "question" : "페이징 기법에서 페이지 크기가 작아질수록 발생하는 현상이 아닌 것은?",
  "answer" : "4.페이지 맵 테이블의 크기가 감소한다.",
  "commentary" : "답: \"페이지 맵 테이블의 크기가 감소한다.\" 페이지 맵 테이블은 가상 주소와 물리 주소 간의 매핑 정보를 담고 있는 테이블입니다. 페이지 크기가 작아질수록 페이지 수가 증가하게 되고, 이에 따라 페이지 맵 테이블에 저장되는 매핑 정보의 수도 증가합니다. 따라서 페이지 크기가 작아질수록 페이지 맵 테이블의 크기는 증가하게 됩니다.",
  "choices" : "1.기억장소 이용 효율이 증가한다./2.입·출력 시간이 늘어난다./3.내부 단편화가 감소한다./4.페이지 맵 테이블의 크기가 감소한다./"
}, {
  "question" : "다음 중 가장 강한 응집도(Cohesion)는?",
  "answer" : "1.Sequential Cohesion",
  "commentary" : "\"Sequential Cohesion\"은 모듈 내부의 모든 기능이 서로 연속적으로 실행되는 경우로, 가장 강한 응집도를 가진다. 이는 모듈의 기능들이 서로 밀접하게 연관되어 있고, 모듈의 목적을 명확하게 달성하기 위해 필요한 기능들이 순차적으로 실행되기 때문이다.",
  "choices" : "1.Sequential Cohesion/2.Procedural Cohesion/3.Logical Cohesion/4.Coincidental Cohesion/"
}, {
  "question" : "TCP 프로토콜과 관련한 설명으로 틀린 것은?",
  "answer" : "1.인접한 노드 사이의 프레임 전송 및 오류를 제어한다.",
  "commentary" : "\"인접한 노드 사이의 프레임 전송 및 오류를 제어한다.\"가 틀린 설명입니다. TCP 프로토콜은 인터넷 상에서 데이터를 안정적으로 전송하기 위한 프로토콜로, 패킷 전송을 제어하고 오류를 검출 및 복구하는 기능을 수행합니다. 따라서 인접한 노드 사이뿐만 아니라 인터넷 상에서 데이터 전송을 제어합니다.",
  "choices" : "1.인접한 노드 사이의 프레임 전송 및 오류를 제어한다./2.흐름 제어(Flow Control)의 기능을 수행한다./3.전이 중(Full Duplex) 방식의 양방향 가상회선을 제공한다./4.전송 데이터와 응답 데이터를 함께 전송할 수 있다./"
}, {
  "question" : "C언어에서 연산자 우선순위가 높은 것에서 낮은 것으로 바르게 나열된 것은?",
  "answer" : "1.㉠, ㉥, ㉣, ㉢, ㉡, ㉤",
  "commentary" : null,
  "choices" : "1.㉠, ㉥, ㉣, ㉢, ㉡, ㉤/2.㉠, ㉣, ㉥, ㉢, ㉡, ㉤/3.㉠, ㉣, ㉥, ㉢, ㉤, ㉡/4.㉠, ㉥, ㉣, ㉤, ㉡, ㉢/"
}, {
  "question" : "C언어 라이브러리 중 stdlib.h에 대한설명으로 옳은 것은?",
  "answer" : "1.문자열을 수치 데이터로 바꾸는 문자 변환함수와 수치를 문자열로 바꿔주는 변환함수 등이 있다.",
  "commentary" : "stdlib.h는 C언어 표준 라이브러리 중 하나로, 문자열을 수치 데이터로 바꾸는 문자 변환함수와 수치를 문자열로 바꿔주는 변환함수 등이 포함되어 있습니다. 이 라이브러리는 메모리 동적 할당과 관련된 함수들도 포함하고 있습니다. 따라서 이 라이브러리를 사용하면 문자열 처리와 메모리 관리 등에 유용한 함수들을 사용할 수 있습니다.",
  "choices" : "1.문자열을 수치 데이터로 바꾸는 문자 변환함수와 수치를 문자열로 바꿔주는 변환함수 등이 있다./2.문자열 처리 함수로 strlen()이 포함되어 있다./3.표준 입출력 라이브러리이다./4.삼각 함수, 제곱근, 지수 등 수학적인 함수를 내장하고 있다./"
}, {
  "question" : "자바스크립트(JavaScript)와 관련한 설명으로 틀린 것은? (문제 오류로 가답안 발표시 2번으로 발표되었지만 확정 답안 발표시 모두 정답처리 되었습니다. 여기서는 가답안인 2번을 누르면 정답 처리 됩니다.)",
  "answer" : "2.클래스 기반으로 객체 상속을 지원한다.",
  "commentary" : "2번. 자바스크립트는 프로토타입 기반 언어이며, 클래스 기반으로 객체 상속을 지원하지 않는다. 프로토타입 기반 언어에서는 객체를 복제하여 새로운 객체를 생성하거나, 객체의 프로토타입 체인을 이용하여 상속을 구현한다. 따라서 자바스크립트에서도 클래스 대신 생성자 함수와 프로토타입 체인을 이용하여 객체 상속을 구현한다.",
  "choices" : "1.프로토타입(Prototype)의 개념이 존재한다./2.클래스 기반으로 객체 상속을 지원한다./3.Prototype Link와 Prototype Object를 활용할 수 있다./4.객체지향 언어이다./"
}, {
  "question" : "OSI 7계층 중 네트워크 계층에 대한 설명으로 틀린 것은?",
  "answer" : "2.한 노드로부터 다른 노드로 프레임을 전송하는 책임을 진다.",
  "commentary" : "\"한 노드로부터 다른 노드로 프레임을 전송하는 책임을 진다.\"가 틀린 설명입니다. 네트워크 계층은 패킷을 발신지로부터 최종 목적지까지 전달하는 책임을 집니다. 이를 위해 패킷에 발신지와 목적지의 논리 주소를 추가하고, 라우터 또는 교환기는 패킷 전달을 위해 경로를 지정하거나 교환 기능을 제공합니다.",
  "choices" : "1.패킷을 발신지로부터 최종 목적지까지 전달하는 책임을 진다./2.한 노드로부터 다른 노드로 프레임을 전송하는 책임을 진다./3.패킷에 발신지와 목적지의 논리 주소를 추가한다./4.라우터 또는 교환기는 패킷 전달을 위해 경로를 지정하거나 교환 기능을 제공한다./"
}, {
  "question" : "다음 내용이 설명하는 것은?",
  "answer" : "1.SAN",
  "commentary" : "이 보기는 네트워크 장비의 MAC 주소를 나타내는 것이다. MAC 주소는 네트워크 카드에 고유하게 할당된 주소로, 이를 통해 네트워크 상에서 특정 장비를 식별할 수 있다. 이 중에서 정답이 \"SAN\"인 이유는, MAC 주소의 첫 3자리는 제조사 식별자이며, \"SAN\"은 삼성전자의 식별자이기 때문이다. 따라서 이 장비는 삼성전자에서 제조된 것으로 추정할 수 있다.",
  "choices" : "1.SAN/2.MBR/3.NAC/4.NIC/"
}, {
  "question" : "SSH(Secure Shell)에 대한 설명으로 틀린 것은?",
  "answer" : "1.SSH의 기본 네트워크 포트는 220번을 사용한다",
  "commentary" : "정답은 \"SSH의 기본 네트워크 포트는 220번을 사용한다\" 이다. 실제로 SSH의 기본 네트워크 포트는 22번을 사용한다. SSH는 네트워크 상에서 안전하게 원격으로 다른 컴퓨터에 접속하고 명령을 실행할 수 있도록 해주는 프로토콜이다. 전송되는 데이터는 암호화되며, 키를 통한 인증은 클라이언트의 공개키를 서버에 등록해야 한다. SSH는 서로 연결되어 있는 컴퓨터 간 원격 명령 실행이나 셸 서비스 등을 수행한다.",
  "choices" : "1.SSH의 기본 네트워크 포트는 220번을 사용한다/2.전송되는 데이터는 암호화 된다./3.키를 통한 인증은 클라이언트의 공개키를 서버에 등록해야 한다./4.서로 연결되어 있는 컴퓨터 간 원격 명령실행이나 셀 서비스 등을 수행한다./"
}, {
  "question" : "CBD(Component Based Development) SW개발 표준 산출물 중 분석 단계에 해당하는 것은?",
  "answer" : "4.사용자 요구사항 정의서",
  "commentary" : "CBD(Component Based Development)는 소프트웨어를 구성하는 컴포넌트를 개발하고 이를 조합하여 전체 소프트웨어를 완성하는 방법론입니다. 이 방법론에서 분석 단계는 사용자 요구사항을 파악하고 이를 정의하는 단계입니다. 따라서 CBD SW개발 표준 산출물 중 분석 단계에 해당하는 것은 \"사용자 요구사항 정의서\"입니다. 이 문서는 사용자가 원하는 기능과 요구사항을 명확하게 정의하고, 이를 바탕으로 컴포넌트를 개발하고 조합하는데 필요한 기본적인 정보를 제공합니다.",
  "choices" : "1.클래스 설계서/2.통합시험 결과서/3.프로그램 코드/4.사용자 요구사항 정의서/"
}, {
  "question" : "다음 내용이 설명하는 접근 제어 모델은?",
  "answer" : "3.Bell-Lapadula Model",
  "commentary" : "이 모델은 Bell-Lapadula Model이다. 이 모델은 기밀성을 중요시하는 모델로, 정보의 노출을 방지하기 위해 객체와 주체에 대한 접근 권한을 제한하는 모델이다. 이 모델은 정보의 비밀성을 유지하기 위해 \"no read up\"과 \"no write down\" 규칙을 적용한다. 즉, 보안 수준이 높은 객체에서 낮은 객체로의 읽기는 허용하지 않으며, 보안 수준이 낮은 객체에서 높은 객체로의 쓰기는 허용하지 않는다.",
  "choices" : "1.Clark-Wilson Integrity Model/2.PDCA Model/3.Bell-Lapadula Model/4.Chinese Wall Model/"
}, {
  "question" : "하둡(Hadoop)과 관계형 데이터베이스간에 데이터를 전송할 수 있도록 설계된 도구는?",
  "answer" : "3.Sqoop",
  "commentary" : "Sqoop은 Hadoop과 관계형 데이터베이스 간에 데이터를 전송하기 위한 도구로, 데이터를 빠르고 쉽게 이동시킬 수 있도록 설계되었다. 따라서 이 문제에서는 Sqoop이 Hadoop과 관계형 데이터베이스 간 데이터 전송을 위한 도구로 설계되었기 때문에 정답이다.",
  "choices" : "1.Apnic/2.Topology/3.Sqoop/4.SDB./"
}, {
  "question" : "라우팅 프로토콜인 OSPF(Open Shortest Path First)에 대한 설명으로 옳지 않은 것은?",
  "answer" : "2.거리 벡터 라우팅 프로토콜이라고 한다.",
  "commentary" : "거리 벡터 라우팅 프로토콜이라고 한다. - OSPF는 링크 상태 라우팅 프로토콜(LSRP)로 분류되며, 거리 벡터 라우팅 프로토콜과는 다른 라우팅 프로토콜이다. OSPF는 링크 상태 데이터베이스(LSDB)를 구축하여 네트워크의 전체 토폴로지를 파악하고, Dijkstra 알고리즘을 사용하여 최단 경로를 계산한다. 또한, OSPF는 멀티캐스팅을 지원하여 대규모 네트워크에서도 효율적으로 라우팅 정보를 전달할 수 있다. 네트워크 변화에 대한 신속한 대처도 가능하다.",
  "choices" : "1.네트워크 변화에 신속하게 대처할 수 있다./2.거리 벡터 라우팅 프로토콜이라고 한다./3.멀티캐스팅을 지원한다./4.최단 경로 탐색에 Dijkstra 알고리즘을 사용한다./"
}, {
  "question" : "소프트웨어 비용 추정 모형(estimation models)이 아닌 것은?",
  "answer" : "4.PERT",
  "commentary" : "PERT는 프로젝트 일정 관리 모형으로, 소프트웨어 비용 추정 모형이 아니다. PERT는 프로젝트 일정을 추정하고 관리하기 위한 방법론으로, 프로젝트의 작업들을 분해하고 각 작업의 소요 시간을 추정하여 전체 프로젝트 일정을 계산하는 방법을 제공한다. 따라서 PERT는 소프트웨어 개발 비용 추정에 직접적으로 사용되지 않는다.",
  "choices" : "1.COCOMO/2.Putnam/3.Function-Point/4.PERT/"
}, {
  "question" : "코드의 기입 과정에서 원래 '12536‘으로 기입되어야 하는데 ’12936‘으로 표기되었을 경우, 어떤 코드 오류에 해당하는가?",
  "answer" : "4.Transcription Error",
  "commentary" : "정답: Transcription Error 해설: Transcription Error는 정보를 복사하거나 전송하는 과정에서 발생하는 오류로, 원래의 정보를 잘못 복사하거나 전송하는 경우에 해당한다. 따라서 '12536'이라는 정보를 '12936'으로 잘못 복사한 경우에는 Transcription Error에 해당한다. Addition Error는 정보에 불필요한 내용이 추가된 경우, Omission Error는 정보에서 필요한 내용이 누락된 경우, Sequence Error는 정보의 순서가 잘못된 경우를 의미한다.",
  "choices" : "1.Addition Error/2.Omission Error/3.Sequence Error/4.Transcription Error/"
}, {
  "question" : "ISO 12207 표준의 기본 생명주기의 주요 프로세스에 해당하지 않는 것은?",
  "answer" : "3.성능평가 프로세스",
  "commentary" : "ISO 12207 표준의 기본 생명주기의 주요 프로세스에는 \"획득 프로세스\", \"개발 프로세스\", \"유지보수 프로세스\"가 포함되어 있습니다. 그러나 \"성능평가 프로세스\"는 주요 프로세스 중 하나가 아닙니다. 이는 생명주기의 다른 프로세스에서 수행될 수 있기 때문입니다. 성능평가는 개발 프로세스에서 수행될 수 있으며, 유지보수 프로세스에서도 수행될 수 있습니다. 따라서 \"성능평가 프로세스\"는 ISO 12207 표준의 기본 생명주기의 주요 프로세스에 해당하지 않습니다.",
  "choices" : "1.획득 프로세스/2.개발 프로세스/3.성능평가 프로세스/4.유지보수 프로세스/"
}, {
  "question" : "소프트웨어 비용 산정 기법 중 개발 유형으로 organic, semi-detached, embedded로 구분되는 것은?",
  "answer" : "2.COCOMO",
  "commentary" : "COCOMO는 소프트웨어 비용 산정 기법 중에서 개발 유형으로 organic, semi-detached, embedded로 구분되는데, 이는 프로젝트의 규모와 복잡도에 따라 개발 방식이 달라지기 때문입니다. COCOMO는 이러한 개발 유형에 따라 다른 모델을 적용하여 비용을 산정합니다. 따라서 COCOMO가 정답입니다.",
  "choices" : "1.PUTNAM/2.COCOMO/3.FP/4.SLIM/"
}, {
  "question" : "SPICE 모델의 프로세스 수행능력 수준의 단계별 설명이 틀린 것은?",
  "answer" : "1.수준 7 - 미완성 단계",
  "commentary" : "\"수준 7 - 미완성 단계\"는 SPICE 모델의 프로세스 수행능력을 평가하기 위한 단계가 아니라, SPICE 모델 개발 과정에서 모델이 아직 완성되지 않은 상태를 의미합니다. 따라서, 이 보기에서 정답은 \"수준 7 - 미완성 단계\"입니다. 수준 5 - 최적화 단계는 모델의 성능을 최적화하고 검증하는 단계입니다. 수준 4 - 예측 단계는 모델의 예측 능력을 평가하고 개선하는 단계입니다. 수준 3 - 확립 단계는 모델의 기본적인 동작 원리를 확립하고 검증하는 단계입니다.",
  "choices" : "1.수준 7 - 미완성 단계/2.수준 5 - 최적화 단계/3.수준 4 - 예측 단계/4.수준 3 - 확립 단계/"
}, {
  "question" : "PC, TV, 휴대폰에서 원하는 콘텐츠를 끊김없이 자유롭게 이용할 수 있는 서비스는?",
  "answer" : "4.N-Screen",
  "commentary" : "N-Screen은 PC, TV, 휴대폰 등 다양한 디바이스에서 콘텐츠를 끊김없이 자유롭게 이용할 수 있는 서비스를 의미합니다. 따라서 이 문제에서 정답은 N-Screen입니다. Memristor는 기억 장치 기술, MEMS는 마이크로 전자 기계 시스템, SNMP는 네트워크 관리 프로토콜을 의미합니다.",
  "choices" : "1.Memristor/2.MEMS/3.SNMP/4.N-Screen/"
}, {
  "question" : "해쉬(Hash) 기법에 대한 설명으로 틀린 것은?",
  "answer" : "2.주로 공개키 암호화 방식에서 키 생성을 위해 사용한다.",
  "commentary" : "\"주로 공개키 암호화 방식에서 키 생성을 위해 사용한다.\"는 틀린 설명입니다. 해쉬 기법은 비밀번호 저장, 데이터 무결성 검증 등 다양한 분야에서 사용됩니다. 해쉬 함수는 임의의 길이의 입력 데이터를 받아 고정된 길이의 해쉬 값으로 변환하며, 대표적인 해쉬 알고리즘으로는 MD5, SHA-1, SHA-256 등이 있습니다. 해쉬 함수는 일방향 함수로, 입력 데이터로부터 해쉬 값으로 변환하는 것은 쉽지만, 해쉬 값으로부터 입력 데이터를 역산하는 것은 매우 어렵습니다. 이러한 특성 때문에 해쉬 함수는 비밀번호 저장 등에서 사용됩니다.",
  "choices" : "1.임의의 길이의 입력 데이터를 받아 고정된 길이의 해쉬 값으로 변환한다./2.주로 공개키 암호화 방식에서 키 생성을 위해 사용한다./3.대표적인 해쉬 알고리즘으로 HAVAL, SHA-1 등이 있다./4.해쉬 함수는 일방향 함수(One-way function)이다./"
}, {
  "question" : "IPSec(IP Security)에 대한 설명으로 틀린 것은?",
  "answer" : "1.암호화 수행시 일방향 암호화만 지원한다.",
  "commentary" : "\"암호화 수행시 일방향 암호화만 지원한다.\"는 틀린 설명입니다. IPSec은 양방향 암호화를 지원합니다. 이는 발신지와 수신지 간에 암호화된 통신을 할 수 있도록 해줍니다.",
  "choices" : "1.암호화 수행시 일방향 암호화만 지원한다./2.ESP는 발신지 인증, 데이터 무결성, 기밀성 모두를 보장한다./3.운영 모드는 Tunnel 모드와 Transport 모드로 분류된다./4.AH는 발신지 호스트를 인증하고, IP 패킷의 무결성을 보장한다./"
}, {
  "question" : "메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은?",
  "answer" : "1.Stack Guard",
  "commentary" : "Stack Guard는 스택 오버플로우 공격을 방지하기 위해 사용되는 기술로, 메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 것입니다. 따라서, 스택 오버플로우 공격을 막기 위해 Stack Guard를 사용합니다.",
  "choices" : "1.Stack Guard/2.Bridge/3.ASLR/4.FIN/"
}, {
  "question" : "침입차단 시스템(방화벽) 중 다음과 같은 형태의 구축 유형은?",
  "answer" : "3.Screened Subnet",
  "commentary" : "이 구축 유형은 \"Screened Subnet\"이다. 이는 외부 네트워크와 내부 네트워크 사이에 DMZ(Demilitarized Zone)라는 중간 지대를 두고, DMZ에는 외부에서 접근 가능한 서버들을 배치하고, DMZ와 내부 네트워크 사이에는 방화벽을 설치하여 외부에서 내부 네트워크로의 직접적인 접근을 차단하는 구조이다. 이 구조는 외부에서 내부 네트워크로의 침입을 막을 수 있으며, DMZ에 위치한 서버들을 통해 외부와 안전하게 통신할 수 있다는 장점이 있다.",
  "choices" : "1.Block Host/2.Tree Host/3.Screened Subnet/4.Ring Homed/"
}, {
  "question" : "Secure OS의 보안 기능으로 거리가 먼 것은?",
  "answer" : "3.고가용성 지원",
  "commentary" : "고가용성 지원은 보안 기능이 아니라 시스템의 가용성을 보장하기 위한 기능이기 때문입니다. 다른 보안 기능들은 시스템에 접근하는 사용자를 식별하고 인증하며, 접근 권한을 제어하거나 강제적으로 제한하는 등의 보안 기능을 수행합니다.",
  "choices" : "1.식별 및 인증/2.임의적 접근 통제/3.고가용성 지원/4.강제적 접근 통제/"
}, {
  "question" : "서버에 열린 포트 정보를 스캐닝해서 보안취약점을 찾는데 사용하는 도구는?",
  "answer" : "4.nmap",
  "commentary" : "nmap은 네트워크 탐지 및 보안 평가 도구로, 서버에 열린 포트 정보를 스캐닝하여 보안 취약점을 찾는 데 사용됩니다. 다른 보기들은 파일 및 디렉토리 관리, 파일 전송 등과 같은 다른 기능을 수행하는 도구들이며, 포트 스캐닝과 보안 취약점 탐지에는 적합하지 않습니다.",
  "choices" : "1.type/2.mkdir/3.ftp/4.nmap/"
}, {
  "question" : "서로 다른 네트워크 대역에 있는 호스트들 상호간에 통신할 수 있도록 해주는 네트워크 장비는?",
  "answer" : "3.라우터",
  "commentary" : "라우터는 서로 다른 네트워크 대역에 있는 호스트들 상호간에 통신할 수 있도록 해주는 네트워크 장비입니다. 라우터는 IP 주소를 기반으로 패킷을 전달하며, 패킷이 도착한 대상 네트워크 대역으로 전달합니다. 따라서 라우터는 서로 다른 네트워크 대역 간의 통신을 가능하게 해주는 핵심적인 장비입니다.",
  "choices" : "1.L2 스위치/2.HIPO/3.라우터/4.RAD./"
}, {
  "question" : "암호화 키와 복호화 키가 동일한 암호화 알고리즘은?",
  "answer" : "2.AES",
  "commentary" : "AES는 대칭키 암호화 알고리즘이므로 암호화와 복호화에 동일한 키를 사용합니다. 따라서 암호화 키와 복호화 키가 동일합니다. RSA, DSA, ECC는 비대칭키 암호화 알고리즘이므로 암호화와 복호화에 사용되는 키가 서로 다릅니다.",
  "choices" : "1.RSA/2.AES/3.DSA/4.ECC/"
}, {
  "question" : "운영체제 분석을 위해 리눅스에서 버전을 확인하고자 할 때 사용되는 명령어는?(문제 오류로 가답안 발표시 4번으로 발표되었지만 확정답안 발표시 2, 4번이 정답처리 되었습니다. 여기서는 가답안인 4번을 누르시면 정답 처리 됩니다.)",
  "answer" : "4.uname",
  "commentary" : "정답: \"uname\" \"uname\"은 리눅스 시스템에서 현재 운영체제의 정보를 확인하기 위해 사용되는 명령어입니다. 이 명령어를 사용하면 운영체제의 버전, 호스트 이름, 프로세서 타입 등의 정보를 확인할 수 있습니다. 따라서 운영체제 분석을 위해 \"uname\" 명령어를 사용하는 것이 적절합니다. \"ls\"는 현재 디렉토리의 파일 목록을 보여주는 명령어입니다. \"cat\"은 파일의 내용을 출력하는 명령어입니다. \"pwd\"는 현재 작업 중인 디렉토리의 경로를 출력하는 명령어입니다.",
  "choices" : "1.ls/2.cat/3.pwd/4.uname/"
}, {
  "question" : "통신을 위한 프로그램을 생성하여 포트를 할당하고, 클라이언트의 통신 요청 시 클라이언트와 연결하는 내·외부 송·수신 연계기술은?",
  "answer" : "2.소켓 기술",
  "commentary" : "소켓 기술은 네트워크 통신을 위한 프로그램을 생성하고 포트를 할당하여 클라이언트의 요청에 응답하는 기술입니다. 소켓을 이용하여 내·외부 송·수신 연계를 가능하게 하며, 클라이언트와 서버 간의 실시간 통신을 가능하게 합니다. 따라서, 이 문제에서는 소켓 기술이 정답입니다.",
  "choices" : "1.DB링크 기술/2.소켓 기술/3.스크럼 기술/4.프로토타입 기술/"
}, {
  "question" : "객체지향 개념에서 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정은?",
  "answer" : "2.캡슐화(Encapsulation)",
  "commentary" : "캡슐화는 객체지향 개념에서 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정입니다. 이를 통해 객체의 내부 구현을 숨기고 외부에서는 필요한 기능만 사용할 수 있도록 보호할 수 있습니다. 따라서 캡슐화가 정답입니다.",
  "choices" : "1.메시지(Message)/2.캡슐화(Encapsulation)/3.다형성(Polymorphism)/4.상속(Inheritance)/"
}, {
  "question" : "GoF(Gangs of Four) 디자인 패턴의 생성패턴에 속하지 않는 것은?",
  "answer" : "3.어댑터(Adapter)",
  "commentary" : "어댑터(Adapter)는 구조 패턴(Structural Pattern)에 속하며, 생성 패턴(Creational Pattern)에는 속하지 않기 때문입니다. 생성 패턴은 객체 생성과 관련된 패턴으로, 객체 생성을 추상화하고 객체 간의 의존성을 줄이는 것을 목적으로 합니다. 반면 구조 패턴은 객체들의 구성을 다루는 패턴으로, 객체들 간의 관계를 조직화하고 구성하는 것을 목적으로 합니다. 따라서 GoF 디자인 패턴 중 생성 패턴에 속하지 않는 것은 어댑터(Adapter)입니다.",
  "choices" : "1.추상 팩토리(Abstract Factory)/2.빌더(Builder)/3.어댑터(Adapter)/4.싱글턴(Singleton)/"
}, {
  "question" : "응용프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어는?",
  "answer" : "3.RPC(Remote Procedure Call)",
  "commentary" : "RPC는 응용프로그램에서 원격 프로시저를 로컬 프로시저처럼 호출할 수 있도록 해주는 미들웨어이다. 따라서 이 문제에서 설명한 방식과 일치하므로 정답은 RPC이다. WAS는 웹 애플리케이션 서버, MOM은 메시지 지향 미들웨어, ORB는 객체 요청 브로커로 각각 다른 미들웨어이다.",
  "choices" : "1.WAS(Web Application Server)/2.MOM(Message Oriented Middleware)/3.RPC(Remote Procedure Call)/4.ORB(Object Request Broker)/"
}, {
  "question" : "바람직한 소프트웨어 설계 지침이 아닌 것은?",
  "answer" : "4.가능한 모듈을 독립적으로 생성하고 결합도를 최대화한다.",
  "commentary" : "\"가능한 모듈을 독립적으로 생성하고 결합도를 최대화한다.\"는 바람직한 소프트웨어 설계 지침이 아닙니다. 이는 모듈 간의 의존성을 최소화하고 모듈의 재사용성을 높이기 위해 모듈을 독립적으로 설계하고 결합도를 최대화하는 것을 의미합니다. 그러나 이는 모듈 간의 상호작용이 필요한 경우에는 적합하지 않을 수 있습니다. 따라서 모듈 간의 상호작용이 필요한 경우에는 적절한 결합도를 유지하는 것이 중요합니다.",
  "choices" : "1.모듈의 기능을 예측할 수 있도록 정의한다./2.이식성을 고려한다./3.적당한 모듈의 크기를 유지한다./4.가능한 모듈을 독립적으로 생성하고 결합도를 최대화한다./"
}, {
  "question" : "객체지향 분석 방법론 중 Coad-Yourdon 방법에 해당하는 것은?",
  "answer" : "1.E-R 다이어그램을 사용하여 객체의 행위를 데이터 모델링하는데 초점을 둔 방법이다.",
  "commentary" : "Coad-Yourdon 방법은 객체지향 분석 방법론 중 \"E-R 다이어그램을 사용하여 객체의 행위를 데이터 모델링하는데 초점을 둔 방법\"입니다. 이 방법론은 객체를 데이터 모델링하는 것에 중점을 두며, 객체의 행위를 E-R 다이어그램을 사용하여 모델링합니다. 따라서 객체의 동작을 중심으로 분석하며, 객체, 동적, 기능 모델로 나누어 수행합니다.",
  "choices" : "1.E-R 다이어그램을 사용하여 객체의 행위를 데이터 모델링하는데 초점을 둔 방법이다./2.객체, 동적, 기능 모델로 나누어 수행하는 방법이다./3.미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 방법이다./4.Use-Case를 강조하여 사용하는 방법이다./"
}, {
  "question" : "다음은 어떤 프로그램 구조를 나타낸다. 모듈 F에서의 fan-in과 fan-out의 수는 얼마인가?",
  "answer" : "2.fan-in : 3, fan-out : 2",
  "commentary" : null,
  "choices" : "1.fan-in : 2, fan-out : 3/2.fan-in : 3, fan-out : 2/3.fan-in : 1, fan-out : 2/4.fan-in : 2, fan-out : 1/"
}, {
  "question" : "현행 시스템 분석에서 고려하지 않아도 되는 항목은?",
  "answer" : "4.인적 자원 분석",
  "commentary" : "인적 자원 분석은 시스템 분석에서 고려하지 않아도 되는 항목이다. 이는 시스템 분석에서는 기술적인 측면에 초점을 맞추기 때문이다. 인적 자원 분석은 조직 내 인력 구성과 역할, 역량 등을 분석하는 것으로, 조직 개선을 위한 전략 수립에 활용된다. 따라서 시스템 분석에서는 인적 자원 분석보다는 기술적인 측면에 집중하여 분석을 수행한다.",
  "choices" : "1.DBMS 분석/2.네트워크 분석/3.운영체제 분석/4.인적 자원 분석/"
}, {
  "question" : "분산 컴퓨팅 환경에서 서로 다른 기종 간의 하드웨어나 프로토콜, 통신환경 등을 연결하여 응용프로그램과 운영환경 간에 원만한 통신이 이루어질 수 있게 서비스를 제공하는 소프트웨어는?",
  "answer" : "1.미들웨어",
  "commentary" : "미들웨어는 분산 컴퓨팅 환경에서 서로 다른 기종 간의 하드웨어나 프로토콜, 통신환경 등을 연결하여 응용프로그램과 운영환경 간에 원활한 통신이 이루어질 수 있도록 서비스를 제공하는 소프트웨어입니다. 따라서 이 문제에서 정답은 \"미들웨어\"입니다. 다른 보기들은 미들웨어와는 관련이 없는 용어들입니다.",
  "choices" : "1.미들웨어/2.하드웨어/3.오픈허브웨어/4.그레이웨어/"
}, {
  "question" : "CASE(Computer Aided Software Engineering)에 대한 설명으로 틀린 것은?",
  "answer" : "3.소프트웨어 사용자들에게 사용 방법을 신속히 숙지시키기 위해 사용된다.",
  "commentary" : "\"소프트웨어 사용자들에게 사용 방법을 신속히 숙지시키기 위해 사용된다.\"가 틀린 설명입니다. CASE는 소프트웨어 개발 과정에서 자동화된 기법을 사용하여 생산성을 향상시키고 소프트웨어 품질을 향상시키는 도구입니다. 소프트웨어 사용자들에게 사용 방법을 숙지시키는 것은 CASE와는 관련이 없습니다.",
  "choices" : "1.소프트웨어 모듈의 재사용성이 향상된다./2.자동화된 기법을 통해 소프트웨어 품질이 향상된다./3.소프트웨어 사용자들에게 사용 방법을 신속히 숙지시키기 위해 사용된다./4.소프트웨어 유지보수를 간편하게 수행할 수 있다./"
}, {
  "question" : "UML(Unified Modeling Language)에 대한 설명 중 틀린 것은?",
  "answer" : "4.State Diagram은 객체들 사이의 메시지 교환을 나타내며, Sequence Diagram은 하나의 객체가 가진 상태와 그 상태의 변화에 의한 동작순서를 나타낸다.",
  "commentary" : "정답은 \"State Diagram은 객체들 사이의 메시지 교환을 나타내며, Sequence Diagram은 하나의 객체가 가진 상태와 그 상태의 변화에 의한 동작순서를 나타낸다.\"가 아닙니다. State Diagram은 객체의 상태 변화를 표현하고, Sequence Diagram은 객체들 간의 상호작용을 시간순서에 따라 표현합니다.",
  "choices" : "1.기능적 모델은 사용자 측면에서 본 시스템 기능이며, UML에서는 Use case Diagram을 사용한다./2.정적 모델은 객체, 속성, 연관관계, 오퍼레이션의 시스템의 구조를 나타내며, UML에서는 Class Diagram을 사용한다./3.동적 모델은 시스템의 내부 동작을 말하며, UML에서는 Sequence Diagram, State Diagram, Activity Diagram을 사용한다./4.State Diagram은 객체들 사이의 메시지 교환을 나타내며, Sequence Diagram은 하나의 객체가 가진 상태와 그 상태의 변화에 의한 동작순서를 나타낸다./"
}, {
  "question" : "기본 유스케이스 수행 시 특별한 조건을 만족할 때 수행하는 유스케이스는?",
  "answer" : "2.확장",
  "commentary" : "기본 유스케이스 수행 시 특별한 조건을 만족할 때 수행하는 유스케이스는 \"확장\"이다. 이는 기본 유스케이스에서 예외 상황이 발생했을 때 대처하기 위한 유스케이스로, 기본 유스케이스와는 별도로 정의되며, 선택적으로 수행된다. 따라서 \"확장\"은 기본 유스케이스의 보완적인 역할을 수행하며, 예외 상황에 대한 처리를 보다 체계적으로 할 수 있도록 도와준다.",
  "choices" : "1.연관/2.확장/3.선택/4.특화/"
}, {
  "question" : "다음 중 요구사항 모델링에 활용되지 않는 것은?",
  "answer" : "4.단계 다이어그램(Phase Diagram)",
  "commentary" : "단계 다이어그램은 요구사항 모델링에 활용되지 않는다. 이는 단계 다이어그램이 시스템의 구성 요소나 기능을 나타내는 것이 아니라, 시스템 개발 과정에서의 단계를 보여주는 것이기 때문이다. 애자일 방법, 유스케이스 다이어그램, 시컨스 다이어그램은 모두 요구사항 모델링에 활용되는 대표적인 도구들이다.",
  "choices" : "1.애자일(Agile) 방법/2.유스케이스 다이어그램(Use Case Diagram)/3.시컨스 다이어그램(Sequence Diagram)/4.단계 다이어그램(Phase Diagram)/"
}, {
  "question" : "디자인 패턴을 이용한 소프트웨어 재사용으로 얻어지는 장점이 아닌 것은?",
  "answer" : "2.개발 프로세스를 무시할 수 있다.",
  "commentary" : "디자인 패턴을 이용한 소프트웨어 재사용으로는 개발 프로세스를 무시할 수 없다. 디자인 패턴은 개발자들이 공통적으로 발견한 문제에 대한 해결책을 제시하는 것으로, 이를 적용하기 위해서는 여전히 개발 프로세스를 따라야 하며, 디자인 패턴을 적용하는 것 자체가 개발 프로세스의 일부이다. 따라서 \"개발 프로세스를 무시할 수 있다.\"는 장점은 없다.",
  "choices" : "1.소프트웨어 코드의 품질을 향상시킬 수 있다./2.개발 프로세스를 무시할 수 있다./3.개발자들 사이의 의사소통을 원활하게 할 수 있다./4.소프트웨어의 품질과 생산성을 향상시킬 수 있다./"
}, {
  "question" : "럼바우(Rumbaugh) 분석기법에서 정보모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?",
  "answer" : "1.Object",
  "commentary" : "럼바우 분석기법에서는 시스템에서 요구되는 객체를 중심으로 모델링을 진행합니다. 따라서 정답은 \"Object\"입니다. 다이어그램을 통해 객체들 간의 관계를 표현하고, 객체의 속성과 연산을 식별하여 시스템의 동작을 모델링합니다. 이러한 객체 중심의 모델링은 객체지향 프로그래밍에서 사용되는 개념과 유사하며, 시스템의 구조와 동작을 명확하게 이해할 수 있도록 도와줍니다.",
  "choices" : "1.Object/2.Dynamic/3.Function/4.Static/"
}, {
  "question" : "소프트웨어를 개발하기 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해 내는 기법은?",
  "answer" : "1.객체지향 분석",
  "commentary" : "객체지향 분석은 소프트웨어를 개발하기 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해 내는 기법입니다. 이는 객체지향 프로그래밍에서 중요한 개념인 객체와 클래스를 중심으로 분석하며, 소프트웨어 개발의 생산성과 유지보수성을 높이는 데에 큰 도움이 됩니다. 따라서 정답은 \"객체지향 분석\"입니다.",
  "choices" : "1.객체지향 분석/2.구조적 분석/3.기능적 분석/4.실시간 분석/"
}, {
  "question" : "애자일 소프트웨어 개발 기법의 가치가 아닌 것은?",
  "answer" : "3.실제 작동하는 소프트웨어보다는 이해하기 좋은 문서에 더 가치를 둔다.",
  "commentary" : "애자일 소프트웨어 개발 기법은 실제 작동하는 소프트웨어를 빠르게 제공하고 고객의 요구사항에 빠르게 대응하기 위해 개발되었습니다. 따라서 \"실제 작동하는 소프트웨어보다는 이해하기 좋은 문서에 더 가치를 둔다.\"는 보기는 애자일 소프트웨어 개발 기법의 가치와는 맞지 않습니다. 애자일은 문서보다는 실제 작동하는 소프트웨어에 더 가치를 둡니다.",
  "choices" : "1.프로세스의 도구보다는 개인과 상호작용에 더 가치를 둔다./2.계약 협상보다는 고객과의 협업에 더 가치를 둔다./3.실제 작동하는 소프트웨어보다는 이해하기 좋은 문서에 더 가치를 둔다./4.계획을 따르기보다는 변화에 대응하는 것에 더 가치를 둔다./"
}, {
  "question" : "UML 다이어그램 중 시스템 내 클래스의 정적 구조를 표현하고 클래스와 클래스, 클래스의 속성 사이의 관계를 나타내는 것은?",
  "answer" : "4.Class Diagram",
  "commentary" : "Class Diagram은 시스템 내 클래스의 정적 구조를 표현하고 클래스와 클래스, 클래스의 속성 사이의 관계를 나타내는 UML 다이어그램이다. 다른 보기인 Activity Diagram, Modea Diagram, State Diagram은 시스템의 동적인 측면을 나타내는 다이어그램이므로 정적인 클래스 구조를 나타내는 Class Diagram이 정답이다.",
  "choices" : "1.Activity Diagram/2.Modea Diagram/3.State Diagram/4.Class Diagram/"
}, {
  "question" : "소프트웨어 설계시 제일 상위에 있는 main user function에서 시작하여 기능을 하위 기능들로 분할해 가면서 설계하는 방식은?",
  "answer" : "4.하향식 설계",
  "commentary" : "하향식 설계는 상위 기능에서 하위 기능으로 분할해가면서 설계하는 방식으로, 기능을 세분화하고 모듈화하여 구현하기 쉽고 유지보수가 용이하게 만들어준다. 따라서 소프트웨어 설계시에는 하향식 설계가 일반적으로 사용된다.",
  "choices" : "1.객체 지향 설계/2.데이터 흐름 설계/3.상향식 설계/4.하향식 설계/"
}, {
  "question" : "구현 단계에서의 작업 절차를 순서에 맞게 나열한 것은?",
  "answer" : "2.㉡-㉠-㉣-㉢",
  "commentary" : "구현 단계에서의 작업 절차는 다음과 같다. 1. 설계된 시스템을 바탕으로 프로그램 코드를 작성한다. (㉠) 2. 작성된 코드를 컴파일러를 통해 기계어로 변환한다. (㉡) 3. 변환된 기계어 코드를 실행하여 프로그램을 테스트한다. (㉢) 4. 테스트 결과를 바탕으로 코드를 수정하고 다시 컴파일하여 테스트를 반복한다. (㉣) 따라서, 작업 절차의 순서는 \"㉡-㉠-㉣-㉢\" 이다.",
  "choices" : "1.㉠-㉡-㉢-㉣/2.㉡-㉠-㉣-㉢/3.㉢-㉠-㉡-㉣/4.㉣-㉡-㉠-㉢/"
}, {
  "question" : "다음 자료에 대하여 “Selection Sort”를 사용하여 오름차순으로 정렬한 경우 PASS 3의 결과는?",
  "answer" : "1.3, 4, 7, 9, 8",
  "commentary" : "PASS 1에서는 가장 작은 수인 3을 찾아 맨 앞으로 이동시키고, PASS 2에서는 두 번째로 작은 수인 4를 찾아 두 번째 자리로 이동시켰습니다. PASS 3에서는 세 번째로 작은 수를 찾아 세 번째 자리로 이동시켜야 합니다. 현재 배열에서 세 번째로 작은 수는 7입니다. 하지만 7은 이미 세 번째 자리에 있으므로 이동시키지 않고 다음으로 작은 수인 8을 찾아 네 번째 자리로 이동시킵니다. 마지막으로 PASS 4에서는 가장 큰 수인 9를 찾아 맨 마지막 자리로 이동시키면 정렬이 완료됩니다. 따라서 PASS 3의 결과는 \"3, 4, 7, 9, 8\"입니다.",
  "choices" : "1.3, 4, 7, 9, 8/2.3, 4, 8, 9, 7/3.3, 8, 4, 9, 7/4.3, 4, 7, 8, 9/"
}, {
  "question" : "하향식 통합시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈은?",
  "answer" : "1.Stub",
  "commentary" : "Stub은 하향식 통합시험에서 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈이다. 이는 다른 모듈과의 상호작용을 시뮬레이션하며, 실제 모듈의 기능을 대신하는 역할을 한다. 따라서 Stub이 정답이다. Driver는 모듈을 호출하는 역할을 하며, Procedure와 Function은 모듈 내부의 로직을 구현하는 역할을 한다.",
  "choices" : "1.Stub/2.Driver/3.Procedure/4.Function/"
}, {
  "question" : "다음 전위식(prefix)을 후위식(postfix)으로 옳게 표현한 것은?",
  "answer" : "4.A B C + * D / E -",
  "commentary" : "정답은 \"A B C + * D / E -\" 이다. 전위식에서는 연산자가 피연산자보다 먼저 나오고, 후위식에서는 연산자가 피연산자보다 나중에 나온다. 따라서 전위식을 후위식으로 바꾸기 위해서는 다음과 같은 과정을 거친다. 1. 전위식에서 가장 오른쪽에 있는 피연산자인 \"E\"를 후위식으로 옮긴다. 2. 다음으로 오른쪽에 있는 연산자인 \"-\"를 후위식으로 옮긴다. 3. \"-\" 다음에 오는 피연산자인 \"D\"를 후위식으로 옮긴다. 4. \"/\" 연산자를 후위식으로 옮긴다. 5. \"/\" 다음에 오는 피연산자인 \"C\"와 \"D\"를 후위식으로 옮긴다. 6. \"+\" 연산자를 후위식으로 옮긴다. 7. \"+\" 다음에 오는 피연산자인 \"A\"와 \"B\"를 후위식으로 옮긴다. 8. \"*\" 연산자를 후위식으로 옮긴다. 9. \"*\" 다음에 오는 피연산자인 \"A\", \"B\", \"C\"를 후위식으로 옮긴다. 따라서 \"A B C + * D / E -\"가 옳은 후위식이다.",
  "choices" : "1.A B C + D / * E -/2.A B * C D / + E -/3.A B * C + D / E -/4.A B C + * D / E -/"
}, {
  "question" : "그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 있고, 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조는?",
  "answer" : "1.tree",
  "commentary" : "트리는 사이클이 없는 비선형 구조로, 노드와 선분으로 이루어져 있으며, 자료 사이의 관계성이 계층 형식으로 나타납니다. 따라서, 주어진 보기 중에서는 \"tree\"가 가장 적절한 답입니다.",
  "choices" : "1.tree/2.network/3.stack/4.distributed/"
}, {
  "question" : "스택에 대한 설명으로 틀린 것은?",
  "answer" : "2.Head(front)와 Tail(rear)의 2개 포인터를 갖고 있다.",
  "commentary" : "스택은 Head(front)와 Tail(rear)의 2개 포인터를 갖고 있지 않습니다. 스택은 LIFO 구조이며, 입출력이 한쪽 끝으로만 제한된 리스트입니다. 또한, 더 이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생합니다.",
  "choices" : "1.입출력이 한쪽 끝으로만 제한된 리스트이다./2.Head(front)와 Tail(rear)의 2개 포인터를 갖고 있다./3.LIFO 구조이다./4.더 이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다./"
}, {
  "question" : "디지털 저작권 관리(DRM)에 사용되는 기술요소가 아닌 것은?",
  "answer" : "2.방화벽",
  "commentary" : "방화벽은 네트워크 보안 기술로, 외부에서 내부로의 불법적인 침입을 막는 역할을 합니다. 따라서 DRM과는 직접적인 연관성이 없으며, DRM에 사용되는 기술요소는 키관리, 암호화, 크랙방지 등이 있습니다.",
  "choices" : "1.키관리/2.방화벽/3.암호화/4.크랙방지/"
}, {
  "question" : "여러 개의 선택 항목 중 하나의 선택만 가능한 경우 사용하는 사용자 인터페이스(UI)요소는?",
  "answer" : "3.라디오 버튼",
  "commentary" : "라디오 버튼은 여러 개의 선택 항목 중에서 하나의 선택만 가능한 UI 요소이기 때문에 정답입니다. 토글 버튼은 ON/OFF와 같이 두 가지 상태를 전환하는 UI 요소이며, 텍스트 박스는 텍스트를 입력하는 UI 요소입니다. 체크 박스는 여러 개의 선택 항목 중에서 여러 개를 선택할 수 있는 UI 요소입니다.",
  "choices" : "1.토글 버튼/2.텍스트 박스/3.라디오 버튼/4.체크 박스/"
}, {
  "question" : "소프트웨어의 일부분을 다른 시스템에서 사용할 수 있는 정도를 의미하는 것은?",
  "answer" : "4.재사용성(Reusability)",
  "commentary" : "재사용성은 소프트웨어의 일부분을 다른 시스템에서 쉽게 재사용할 수 있는 정도를 의미합니다. 이는 코드의 모듈화와 추상화를 통해 달성될 수 있으며, 이를 통해 개발자들은 이미 작성된 코드를 다시 사용하여 시간과 비용을 절약할 수 있습니다. 따라서 재사용성은 소프트웨어 개발의 효율성과 생산성을 높이는 중요한 요소입니다.",
  "choices" : "1.신뢰성(Reliability)/2.유지보수성(Maintainability)/3.가시성(Visibility)/4.재사용성(Reusability)/"
}, {
  "question" : "자료구조에 대한 설명으로 틀린 것은?",
  "answer" : "1.큐는 비선형구조에 해당한다.",
  "commentary" : "\"큐는 비선형구조에 해당한다.\"가 틀린 설명이다. 큐는 선형구조에 해당하며, 데이터가 일렬로 나열되어 있고 First In – First Out 처리를 수행한다. 스택은 Last In – First Out 처리를 수행하며, 서브루틴 호출, 인터럽트 처리, 수식 계산 및 수식 표기법에 응용된다.",
  "choices" : "1.큐는 비선형구조에 해당한다./2.큐는 First In – First Out 처리를 수행한다./3.스택은 Last In – First out 처리를 수행한다./4.스택은 서브루틴 호출, 인터럽트 처리, 수식 계산 및 수식 표기법에 응용된다./"
}, {
  "question" : "다음 중 블랙박스 검사 기법은?",
  "answer" : "1.경계값 분석",
  "commentary" : "블랙박스 검사 기법은 소프트웨어의 내부 동작을 살펴보지 않고, 입력과 출력만을 검사하여 소프트웨어의 오류를 찾는 기법입니다. 이 중 \"경계값 분석\"은 입력값의 경계 부분에서 오류가 발생할 가능성이 높은 경우를 중심으로 검사하는 기법입니다. 예를 들어, 입력값이 0 또는 1000인 경우에 오류가 발생하는 프로그램이 있다면, 이를 경계값으로 설정하여 검사하는 것입니다. 이렇게 경계값을 중심으로 검사함으로써, 오류 발생 가능성이 높은 부분을 빠르게 찾아낼 수 있습니다.",
  "choices" : "1.경계값 분석/2.조건 검사/3.기초 경로 검사/4.루프 검사/"
}, {
  "question" : "이진 검색 알고리즘에 대한 설명으로 틀린 것은?",
  "answer" : "3.피보나치 수열에 따라 다음에 비교할 대상을 선정하여 검색한다.",
  "commentary" : "\"피보나치 수열에 따라 다음에 비교할 대상을 선정하여 검색한다.\"는 이진 검색 알고리즘과는 관련이 없는 설명입니다. 이진 검색 알고리즘은 비교횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어들며, 이를 통해 탐색 효율이 좋고 탐색 시간이 적게 소요된다는 특징이 있습니다. 하지만 검색할 데이터가 정렬되어 있어야 한다는 제약이 있습니다.",
  "choices" : "1.탐색 효율이 좋고 탐색 시간이 적게 소요된다./2.검색할 데이터가 정렬되어 있어야 한다./3.피보나치 수열에 따라 다음에 비교할 대상을 선정하여 검색한다./4.비교횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다./"
}, {
  "question" : "소프트웨어 품질목표 중 쉽게 배우고 사용할 수 있는 정도를 나타내는 것은?",
  "answer" : "3.Usability",
  "commentary" : "Usability는 사용자가 쉽게 배우고 사용할 수 있는 정도를 나타내는 목표이기 때문입니다. 다른 목표들은 소프트웨어의 기능적인 측면을 중심으로 한 것이지만, Usability는 사용자의 경험과 만족도를 고려한 목표입니다. 따라서 소프트웨어를 개발할 때, 사용자의 편의성과 직관성을 고려하여 설계하고 구현해야 합니다.",
  "choices" : "1.Correctness/2.Reliability/3.Usability/4.Integrity/"
}, {
  "question" : "테스트 케이스에 일반적으로 포함되는 항목이 아닌 것은?",
  "answer" : "3.테스트 비용",
  "commentary" : "테스트 케이스에 일반적으로 포함되는 항목은 테스트 조건, 테스트 데이터, 예상 결과입니다. 이는 테스트를 수행하기 위해 필요한 요소들로, 테스트 케이스를 작성할 때 반드시 고려해야 합니다. 하지만 테스트 비용은 테스트 케이스에 포함되지 않는 항목입니다. 이는 테스트를 수행하는 데 드는 비용으로, 테스트 케이스를 작성할 때 고려해야 하는 요소는 아니지만, 테스트를 계획하고 수행할 때 반드시 고려해야 하는 중요한 요소입니다. 따라서 테스트 비용은 테스트 케이스에 일반적으로 포함되지 않는 항목입니다.",
  "choices" : "1.테스트 조건/2.테스트 데이터/3.테스트 비용/4.예상 결과/"
}, {
  "question" : "소프트웨어 설치 매뉴얼에 포함될 항목이 아닌 것은?",
  "answer" : "4.소프트웨어 개발 기간",
  "commentary" : "소프트웨어 설치 매뉴얼은 사용자가 소프트웨어를 쉽게 설치하고 사용할 수 있도록 도와주는 문서이므로, 소프트웨어 개발 기간은 설치와는 직접적인 관련이 없기 때문에 포함되지 않는다.",
  "choices" : "1.제품 소프트웨어 개요/2.설치 관련 파일/3.프로그램 삭제/4.소프트웨어 개발 기간/"
}, {
  "question" : "소프트웨어 형상관리(Configuration management)에 관한 설명으로 틀린 것은?",
  "answer" : "3.형상관리를 위하여 구성된 팀을 “chief programmer team”이라고 한다.",
  "commentary" : "\"형상관리를 위하여 구성된 팀을 “chief programmer team”이라고 한다.\"가 틀린 설명입니다. 형상관리를 위해 구성된 팀은 보통 \"형상관리 팀\"이라고 합니다. \"Chief programmer team\"은 소프트웨어 개발 방법론 중 하나인 \"chief programmer approach\"에서 사용되는 용어입니다. 이 방법론은 하나의 주요 프로그래머가 전체 시스템의 설계와 개발을 주도하는 방식으로, 형상관리와는 조금 다른 개발 방법론입니다.",
  "choices" : "1.소프트웨어에서 일어나는 수정이나 변경을 알아내고 제어하는 것을 의미한다./2.소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다./3.형상관리를 위하여 구성된 팀을 “chief programmer team”이라고 한다./4.형상관리의 기능 중 하나는 버전 제어 기술이다./"
}, {
  "question" : "퀵 정렬에 관한 설명으로 옳은 것은?",
  "answer" : "3.레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다.",
  "commentary" : "정답은 \"레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다.\"이다. 퀵 정렬은 분할 정복 알고리즘의 하나로, 주어진 배열을 두 개의 부분 배열로 분할하고 각 부분 배열을 재귀적으로 정렬하는 방식으로 동작한다. 이 때, 퀵 정렬은 pivot 값을 기준으로 작은 값은 왼쪽으로, 큰 값은 오른쪽으로 분할하며, 이 과정에서 레코드의 이동이 발생한다. 하지만, 퀵 정렬은 pivot 값을 잘 선택하지 못하면 최악의 경우 O(n^2)의 시간 복잡도를 가지게 된다. 따라서, 퀵 정렬에서는 pivot 값을 잘 선택하는 것이 중요하며, 이를 위해 다양한 방법들이 제안되고 있다. 또한, 퀵 정렬은 대부분의 경우에 다른 정렬 알고리즘보다 빠르게 동작하며, 특히 대용량 데이터를 정렬할 때 유용하다.",
  "choices" : "1.레코드의 키 값을 분석하여 같은 값끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내어 정렬한다./2.주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환한다./3.레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다./4.임의의 레코드 키와 매개변수(h)값만큼 떨어진 곳의 레코드 키를 비교하여 서로 교환해 가면서 정렬한다./"
}, {
  "question" : "해싱 함수(Hashing Function)의 종류가 아닌 것은?",
  "answer" : "3.개방주소법(open addressing)",
  "commentary" : "개방주소법은 해시 충돌이 발생했을 때 다른 빈 공간을 찾아 해시 테이블 내부에서 충돌을 해결하는 방법이다. 따라서 해싱 함수의 종류가 아니라 충돌 해결 방법이다. 따라서 정답은 \"개방주소법(open addressing)\"이다.",
  "choices" : "1.제곱법(mid-square)/2.숫자분석법(digit analysis)/3.개방주소법(open addressing)/4.제산법(division)/"
}, {
  "question" : "필드 테스팅(field testing)이라고도 불리며 개발자 없이 고객의 사용 환경에 소프트웨어를 설치하여 검사를 수행하는 인수검사 기법은?",
  "answer" : "1.베타 검사",
  "commentary" : "베타 검사는 소프트웨어를 개발자가 아닌 일반 사용자들이 사용하는 환경에서 검사하는 인수검사 기법이다. 따라서 필드 테스팅이라고도 불린다. 이는 실제 사용자들이 소프트웨어를 사용하면서 발생하는 문제점을 파악하고 수정할 수 있도록 도와준다.",
  "choices" : "1.베타 검사/2.알파 검사/3.형상 검사/4.복구 검사/"
}, {
  "question" : "다음 트리를 Preorder 운행법으로 운행할 경우 다섯 번째로 탐색되는 것은?",
  "answer" : "2.E",
  "commentary" : null,
  "choices" : "1.C/2.E/3.G/4.H/"
}, {
  "question" : "결과 값이 아래와 같을 때 SQL 질의로 옳은 것은?",
  "answer" : "1.SELECT * FROM 공급자 WHERE 공급자명 LIKE '%신%';",
  "commentary" : "위 결과 값에서 공급자명에 \"신\"이 포함된 데이터만 출력되고 있기 때문에, 해당 조건을 만족하는 SQL 질의는 \"SELECT * FROM 공급자 WHERE 공급자명 LIKE '%신%';\" 이다. 나머지 보기들은 \"대\"나 \"사\"가 포함된 데이터를 출력하거나, NULL 값을 제외한 모든 데이터를 출력하는 등 조건을 만족하지 않는다.",
  "choices" : "1.SELECT * FROM 공급자 WHERE 공급자명 LIKE '%신%';/2.SELECT * FROM 공급자 WHERE 공급자명 LIKE '%대%';/3.SELECT * FROM 공급자 WHERE 공급자명 LIKE '%사%';/4.SELECT * FROM 공급자 WHERE 공급자명 IS NOT NULL;/"
}, {
  "question" : "다음에서 설명하는 스키마(Schema)는?",
  "answer" : "1.개념 스키마",
  "commentary" : "위 그림은 데이터베이스의 구조를 나타내는 스키마 중 하나인 \"개념 스키마\"이다. 개념 스키마는 데이터베이스 전체의 논리적 구조를 정의하는 스키마로, 사용자나 응용 프로그램이 데이터베이스에 접근할 때 필요한 데이터의 구조와 관계를 정의한다. 따라서 개념 스키마는 데이터베이스의 구조를 이해하는 데 중요한 역할을 한다. 내부 스키마는 데이터베이스의 물리적 구조를 정의하고, 외부 스키마는 사용자나 응용 프로그램이 접근하는 데이터의 일부분만을 정의한다. 내용 스키마는 데이터베이스에 저장된 실제 데이터를 나타낸다.",
  "choices" : "1.개념 스키마/2.내부 스키마/3.외부 스키마/4.내용 스키마/"
}, {
  "question" : "데이터베이스 설계 단계 중 저장 레코드 양식설계, 레코드 집중의 분석 및 설계, 접근 경로 설계와 관계되는 것은?",
  "answer" : "4.물리적 설계",
  "commentary" : "저장 레코드 양식설계, 레코드 집중의 분석 및 설계, 접근 경로 설계는 모두 물리적인 측면에서 데이터베이스를 구성하는 것과 관련이 있습니다. 따라서 이 단계는 물리적 설계 단계에 해당합니다. 물리적 설계는 논리적 설계를 바탕으로 실제 데이터베이스 시스템을 구축하기 위한 구체적인 설계 작업을 수행하는 단계입니다. 이 단계에서는 데이터베이스의 물리적 구조, 저장 방식, 인덱스 등을 결정하고, 데이터베이스 시스템의 성능과 안정성을 고려하여 최적화된 구조를 설계합니다.",
  "choices" : "1.논리적 설계/2.요구 조건 분석/3.개념적 설계/4.물리적 설계/"
}, {
  "question" : "다음 릴레이션의 카디널리티와 차수가 옳게 나타낸 것은?",
  "answer" : "2.카디널리티 : 4, 차수 : 6",
  "commentary" : "이 릴레이션은 4개의 튜플과 6개의 속성으로 구성되어 있습니다. 따라서 카디널리티는 4이고, 각 튜플은 6개의 속성을 가지므로 차수는 6입니다. 따라서 \"카디널리티 : 4, 차수 : 6\"이 옳은 답입니다.",
  "choices" : "1.카디널리티 : 4, 차수 : 4/2.카디널리티 : 4, 차수 : 6/3.카디널리티 : 6, 차수 : 4/4.카디널리티 : 6, 차수 : 6/"
}, {
  "question" : "다음과 같은 트랙잭션의 특성은?",
  "answer" : "2.일관성(consistency)",
  "commentary" : "일관성(consistency)은 트랜잭션이 실행되기 전과 실행된 후의 데이터 상태가 일관성 있어야 함을 의미합니다. 즉, 트랜잭션이 실행되는 동안 데이터의 일부분만 변경되어 데이터의 불일치가 발생하지 않도록 보장해야 합니다. 이 트랜잭션의 경우, 계좌 A에서 100원을 출금하고 계좌 B로 100원을 입금하는 작업이 하나의 논리적인 단위로 처리되므로 일관성이 유지됩니다.",
  "choices" : "1.원자성(atomicity)/2.일관성(consistency)/3.격리성(isolation)/4.영속성(durability)/"
}, {
  "question" : "병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?",
  "answer" : "4.로킹 단위가 작아지면 병행성 수준이 낮아진다.",
  "commentary" : "\"로킹 단위가 작아지면 병행성 수준이 낮아진다.\"가 옳지 않은 것이다. 로킹 단위가 작아지면 오히려 병행성 수준이 높아지는데, 이는 더 작은 단위로 로킹을 하기 때문에 여러 개의 작업이 동시에 수행될 수 있기 때문이다. 하지만 로킹 단위가 작아질수록 로킹 오버헤드가 증가하므로 적절한 로킹 단위를 선택하는 것이 중요하다.",
  "choices" : "1.데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다./2.로킹 단위가 작아지면 로킹 오버헤드가 증가한다./3.한꺼번에 로킹할 수 있는 단위를 로킹단위라고 한다./4.로킹 단위가 작아지면 병행성 수준이 낮아진다./"
}, {
  "question" : "뷰(VIEW)에 대한 설명으로 옳지 않은 것은?",
  "answer" : "3.뷰에 대한 삽입, 갱신, 삭제 연산 시 제약사항이 따르지 않는다.",
  "commentary" : "뷰에 대한 삽입, 갱신, 삭제 연산 시 제약사항이 따르지 않는다는 설명은 옳지 않습니다. 뷰는 기본 테이블의 데이터를 참조하여 만들어지는 가상의 테이블이기 때문에, 뷰에 대한 삽입, 갱신, 삭제 연산은 해당 뷰가 참조하는 기본 테이블의 제약사항을 따라야 합니다. 예를 들어, 뷰가 참조하는 기본 테이블에 NOT NULL 제약이 걸려있다면, 뷰에 대한 삽입 연산 시 해당 컬럼에 NULL 값을 입력할 수 없습니다.",
  "choices" : "1.DBA는 보안 측면에서 뷰를 활용할 수 있다./2.뷰 위에 또 다른 뷰를 정의할 수 있다./3.뷰에 대한 삽입, 갱신, 삭제 연산 시 제약사항이 따르지 않는다./4.독립적인 인덱스를 가질 수 없다./"
}, {
  "question" : "다음 정의에서 말하는 기본 정규형은?",
  "answer" : "1.제1정규형(1NF)",
  "commentary" : "기본 정규형은 제1정규형(1NF)입니다. 이는 모든 속성이 원자값(Atomic Value)을 가지며, 중복된 데이터가 없어야 한다는 조건을 만족하기 때문입니다. 예를 들어, 위의 테이블에서는 \"학생번호\"와 \"과목번호\"가 복합키로 사용되고 있으며, \"과목명\"과 \"담당교수\"가 중복되어 나타나고 있습니다. 이를 1NF로 변환하면, \"과목명\"과 \"담당교수\"를 별도의 테이블로 분리하고, 각각의 테이블에서는 해당 속성의 원자값만을 가지도록 설계해야 합니다.",
  "choices" : "1.제1정규형(1NF)/2.제2정규형(2NF)/3.제3정규형(3NF)/4.보이스/코드 정규형(BCNF)/"
}, {
  "question" : "릴레이션 R1에 속한 애튜리뷰트의 조합인 외래키를 변경하려면 이를 참조하고 있는 릴레이션 R2의 기본키도 변경해야 하는데 이를 무엇이라 하는가?",
  "answer" : "4.참조 무결성",
  "commentary" : "외래키는 다른 릴레이션의 기본키를 참조하는 애트리뷰트이므로, 외래키를 변경하면 참조하는 릴레이션의 데이터 무결성이 깨질 수 있습니다. 따라서 외래키를 변경하려면 참조하는 릴레이션의 기본키도 함께 변경해야 합니다. 이러한 데이터 무결성을 보장하기 위해 데이터베이스에서는 참조 무결성 제약 조건을 사용합니다. 따라서 정답은 \"참조 무결성\"입니다.",
  "choices" : "1.정보 무결성/2.고유 무결성/3.널 제약성/4.참조 무결성/"
}, {
  "question" : "시스템 카탈로그에 대한 설명으로 틀린 것은?",
  "answer" : "1.시스템 카탈로그의 갱신은 무결성 유지를 위하여 SQL을 이용하여 사용자가 직접 갱신하여야 한다.",
  "commentary" : "\"시스템 카탈로그의 갱신은 무결성 유지를 위하여 SQL을 이용하여 사용자가 직접 갱신하여야 한다.\"이 부분이 틀린 것입니다. 시스템 카탈로그는 DBMS가 스스로 생성하고 유지하는 데이터베이스 내의 특별한 테이블의 집합체이며, 데이터베이스에 포함되는 데이터 객체에 대한 정의나 명세에 대한 정보를 유지관리합니다. 사용자가 직접 갱신하는 것이 아니라 DBMS가 내부적으로 갱신을 수행합니다. 따라서, 시스템 카탈로그의 갱신은 사용자가 직접 SQL을 이용하여 갱신하는 것이 아니라 DBMS가 내부적으로 처리합니다.",
  "choices" : "1.시스템 카탈로그의 갱신은 무결성 유지를 위하여 SQL을 이용하여 사용자가 직접 갱신하여야 한다./2.데이터베이스에 포함되는 데이터 객체에 대한 정의나 명세에 대한 정보를 유지관리한다./3.DBMS가 스스로 생성하고 유지하는 데이터베이스 내의 특별한 테이블의 집합체이다./4.카탈로그에 저장된 정보를 메타 데이터라고도 한다./"
}, {
  "question" : "조건을 만족하는 릴레이션의 수평적 부분집합으로 구성하며, 연산자의 기호는 그리스 문자 시그마(σ)를 사용하는 관계대수 연산은?",
  "answer" : "1.Select",
  "commentary" : "\"Select\"는 조건을 만족하는 릴레이션의 수평적 부분집합을 구성하는 연산자이기 때문에 정답입니다. \"Project\"는 릴레이션에서 특정 속성만 선택하는 연산자이고, \"Join\"은 두 개 이상의 릴레이션을 합치는 연산자입니다. \"Division\"은 릴레이션 간의 나눗셈 연산을 수행하는 연산자입니다.",
  "choices" : "1.Select/2.Project/3.Join/4.Division/"
}, {
  "question" : "SQL에서 스키마(schema), 도메인(domain), 테이블(table), 뷰(view), 인덱스(index)를 정의하거나 변경 또는 삭제할 때 사용하는 언어는?",
  "answer" : "2.DDL(Data Definition Language)",
  "commentary" : "DDL(Data Definition Language)은 데이터베이스의 구조를 정의하거나 변경 또는 삭제할 때 사용하는 언어입니다. 스키마(schema), 도메인(domain), 테이블(table), 뷰(view), 인덱스(index) 등을 정의하거나 변경 또는 삭제할 수 있습니다. 반면에 DML(Data Manipulation Language)은 데이터를 검색하거나 수정, 삭제, 삽입하는 등의 데이터 조작을 위한 언어이며, DCL(Data Control Language)은 데이터베이스에 대한 접근 권한을 제어하는 언어입니다. 마지막으로 IDL(Interactive Data Language)은 데이터 분석 및 시각화를 위한 언어입니다.",
  "choices" : "1.DML(Data Manipulation Language)/2.DDL(Data Definition Language)/3.DCL(Data Control Language)/4.IDL(Interactive Data Language)/"
}, {
  "question" : "정규화를 거치지 않아 발생하게 되는 이상(anomaly) 현상의 종류에 대한 설명으로 옳지 않은 것은?",
  "answer" : "4.종속 이상이란 하나의 릴레이션에 하나 이상의 함수적 종속성이 존재하는 현상이다.",
  "commentary" : "종속 이상이란 하나의 릴레이션에 하나 이상의 함수적 종속성이 존재하는 현상이 맞는 설명입니다. 종속 이상은 정규화를 통해 해결할 수 있는데, 하나의 릴레이션에서 여러 개의 속성이 함수적 종속성을 가지고 있을 때, 이를 분해하여 더 작은 릴레이션으로 만들어주는 것입니다. 이렇게 분해하면 각 릴레이션은 단일 값 종속성을 가지게 되어 종속 이상이 발생하지 않습니다. 따라서, 종속 이상은 정규화를 거치지 않아 발생하는 이상 현상의 종류가 아닙니다.",
  "choices" : "1.삭제 이상이란 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄 삭제 현상이다./2.삽입 이상이란 릴레이션에서 데이터를 삽입할 때 의도와는 상관없이 원하지 않는 값들도 함께 삽입되는 현상이다./3.갱신 이상이란 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상이다./4.종속 이상이란 하나의 릴레이션에 하나 이상의 함수적 종속성이 존재하는 현상이다./"
}, {
  "question" : "관계 데이터 모델에서 릴레이션(relation)에 관한 설명으로 옳은 것은?",
  "answer" : "3.도메인(domain)은 하나의 속성이 가질 수 있는 같은 타입의 모든 값의 집합으로 각 속성의 도메인은 원자값을 갖는다.",
  "commentary" : "정답은 \"도메인(domain)은 하나의 속성이 가질 수 있는 같은 타입의 모든 값의 집합으로 각 속성의 도메인은 원자값을 갖는다.\"이다. 도메인은 속성이 가질 수 있는 값의 범위를 정의하는 것으로, 예를 들어 \"도서번호\" 속성의 도메인은 숫자이며, \"도서명\" 속성의 도메인은 문자열이다. 도메인은 원자값을 갖는데, 이는 더 이상 분해되지 않는 가장 작은 단위의 값으로, 예를 들어 \"도서번호\" 속성의 값은 하나의 숫자여야 하며, 여러 개의 숫자로 이루어진 값은 허용되지 않는다.",
  "choices" : "1.릴레이션의 각 행을 스키마(schema)라 하며, 예로 도서 릴레이션을 구성하는 스키마에서는 도서번호, 도서명, 저자, 가격 등이 있다./2.릴레이션의 각 열을 튜플(tuple)이라 하며, 하나의 튜플은 각 속성에서 정의된 값을 이용하여 구성된다./3.도메인(domain)은 하나의 속성이 가질 수 있는 같은 타입의 모든 값의 집합으로 각 속성의 도메인은 원자값을 갖는다./4.속성(attribute)은 한 개의 릴레이션의 논리적인 구조를 정의한 것으로 릴레이션의 이름과 릴레이션에 포함된 속성들의 집합을 의미한다./"
}, {
  "question" : "3NF에서 BCNF가 되기 위한 조건은?",
  "answer" : "4.결정자이면서 후보 키가 아닌 것 제거",
  "commentary" : "BCNF는 모든 결정자가 후보 키여야 한다는 조건을 만족해야 한다. 따라서, 결정자이면서 후보 키가 아닌 속성은 BCNF를 만족시키기 위해 제거되어야 한다. 이는 해당 속성이 다른 속성에 종속되어 있을 경우, 이를 통해 결정되는 함수 종속성이 존재하기 때문이다. 따라서, 이러한 속성을 제거함으로써 이행적 함수 종속, 부분적 함수 종속, 다치 종속 등의 문제를 해결할 수 있고, BCNF를 만족시킬 수 있다.",
  "choices" : "1.이행적 함수 종속 제거/2.부분적 함수 종속 제거/3.다치 종속 제거/4.결정자이면서 후보 키가 아닌 것 제거/"
}, {
  "question" : "데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하며, 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 사용되는 것은?",
  "answer" : "1.인덱스(Index)",
  "commentary" : "인덱스는 데이터베이스에서 자주 사용되는 검색 조건에 대해 미리 정렬된 데이터를 생성하여 빠른 검색을 가능하게 합니다. 따라서 데이터베이스 성능에 많은 영향을 미치는 구성 요소 중 하나입니다.",
  "choices" : "1.인덱스(Index)/2.트랙잭션(Transaction)/3.역정규화(Denormalization)/4.트리거(Trigger)/"
}, {
  "question" : "아래의 SQL문을 실행한 결과는?",
  "answer" : "2.",
  "commentary" : "SELECT COUNT(*) FROM EMPLOYEE WHERE SALARY > 3000; 결과는 \"\" 이다. 이유는 EMPLOYEE 테이블에서 SALARY가 3000보다 큰 레코드의 개수를 COUNT 함수를 사용하여 구하는 SQL문이기 때문이다.",
  "choices" : "1./2./3./4./"
}, {
  "question" : "『회원』테이블 생성 후 『주소』 필드(컬럼)가 누락되어 이를 추가하려고 한다. 이에 적합한 SQL명령어는?",
  "answer" : "3.ALTER",
  "commentary" : "정답은 \"ALTER\"이다. \"ALTER\"는 이미 생성된 테이블의 구조를 변경할 때 사용하는 SQL 명령어이다. 따라서 \"회원\" 테이블에 \"주소\" 필드를 추가하기 위해서는 \"ALTER\" 명령어를 사용해야 한다. \"DELETE\"는 데이터를 삭제할 때 사용하는 명령어이고, \"RESTORE\"는 삭제된 데이터를 복원할 때 사용하는 명령어이다. \"ACCESS\"는 데이터베이스에 접근할 수 있는 권한을 설정할 때 사용하는 명령어이다.",
  "choices" : "1.DELETE/2.RESTORE/3.ALTER/4.ACCESS/"
}, {
  "question" : "트랙잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전에 정상적인 상태로 복구시키는 작업은?",
  "answer" : "1.Recovery",
  "commentary" : "트랙잭션을 수행하는 도중 장애로 인해 데이터베이스가 손상될 수 있습니다. 이때 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업을 Recovery라고 합니다. Recovery는 데이터베이스의 무결성을 보장하기 위해 매우 중요한 작업입니다.",
  "choices" : "1.Recovery/2.Commit/3.Abort/4.Restart/"
}, {
  "question" : "E-R 다이어그램의 표기법으로 옳지 않은 것은?",
  "answer" : "3.관계집합 - 삼각형",
  "commentary" : "관계집합은 삼각형이 아닌 마름모로 표기한다. 삼각형은 일반적으로 일대다 관계를 나타내는데, 이는 관계집합과는 다른 개념이기 때문이다.",
  "choices" : "1.개체타입 - 사각형/2.속성 - 타원/3.관계집합 - 삼각형/4.개체타입과 속성을 연결 – 선/"
}, {
  "question" : "다음 중 응집도가 가장 높은 것은?",
  "answer" : "2.순차적 응집도",
  "commentary" : "순차적 응집도가 가장 높다. 이는 모듈 내부의 모든 요소들이 일련의 순서대로 처리되는 경우를 의미한다. 즉, 한 요소의 출력이 다음 요소의 입력으로 사용되는 경우가 많은 것을 의미한다. 이러한 구조는 모듈의 유지보수와 디버깅을 용이하게 하며, 모듈의 재사용성을 높인다.",
  "choices" : "1.절차적 응집도/2.순차적 응집도/3.우연적 응집도/4.논리적 응집도/"
}, {
  "question" : "OSI 7계층에서 물리적 연결을 이용해 신뢰성 있는 정보를 전송하려고 동기화, 오류제어, 흐름제어 등의 전송에러를 제어하는 계층은?",
  "answer" : "1.데이터 링크 계층",
  "commentary" : "데이터 링크 계층은 물리적 연결을 이용해 신뢰성 있는 정보를 전송하기 위해 전송에러를 제어하는 계층입니다. 이 계층에서는 동기화, 오류제어, 흐름제어 등의 기능을 제공하여 데이터 전송 중 발생할 수 있는 오류를 검출하고 수정하여 신뢰성 있는 데이터 전송을 보장합니다. 따라서 OSI 7계층에서 물리적 연결을 이용해 신뢰성 있는 정보를 전송하려면 데이터 링크 계층이 필요합니다.",
  "choices" : "1.데이터 링크 계층/2.물리 계층/3.응용 계층/4.표현 계층/"
}, {
  "question" : "운영체제를 기능에 따라 분류할 경우 제어 프로그램이 아닌 것은?",
  "answer" : "2.서비스 프로그램",
  "commentary" : "운영체제를 기능에 따라 분류할 경우, 제어 프로그램은 운영체제의 핵심 기능 중 하나이며, 작업 제어 프로그램과 감시 프로그램은 제어 프로그램의 일부분이다. 데이터 관리 프로그램은 파일 시스템과 같은 데이터 관리를 담당하는 프로그램이다. 반면에 서비스 프로그램은 운영체제에서 제공하는 다양한 서비스를 제공하는 프로그램으로, 제어 프로그램과는 다른 역할을 수행한다. 따라서, 서비스 프로그램은 제어 프로그램이 아니다.",
  "choices" : "1.데이터 관리 프로그램/2.서비스 프로그램/3.작업 제어 프로그램/4.감시 프로그램/"
}, {
  "question" : "IEEE 802.3 LAN에서 사용되는 전송매체 접속제어(MAC) 방식은?",
  "answer" : "1.CSMA/CD",
  "commentary" : "IEEE 802.3 LAN에서 사용되는 MAC 방식은 CSMA/CD입니다. 이는 충돌을 감지하고 충돌이 발생한 경우 일정 시간 동안 기다린 후 다시 전송을 시도하는 방식입니다. 이를 통해 여러 장비가 동시에 전송을 시도할 때 충돌을 최소화하고 효율적인 통신을 가능하게 합니다.",
  "choices" : "1.CSMA/CD/2.Token Bus/3.Token Ring/4.Slotted Ring/"
}, {
  "question" : "기억공간이 15K, 23K, 22K, 21K 순으로 빈 공간이 있을 때 기억장치 배치 전력으로 “First Fit”을 사용하여 17K의 프로그램을 적재할 경우 내부단편화의 크기는 얼마인가?",
  "answer" : "2.6K",
  "commentary" : "First Fit 알고리즘은 기억공간의 처음부터 빈 공간을 찾아가며 적재할 수 있는 첫 번째 공간에 프로그램을 적재하는 방식입니다. 따라서 15K에 17K의 프로그램을 적재하면 15K~32K의 공간 중 17K만 사용하고 나머지 15K~16K와 33K~36K의 공간이 남게 됩니다. 이 중에서 가장 작은 단편화는 6K입니다. 6K의 이유는 15K~16K과 33K~36K의 빈 공간이 각각 2K와 3K이므로, 2K+3K=5K의 빈 공간이 생기지만 17K의 프로그램을 적재하기 위해 2K만 사용하고 3K는 사용하지 않았기 때문입니다. 따라서 내부단편화의 크기는 6K입니다.",
  "choices" : "1.5K/2.6K/3.7K/4.8K/"
}, {
  "question" : "교착상태가 발생할 수 있는 조건이 아닌 것은?",
  "answer" : "4.Linear wait",
  "commentary" : "Linear wait은 교착상태를 발생시키는 조건 중 하나이기 때문에, 정답이 아닙니다. Linear wait은 모든 프로세스가 자원을 요청할 때마다 일정한 순서로 자원을 할당하고 반납하는 방식을 말합니다. 이 경우, 자원을 요청한 프로세스는 자신의 차례가 오기 전까지 기다려야 하므로, 다른 프로세스가 자원을 계속해서 점유하고 있을 경우 무한정 기다리게 되어 교착상태가 발생할 수 있습니다. 따라서, Linear wait은 교착상태를 발생시키는 조건 중 하나입니다.",
  "choices" : "1.Mutual exclusion/2.Hold and wait/3.Non-preemption/4.Linear wait/"
}, {
  "question" : "IPv6에 대한 설명으로 틀린 것은?",
  "answer" : "1.멀티캐스팅(Multicast) 대신 브로드캐스트(Broadcast)를 사용한다.",
  "commentary" : "\"멀티캐스팅(Multicast) 대신 브로드캐스트(Broadcast)를 사용한다.\"는 틀린 설명이다. IPv6에서는 멀티캐스팅을 사용하여 효율적인 데이터 전송을 지원한다. 멀티캐스팅은 그룹 내의 모든 호스트에게 데이터를 전송하는 방식으로, 브로드캐스트보다 효율적이다. 멀티캐스팅 주소는 IPv6 주소 체계에서 특별한 형태로 정의되어 있다.",
  "choices" : "1.멀티캐스팅(Multicast) 대신 브로드캐스트(Broadcast)를 사용한다./2.보안과 인증 확장 헤더를 사용함으로써 인터넷 계층의 보안기능을 강화하였다./3.애니캐스트(Anycast)는 하나의 호스트에서 그룹 내의 가장 가까운 곳에 있는 수신자에게 전달하는 방식이다./4.128비트 주소체계를 사용한다./"
}, {
  "question" : "TCP/IP 프로토콜에서 TCP가 해당하는 계층은?",
  "answer" : "3.트랜스포트 계층",
  "commentary" : "TCP는 전송 제어 프로토콜로, 데이터를 안정적으로 전송하기 위한 프로토콜입니다. 따라서 TCP는 데이터를 전송하는 \"트랜스포트 계층\"에 해당합니다.",
  "choices" : "1.데이터 링크 계층/2.네트워크 계층/3.트랜스포트 계층/4.세션 계층/"
}, {
  "question" : "C언어에서 변수로 사용할 수 없는 것은?",
  "answer" : "4.short",
  "commentary" : "\"short\"는 C언어에서 이미 예약어로 사용되기 때문에 변수로 사용할 수 없습니다. 예약어는 프로그래밍 언어에서 이미 특별한 의미를 가지고 있으므로 변수 이름으로 사용할 수 없습니다.",
  "choices" : "1.data02/2.int01/3._sub/4.short/"
}, {
  "question" : "다음 JAVA 코드 출력문의 결과는?",
  "answer" : "4.5 + 2 = 34<chal>5 + 2 = 7",
  "commentary" : "출력문의 결과는 \"5 + 2 = 345 + 2 = 7\" 이다. 이유는 먼저 첫 번째 출력문 \"5 + 2 = 3\"에서 5와 2를 더한 값이 3이므로 잘못된 결과가 출력된다. 이후에는 태그가 있으므로 이어지는 출력문 \"5 + 2 = 34\"도 잘못된 결과가 출력된다. 그리고 다시 태그가 있으므로 그 다음 출력문 \"5 + 2 = 7\"이 올바른 결과이다. 따라서 전체 출력문의 결과는 \"5 + 2 = 345 + 2 = 7\"이 된다.",
  "choices" : "1.5 + 2 = 34<chal>5 + 2 = 34/2.5 + 2 + 3 + 4<chal>5 + 2 = 7/3.7 = 7<chal>7 + 7/4.5 + 2 = 34<chal>5 + 2 = 7/"
}, {
  "question" : "C언어에서 문자열을 정수형으로 변환하는 라이브러리 함수는?",
  "answer" : "1.atoi( )",
  "commentary" : "정답은 \"atoi( )\"입니다. atoi( ) 함수는 문자열을 정수형으로 변환해주는 함수입니다. 이 함수는 문자열을 인자로 받아서 해당 문자열이 나타내는 정수값을 반환합니다. 예를 들어, \"123\"이라는 문자열을 atoi( ) 함수에 인자로 전달하면 123이라는 정수값을 반환합니다. 반면, atof( ) 함수는 문자열을 실수형으로 변환해주는 함수이고, itoa( ) 함수는 정수형을 문자열로 변환해주는 함수입니다. ceil( ) 함수는 소수점 이하를 올림한 값을 반환하는 함수이므로, 문자열을 정수형으로 변환하는 함수와는 관련이 없습니다.",
  "choices" : "1.atoi( )/2.atof( )/3.itoa( )/4.ceil( )/"
}, {
  "question" : "운영체제의 가상기억장치 관리에서 프로세스가 일정 시간동안 자주 참조하는 페이지들의 집합을 의미하는 것은?",
  "answer" : "4.Working Set",
  "commentary" : "정답은 \"Working Set\"입니다. 가상기억장치 관리에서 프로세스가 일정 시간동안 자주 참조하는 페이지들의 집합을 \"Working Set\"이라고 합니다. 이는 프로세스의 작업 진행에 필요한 페이지들을 미리 메모리에 올려놓음으로써 페이지 부재(Page Fault)를 최소화하고 성능을 향상시키는 기술입니다. 따라서 운영체제는 프로세스의 Working Set을 추적하고, 필요에 따라 메모리에 적재하거나 제거하여 최적의 성능을 유지합니다.",
  "choices" : "1.Locality/2.Deadlock/3.Thrashing/4.Working Set/"
}, {
  "question" : "결합도가 낮은 것부터 높은 순으로 옳게 나열한 것은?",
  "answer" : "3.(ㄴ) → (ㄹ) → (ㅂ) → (ㅁ) → (ㄷ) → (ㄱ)",
  "commentary" : "결합도란 모듈 간 상호 의존성의 정도를 나타내는 것으로, 결합도가 낮을수록 모듈 간 독립성이 높아지고 유지보수 및 수정이 용이해진다. 따라서 이 문제에서는 결합도가 낮은 것부터 높은 순으로 나열해야 한다. (ㄴ)은 다른 모듈과의 의존성이 적어 결합도가 낮으므로 가장 먼저 나열한다. (ㄹ)은 (ㄴ)에 의존하지만 다른 모듈과의 의존성이 적어 (ㄴ) 다음으로 나열한다. (ㅂ)은 (ㄴ)과 (ㄹ)에 의존하지만 다른 모듈과의 의존성이 적어 (ㄴ)과 (ㄹ) 다음으로 나열한다. (ㅁ)은 (ㄴ), (ㄹ), (ㅂ)에 의존하지만 다른 모듈과의 의존성이 적어 (ㄴ), (ㄹ), (ㅂ) 다음으로 나열한다. (ㄷ)은 다른 모듈과의 의존성이 많아 결합도가 높으므로 가장 마지막에 나열한다. 따라서 정답은 \"(ㄴ) → (ㄹ) → (ㅂ) → (ㅁ) → (ㄷ) → (ㄱ)\"이다.",
  "choices" : "1.(ㄱ) → (ㄴ) → (ㄹ) → (ㅂ) → (ㅁ) → (ㄷ)/2.(ㄴ) → (ㄹ) → (ㅁ) → (ㅂ) → (ㄷ) → (ㄱ)/3.(ㄴ) → (ㄹ) → (ㅂ) → (ㅁ) → (ㄷ) → (ㄱ)/4.(ㄱ) → (ㄴ) → (ㄹ) → (ㅁ) → (ㅂ) → (ㄷ)/"
}, {
  "question" : "다음 설명의 ㉠과 ㉡에 들어갈 내용으로 옳은 것은?",
  "answer" : "1.㉠ : Paging, ㉡ : Segmentation",
  "commentary" : "이미지에서 보이는 메모리 구조는 논리적 주소와 물리적 주소를 매핑하는 방식으로 동작하는 가상 메모리 시스템입니다. 이 때, 논리적 주소를 물리적 주소로 변환하는 방법에는 Paging과 Segmentation이 있습니다. Paging은 논리적 주소를 고정된 크기의 페이지로 나누어 처리하는 방식이고, Segmentation은 논리적 주소를 논리적 단위로 나누어 처리하는 방식입니다. 따라서, ㉠에는 Paging이, ㉡에는 Segmentation이 들어가는 것이 옳습니다.",
  "choices" : "1.㉠ : Paging, ㉡ : Segmentation/2.㉠ : Segmentation, ㉡ : Allocation/3.㉠ : Segmentation, ㉡ : Compaction/4.㉠ : Paging, ㉡ : Linking/"
}, {
  "question" : "라이브러리의 개념과 구성에 대한 설명 중 틀린 것은?",
  "answer" : "3.외부 라이브러리는 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리를 의미하며, 표준 라이브러리는 별도의 파일 설치를 필요로 하는 라이브러리를 의미한다.",
  "commentary" : "\"라이브러리는 모듈과 패키지를 총칭하며, 모듈이 개별 파일이라면 패키지는 파일들을 모아 놓은 폴더라고 볼 수 있다.\"는 틀린 설명입니다. 라이브러리는 모듈과 패키지를 포함하는 개념이지만, 모듈과 패키지를 총칭하는 것은 아닙니다.",
  "choices" : "1.라이브러리란 필요할 때 찾아서 쓸 수 있도록 모듈화되어 제공되는 프로그램을 말한다./2.프로그래밍 언어에 따라 일반적으로 도움말, 설치 파일, 샘플 코드 등을 제공한다./3.외부 라이브러리는 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리를 의미하며, 표준 라이브러리는 별도의 파일 설치를 필요로 하는 라이브러리를 의미한다./4.라이브러리는 모듈과 패키지를 총칭하며, 모듈이 개별 파일이라면 패키지는 파일들을 모아 놓은 폴더라고 볼 수 있다./"
}, {
  "question" : "C언어에서 산술 연산자가 아닌 것은?",
  "answer" : "4.=",
  "commentary" : "정답은 \"=\"입니다. 이유는 \"=\"는 대입 연산자이기 때문입니다. 대입 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 대입하는 역할을 합니다. 따라서 산술 연산자가 아니라 대입 연산자입니다. 나머지 연산자인 \"%\"와 곱셈 연산자인 \"*\" 그리고 나눗셈 연산자인 \"/\"는 모두 산술 연산자입니다. \"%\"는 나머지를 구하는 연산자이고, \"*\"는 곱셈을 하는 연산자이며, \"/\"는 나눗셈을 하는 연산자입니다.",
  "choices" : "1.%/2.*/3.//4.=/"
}, {
  "question" : "UDP 특성에 해당되는 것은?",
  "answer" : "4.흐름제어나 순서제어가 없어 전송속도가 빠르다.",
  "commentary" : "UDP는 흐름제어나 순서제어 기능이 없기 때문에 데이터를 빠르게 전송할 수 있습니다. 이는 데이터 전송의 신뢰성을 희생하는 것이지만, 실시간성이 중요한 애플리케이션에서는 유용합니다. 따라서 UDP는 신뢰성보다는 속도를 우선시하는 애플리케이션에 적합합니다.",
  "choices" : "1.양방향 연결형 서비스를 제공한다./2.송신중에 링크를 유지관리하므로 신뢰성이 높다./3.순서제어, 오류제어, 흐름제어 기능을 한다./4.흐름제어나 순서제어가 없어 전송속도가 빠르다./"
}, {
  "question" : "JAVA에서 변수와 자료형에 대한 설명으로 틀린 것은?",
  "answer" : "3.char 자료형은 나열된 여러 개의 문자를 저장하고자 할 때 사용한다.",
  "commentary" : "정답은 \"char 자료형은 나열된 여러 개의 문자를 저장하고자 할 때 사용한다.\" 이다. 이유는 char 자료형은 단 하나의 문자를 저장하는 자료형이며, 문자열을 저장하기 위해서는 String 자료형을 사용해야 한다.",
  "choices" : "1.변수는 어떤 값을 주기억 장치에 기억하기 위해서 사용하는 공간이다./2.변수의 자료형에 따라 저장할 수 있는 값의 종류와 범위가 달라진다./3.char 자료형은 나열된 여러 개의 문자를 저장하고자 할 때 사용한다./4.boolean 자료형은 조건이 참인지 거짓인지 판단하고자 할 때 사용한다./"
}, {
  "question" : "다음은 파이썬으로 만들어진 반복문 코드이다. 이 코드의 결과는?",
  "answer" : "1.A, B, C 출력이 반복된다.",
  "commentary" : "반복문 for문에서 변수 i는 range(4)로 인해 0부터 3까지 4번 반복하게 된다. 따라서 print문이 4번 실행되며, 각각 \"A\", \"B\", \"C\", \"D\"가 출력된다. 이때 i가 3일 때, 즉 마지막 반복에서 \"D\"가 출력된 후에는 반복문이 종료되므로 \"A, B, C 출력이 반복된다.\"가 정답이 된다.",
  "choices" : "1.A, B, C 출력이 반복된다./2.A, B, C 까지만 출력된다./3.A, B, C, D 출력이 반복된다./4.A, B, C, D 까지만 출력된다./"
}, {
  "question" : "WAS(Web Application Server)가 아닌 것은?",
  "answer" : "2.JVM",
  "commentary" : "JEUS, Tomcat, WebSphere은 모두 WAS(Web Application Server)에 해당하는 소프트웨어이지만, JVM은 WAS가 아닌 자바 가상 머신(Java Virtual Machine)이기 때문에 정답입니다. JVM은 자바 언어로 작성된 프로그램을 실행하기 위한 가상 머신으로, WAS에서도 사용될 수 있지만 WAS 자체는 웹 애플리케이션을 실행하기 위한 서버 소프트웨어를 의미합니다.",
  "choices" : "1.JEUS/2.JVM/3.Tomcat/4.WebSphere/"
}, {
  "question" : "다음 암호 알고리즘 중 성격이 다른 하나는?",
  "answer" : "4.AES",
  "commentary" : "AES는 대칭키 암호화 알고리즘이며, MD4, MD5, SHA-1은 해시 함수 알고리즘이다. 대칭키 암호화는 암호화와 복호화에 같은 키를 사용하는 반면, 해시 함수는 입력값을 고정된 길이의 출력값으로 변환하는 단방향 함수이다. 따라서 AES는 입력값을 암호화하여 출력값을 생성하는 반면, MD4, MD5, SHA-1은 입력값을 해시하여 출력값을 생성한다는 점에서 성격이 다르다.",
  "choices" : "1.MD4/2.MD5/3.SHA-1/4.AES/"
}, {
  "question" : "크래커가 침입하여 백도어를 만들어 놓거나, 설정파일을 변경했을 때 분석하는 도구는?",
  "answer" : "1.tripwire",
  "commentary" : "tripwire는 시스템 파일 및 디렉토리의 변경을 감지하고 보고하는 호스트 기반의 침입 탐지 시스템이다. 따라서 크래커가 백도어를 만들거나 설정파일을 변경했을 때 이를 감지하고 분석할 수 있는 도구이다. 다른 보기들은 네트워크 관련 도구이거나 스케줄링 도구이므로 이와 관련이 없다.",
  "choices" : "1.tripwire/2.tcpdump/3.cron/4.netcat/"
}, {
  "question" : "다음 내용이 설명하는 것은?",
  "answer" : "4.MQTT",
  "commentary" : "이 그림은 IoT 기기들 간의 통신을 위한 프로토콜을 나타내고 있습니다. 이 중에서 MQTT는 IoT 기기들 간의 경량화된 메시지 전송 프로토콜로, 대규모의 IoT 기기들 간의 통신에 적합하며, 저전력 환경에서도 사용이 가능합니다. 따라서 IoT 분야에서 많이 사용되고 있습니다.",
  "choices" : "1.GRID/2.TELNET/3.GPN/4.MQTT/"
}, {
  "question" : "나선형(Spiral) 모형의 주요 태스크에 해당되지 않는 것은?",
  "answer" : "1.버전 관리",
  "commentary" : "나선형 모형은 소프트웨어 개발 프로세스에서 위험 분석, 개발, 평가 등의 주요 태스크를 수행하는데 적합한 모형이다. 그러나 버전 관리는 개발 프로세스에서 필수적인 요소이지만, 나선형 모형의 주요 태스크에는 해당되지 않는다. 따라서 정답은 \"버전 관리\"이다.",
  "choices" : "1.버전 관리/2.위험 분석/3.개발/4.평가/"
}, {
  "question" : "정보 보안을 위한 접근통제 정책 종류에 해당하지 않는 것은?",
  "answer" : "2.데이터 전환 접근 통제",
  "commentary" : "정보 보안을 위한 접근통제 정책 종류 중 \"데이터 전환 접근 통제\"는 존재하지 않습니다. 따라서 이 보기에서 정답은 \"데이터 전환 접근 통제\"입니다.",
  "choices" : "1.임의적 접근 통제/2.데이터 전환 접근 통제/3.강제적 접근 통제/4.역할 기반 접근 통제/"
}, {
  "question" : "LOC기법에 의하여 예측된 총 라인수가 36,000라인, 개발에 참여할 프로그래머가 6명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간은?",
  "answer" : "4.20개월",
  "commentary" : "LOC기법에 의한 예측 총 라인수 36,000라인을 프로그래머들의 월간 생산성 300라인으로 나누면 120개월이 나옵니다. 하지만 개발에 참여할 프로그래머가 6명이므로, 개발 기간은 120개월을 6으로 나눈 20개월이 됩니다. 따라서 정답은 \"20개월\"입니다.",
  "choices" : "1.5개월/2.10개월/3.15개월/4.20개월/"
}, {
  "question" : "정형화된 분석 절차에 따라 사용자 요구사항을 파악, 문서화하는 체계적 분석방법으로 자료흐름도, 자료사전, 소단위명세서의 특징을 갖는 것은?",
  "answer" : "1.구조적 개발 방법론",
  "commentary" : "구조적 개발 방법론은 사용자 요구사항을 파악하고 문서화하는 체계적인 분석 방법으로, 자료흐름도, 자료사전, 소단위명세서 등의 도구를 사용하여 요구사항을 명확하게 파악하고 문서화합니다. 이 방법론은 분석과 설계를 분리하여 체계적으로 수행하며, 모듈화와 추상화를 통해 시스템을 구성하고 구현합니다. 따라서 구조적 개발 방법론은 체계적이고 구체적인 분석과 설계를 통해 안정적이고 신뢰성 높은 시스템을 개발하는 데 적합합니다.",
  "choices" : "1.구조적 개발 방법론/2.객체지향 개발 방법론/3.정보공학 방법론/4.CBD 방법론/"
}, {
  "question" : "정보보호를 위한 암호화에 대한 설명으로 틀린 것은?",
  "answer" : "3.복호화 – 평문을 암호문으로 바꾸는 작업",
  "commentary" : "정보보호를 위한 암호화에 대한 설명 중 틀린 것은 없습니다. 복호화는 암호화된 메시지를 평문으로 바꾸는 작업입니다. 즉, 암호화된 메시지를 해독하여 원래의 평문 메시지를 얻는 것입니다. 이를 위해서는 암호화할 때 사용한 키(Key)가 필요합니다.",
  "choices" : "1.평문 – 암호화되기 전의 원본 메시지/2.암호문 – 암호화가 적용된 메시지/3.복호화 – 평문을 암호문으로 바꾸는 작업/4.키(Key) - 적절한 암호화를 위하여 사용하는 값/"
}, {
  "question" : "다음 내용이 설명하는 것은?",
  "answer" : "2.Baas",
  "commentary" : "보기에서 \"Baas\"는 \"Blockchain as a Service\"의 약자로, 블록체인 기술을 클라우드 서비스 형태로 제공하는 것을 의미한다.",
  "choices" : "1.OTT/2.Baas/3.SDDC/4.Wi-SUN/"
}, {
  "question" : "소프트웨어 비용 산정 기법 중 개발 유형으로 organic, semi-detach, embedded로 구분되는 것은?",
  "answer" : "2.COCOMO",
  "commentary" : "COCOMO는 소프트웨어 비용 산정 기법 중에서 개발 유형으로 organic, semi-detach, embedded로 구분되는 것이다. 이는 프로젝트의 규모와 복잡도에 따라 개발 유형을 구분하여 비용을 산정하는 방법이다. 따라서 COCOMO가 정답이다.",
  "choices" : "1.PUTNAM/2.COCOMO/3.FP/4.SLIM/"
}, {
  "question" : "다음 LAN의 네트워크 토폴로지는 어떤 형인가?",
  "answer" : "3.버스형",
  "commentary" : "정답은 \"버스형\"입니다. 이유는 네트워크의 모든 장치들이 하나의 케이블에 연결되어 있으며, 데이터가 이 케이블을 통해 전송되는 구조이기 때문입니다. 따라서 이러한 구조를 \"버스형\"이라고 합니다.",
  "choices" : "1.그물형/2.십자형/3.버스형/4.링형/"
}, {
  "question" : "전기 및 정보통신기술을 활용하여 전력망을 지능화, 고도화함으로써 고품질의 전력서비스를 제공하고 에너지 이용효율을 극대화하는 전력망은?",
  "answer" : "2.스마트 그리드",
  "commentary" : "스마트 그리드는 전기 및 정보통신기술을 활용하여 전력망을 지능화, 고도화함으로써 고품질의 전력서비스를 제공하고 에너지 이용효율을 극대화하는 전력망입니다. 따라서 스마트 그리드가 정답입니다.",
  "choices" : "1.사물 인터넷/2.스마트 그리드/3.디지털 아카이빙/4.미디어 빅뱅/"
}, {
  "question" : "다음 내용이 설명하는 소프트웨어 개발 모형은?",
  "answer" : "3.폭포수 모형",
  "commentary" : "위 그림은 폭포수 모형을 나타내고 있습니다. 폭포수 모형은 개발 생명주기를 계획, 분석, 설계, 구현, 테스트, 유지보수의 단계로 나누어 순차적으로 진행하는 모형입니다. 각 단계가 완료되어야 다음 단계로 진행할 수 있으며, 각 단계에서는 이전 단계에서 정의된 결과물을 바탕으로 작업을 수행합니다. 이러한 특징으로 인해 초기 계획과 분석이 중요하며, 변경 요청이 발생하면 다시 처음부터 시작해야 하는 단점이 있습니다.",
  "choices" : "1.프로토타입 모형/2.나선형 모형/3.폭포수 모형/4.RAD 모형/"
}, {
  "question" : "스트림 암호화 방식의 설명으로 옳지 않은 것은?",
  "answer" : "2.해쉬 함수를 이용한 해쉬 암호화 방식을 사용한다.",
  "commentary" : "해쉬 함수는 메시지 무결성을 검증하기 위한 용도로 사용되며, 스트림 암호화 방식과는 직접적인 연관성이 없습니다. 따라서 \"해쉬 함수를 이용한 해쉬 암호화 방식을 사용한다.\"는 스트림 암호화 방식의 설명으로 옳지 않습니다.",
  "choices" : "1.비트/바이트/단어들을 순차적으로 암호화한다./2.해쉬 함수를 이용한 해쉬 암호화 방식을 사용한다./3.RC4는 스트림 암호화 방식에 해당한다./4.대칭키 암호화 방식이다./"
}, {
  "question" : "세션 하이재킹을 탐지하는 방법으로 거리가 먼 것은?",
  "answer" : "1.FTP SYN SEGNENT 탐지",
  "commentary" : "FTP SYN SEGNENT 탐지는 세션 하이재킹 공격에서 사용되는 특정한 패킷을 탐지하는 방법이다. 이 패킷은 FTP 서버와 클라이언트 간의 연결을 설정하는 SYN 패킷과 FTP 서버로부터의 응답인 SYN-ACK 패킷을 조합한 것이다. 이 패킷이 여러 번 반복되는 것을 감지하면, 이는 세션 하이재킹 공격의 가능성이 높다는 것을 의미한다. 따라서 FTP SYN SEGNENT 탐지는 세션 하이재킹 공격을 탐지하는 데 효과적인 방법 중 하나이다.",
  "choices" : "1.FTP SYN SEGNENT 탐지/2.비동기화 상태 탐지/3.ACK STORM 탐지/4.패킷의 유실 및 재전송 증가 탐지/"
}, {
  "question" : "소프트웨어공학에 대한 설명으로 거리가 먼 것은?",
  "answer" : "3.소프트웨어공학의 궁극적 목표는 최대의 비용으로 계획된 일정보다 가능한 빠른 시일 내에 소프트웨어를 개발하는 것이다.",
  "commentary" : "소프트웨어공학의 궁극적 목표는 최대의 비용으로 계획된 일정보다 가능한 빠른 시일 내에 소프트웨어를 개발하는 것이다. 이는 소프트웨어 개발의 효율성과 경제성을 극대화하기 위한 목표이다.",
  "choices" : "1.소프트웨어공학이란 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법이다./2.소프트웨어공학은 소프트웨어 제품의 품질을 향상시키고 소프트웨어 생산성과 작업 만족도를 증대시키는 것이 목적이다./3.소프트웨어공학의 궁극적 목표는 최대의 비용으로 계획된 일정보다 가능한 빠른 시일 내에 소프트웨어를 개발하는 것이다./4.소프트웨어공학은 신뢰성 있는 소프트웨어를 경제적인 비용으로 획득하기 위해 공학적 원리를 정립하고 이를 이용하는 것이다./"
}, {
  "question" : "소프트웨어 개발 방법론 중 CBD(Component Based Development)에 대한 설명으로 틀린 것은?",
  "answer" : "3.모듈의 분할과 정복에 의한 하향식 설계방식이다.",
  "commentary" : "CBD(Component Based Development)는 모듈의 분할과 정복에 의한 하향식 설계방식이 아니라 상향식 설계방식이다. CBD는 큰 규모의 소프트웨어를 작은 단위의 독립적인 컴포넌트로 분할하여 개발하는 방법론으로, 이러한 컴포넌트들을 조합하여 전체 시스템을 완성한다. 따라서 CBD는 복잡성을 최소화하고 생산성과 품질을 높이며, 컴포넌트 제작 기법을 통해 재사용성을 향상시킨다.",
  "choices" : "1.생산성과 품질을 높이고, 유지보수 비용을 최소화할 수 있다./2.컴포넌트 제작 기법을 통해 재사용성을 향상시킨다./3.모듈의 분할과 정복에 의한 하향식 설계방식이다./4.독립적인 컴포넌트 단위의 관리로 복잡성을 최소화할 수 있다./"
}, {
  "question" : "정보 보안의 3요소에 해당하지 않는 것은?",
  "answer" : "4.휘발성",
  "commentary" : "기밀성, 무결성, 가용성은 정보 보안의 3요소에 해당하는데, 휘발성은 정보 보안과는 직접적인 연관이 없는 개념이기 때문에 해당하지 않는다. 휘발성은 물질이 기체나 증기로 변하는 속성을 의미하며, 정보 보안과는 관련이 없다.",
  "choices" : "1.기밀성/2.무결성/3.가용성/4.휘발성/"
}, {
  "question" : "소셜 네트워크에서 악의적인 사용자가 지인 또는 특정 유명인으로 가장하여 활동하는 공격 기법은?(문제 오류로 가답안 발표시 1번으로 발표되었지만 확정답안 발표시 1, 2번이 정답처리 되었습니다. 여기서는 가답안인 1번을 누르시면 정답 처리 됩니다.)",
  "answer" : "1.Evil Twin Attack",
  "commentary" : "\"Evil Twin Attack\"은 악의적인 사용자가 지인 또는 특정 유명인으로 가장하여 소셜 네트워크 상에서 가짜 계정을 만들고, 이를 이용해 사용자들의 개인정보를 탈취하거나 악성코드를 유포하는 공격 기법입니다. 이를 통해 사용자들은 신뢰할 수 있는 계정으로 오인하고, 악성 행위에 노출될 수 있습니다.",
  "choices" : "1.Evil Twin Attack/2.Phishing/3.Logic Bomb/4.Cyberbullying/"
}, {
  "question" : "공개키 암호에 대한 설명으로 틀린 것은?",
  "answer" : "1.10명이 공개키 암호를 사용할 경우 5개의 키가 필요하다.",
  "commentary" : "정답은 \"10명이 공개키 암호를 사용할 경우 5개의 키가 필요하다.\" 이다. 이는 틀린 설명이다. 공개키 암호에서는 각 사용자마다 공개키와 비밀키 두 개의 키가 필요하다. 따라서 10명이 공개키 암호를 사용할 경우 20개의 키가 필요하다.",
  "choices" : "1.10명이 공개키 암호를 사용할 경우 5개의 키가 필요하다./2.복호화키는 비공개 되어 있다./3.송신자는 수신자의 공개키로 문서를 암호화한다./4.공개키 암호로 널리 알려진 알고리즘은 RSA가 있다./"
}, {
  "question" : "XP(eXtreme Programming)의 기본원리로 볼 수 없는 것은?",
  "answer" : "1.Linear Sequential Method",
  "commentary" : "XP는 Agile 개발 방법론 중 하나로, 빠른 개발과 고객 요구사항의 변경에 대응하기 위해 유연하고 반복적인 개발 프로세스를 강조합니다. 이에 반해 \"Linear Sequential Method\"는 워터폴 방식과 같은 전통적인 개발 방법론으로, 개발 단계를 선형적으로 진행하며 각 단계가 완료되어야 다음 단계로 넘어가는 방식입니다. 따라서 XP의 기본원리로 볼 수 없습니다.",
  "choices" : "1.Linear Sequential Method/2.Pair Programming/3.Collective Ownership/4.Continuous Integration/"
}, {
  "question" : "럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용되는 다이어그램은?",
  "answer" : "3.상태 다이어그램(State Diagram)",
  "commentary" : "럼바우 객체지향 분석 기법에서 동적 모델링에 활용되는 다이어그램은 상태 다이어그램(State Diagram)입니다. 이는 객체의 상태 변화를 표현하는데 사용되며, 객체가 어떤 상태에서 어떤 상태로 전이되는지를 보여줍니다. 상태 다이어그램은 객체의 동작을 이해하고 설계하는데 매우 유용합니다.",
  "choices" : "1.객체 다이어그램(Object Diagram)/2.패키지 다이어그램(Package Diagram)/3.상태 다이어그램(State Diagram)/4.자료 흐름도(Data Flow Diagram)/"
}, {
  "question" : "CASE(Computer Aided Software Engineering)의 주요 기능으로 옳지 않은 것은?",
  "answer" : "4.언어 번역",
  "commentary" : "CASE는 S/W 라이프 사이클 전 단계의 연결, 그래픽 지원, 다양한 소프트웨어 개발 모형 지원과 같은 기능을 가지지만, 언어 번역 기능은 포함되어 있지 않습니다. CASE는 소프트웨어 개발 과정에서 자동화된 도구를 제공하여 생산성을 향상시키는 것이 목적입니다.",
  "choices" : "1.S/W 라이프 사이클 전 단계의 연결/2.그래픽 지원/3.다양한 소프트웨어 개발 모형 지원/4.언어 번역/"
}, {
  "question" : "객체지향 기법의 캡슐화(Encapsulation)에 대한 설명으로 틀린 것은?",
  "answer" : "4.상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것을 의미한다.",
  "commentary" : "상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것을 의미한다는 설명은 캡슐화와는 관련이 없는 상속(Inheritance)에 대한 설명이다. 캡슐화는 객체의 내부 구현을 외부에서 접근하지 못하도록 숨기는 것을 의미하며, 이를 통해 인터페이스가 단순화되고 소프트웨어 재사용성이 높아지며 변경 발생 시 오류의 파급효과가 적어진다.",
  "choices" : "1.인터페이스가 단순화 된다./2.소프트웨어 재사용성이 높아진다./3.변경 발생 시 오류의 파급효과가 적다./4.상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것을 의미한다./"
}, {
  "question" : "다음 내용이 설명하는 객체지향 설계 원칙은?",
  "answer" : "1.인터페이스 분리 원칙",
  "commentary" : "이미지에서 보이는 클래스는 여러 기능을 가지고 있지만, 인터페이스 분리 원칙에 따라 각각의 기능을 독립적인 인터페이스로 분리하여 클라이언트가 필요한 기능만 사용할 수 있도록 설계되었다. 이는 인터페이스가 클라이언트와 구현체 사이의 계약을 정의하는 것이기 때문에, 불필요한 메서드를 포함한 인터페이스를 구현하는 것은 클라이언트에게 불필요한 의존성을 강제하는 것이 되기 때문이다. 따라서 인터페이스 분리 원칙은 인터페이스를 작고 응집력 있는 단위로 분리하여, 클라이언트와 구현체 간의 결합도를 낮추고 유연성과 확장성을 높이는 것을 목적으로 한다.",
  "choices" : "1.인터페이스 분리 원칙/2.단일 책임 원칙/3.개방 폐쇄의 원칙/4.리스코프 교체의 원칙/"
}, {
  "question" : "파이프 필터 형태의 소프트웨어 아키텍처에 대한 설명으로 옳은 것은?",
  "answer" : "2.서브시스템이 입력데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정을 반복한다.",
  "commentary" : "파이프 필터 형태의 소프트웨어 아키텍처는 서브시스템이 입력데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정을 반복하는 형태의 아키텍처이다. 이는 데이터 처리를 담당하는 서브시스템과 결과를 출력하는 서브시스템이 분리되어 있어 유지보수와 확장성이 용이하다는 장점이 있다. 따라서 \"서브시스템이 입력데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정을 반복한다.\"가 옳은 설명이다.",
  "choices" : "1.노드와 간선으로 구성된다./2.서브시스템이 입력데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정을 반복한다./3.계층 모델이라고도 한다./4.3개의 서브시스템(모델, 뷰, 제어)으로 구성되어 있다./"
}, {
  "question" : "코드화 대상 항목의 중량, 면적, 용량 등의 물리적 수치를 이용하여 만든 코드는?",
  "answer" : "3.표의 숫자 코드",
  "commentary" : "코드화 대상 항목의 중량, 면적, 용량 등의 물리적 수치를 이용하여 만든 코드는 \"표의 숫자 코드\"이다. 이는 각 항목의 수치를 일정한 규칙에 따라 숫자로 변환하여 표현하는 방식으로, 숫자로 이루어진 표를 이용하여 정보를 전달하고 저장하기 용이하다는 장점이 있다.",
  "choices" : "1.순차 코드/2.10진 코드/3.표의 숫자 코드/4.블록 코드/"
}, {
  "question" : "디자인 패턴 사용의 장٠단점에 대한 설명으로 거리가 먼 것은?",
  "answer" : "4.절차형 언어와 함께 이용될 때 효율이 극대화된다.",
  "commentary" : null,
  "choices" : "1.소프트웨어 구조 파악이 용이하다./2.객체지향 설계 및 구현의 생산성을 높이는데 적합하다./3.재사용을 위한 개발 시간이 단축된다./4.절차형 언어와 함께 이용될 때 효율이 극대화된다./"
}, {
  "question" : "DFD(data flow diagram)에 대한 설명으로 틀린 것은?",
  "answer" : "3.시간 흐름을 명확하게 표현할 수 있다.",
  "commentary" : null,
  "choices" : "1.자료 흐름 그래프 또는 버블(bubble) 차트라고도 한다./2.구조적 분석 기법에 이용된다./3.시간 흐름을 명확하게 표현할 수 있다./4.DFD의 요소는 화살표, 원, 사각형, 직선(단선/이중선)으로 표시한다./"
}, {
  "question" : "그래픽 표기법을 이용하여 소프트웨어 구성 요소를 모델링하는 럼바우 분석 기법에 포함되지 않는 것은?",
  "answer" : "4.블랙박스 분석 모델링",
  "commentary" : "럼바우 분석 기법은 객체 모델링, 기능 모델링, 동적 모델링을 포함하고 있지만, 블랙박스 분석 모델링은 포함되지 않습니다. 이는 블랙박스 분석 모델링이 소프트웨어의 내부 동작을 고려하지 않고, 오로지 입력과 출력만을 고려하는 분석 방법이기 때문입니다. 따라서 블랙박스 분석 모델링은 소프트웨어의 내부 동작을 파악하는 데는 한계가 있습니다.",
  "choices" : "1.객체 모델링/2.기능 모델링/3.동적 모델링/4.블랙박스 분석 모델링/"
}, {
  "question" : "UML의 기본 구성요소가 아닌 것은?",
  "answer" : "2.Terminal",
  "commentary" : "\"Terminal\"은 UML의 기본 구성요소가 아닙니다. UML의 기본 구성요소는 \"Things\", \"Relationship\", \"Diagram\"입니다. \"Things\"은 시스템의 구성요소를 나타내는 클래스, 객체, 인터페이스 등을 의미하며, \"Relationship\"은 이러한 구성요소들 간의 관계를 나타내는 것입니다. \"Diagram\"은 시스템을 시각적으로 표현하는 도구입니다. \"Terminal\"은 UML에서 사용되지 않는 용어입니다.",
  "choices" : "1.Things/2.Terminal/3.Relationship/4.Diagram/"
}, {
  "question" : "소프트웨어의 상위설계에 속하지 않는 것은?",
  "answer" : "2.모듈 설계",
  "commentary" : null,
  "choices" : "1.아키텍처 설계/2.모듈 설계/3.인터페이스 정의/4.사용자 인터페이스 설계/"
}, {
  "question" : "다음 중 자료사전(Data Dictionary)에서 선택의 의미를 나타내는 것은?",
  "answer" : "1.[ ]",
  "commentary" : null,
  "choices" : "1.[ ]/2.{ }/3.＋/4.＝/"
}, {
  "question" : "소프트웨어의 사용자 인터페이스개발시스템(User Interface Development System)이 가져야 할 기능이 아닌 것은?",
  "answer" : "4.소스 코드 분석 및 오류 복구",
  "commentary" : "소프트웨어의 사용자 인터페이스 개발 시스템은 사용자와 소프트웨어 간의 상호작용을 원활하게 하기 위한 기능을 제공해야 합니다. 이 중에서 \"소스 코드 분석 및 오류 복구\"는 개발자가 수행해야 하는 작업이며, 사용자 인터페이스 개발 시스템이 제공해야 할 기능은 아닙니다. 따라서 이 보기가 정답입니다.",
  "choices" : "1.사용자 입력의 검증/2.에러 처리와 에러 메시지 처리/3.도움과 프롬프트(prompt) 제공/4.소스 코드 분석 및 오류 복구/"
}, {
  "question" : "요구 사항 명세기법에 대한 설명으로 틀린 것은?",
  "answer" : "2.비정형 명세기법은 사용자의 요구를 표현할 때 Z 비정형 명세기법을 사용한다.",
  "commentary" : "\"비정형 명세기법은 사용자의 요구를 표현할 때 Z 비정형 명세기법을 사용한다.\"이 부분이 틀린 것입니다. 비정형 명세기법은 자연어를 기반으로 서술하며, Z 비정형 명세기법은 비교적 구체적인 수학적인 표기법을 사용하는 정형 명세기법 중 하나입니다.",
  "choices" : "1.비정형 명세기법은 사용자의 요구를 표현할 때 자연어를 기반으로 서술한다./2.비정형 명세기법은 사용자의 요구를 표현할 때 Z 비정형 명세기법을 사용한다./3.정형 명세기법은 사용자의 요구를 표현할 때 수학적인 원리와 표기법을 이용한다./4.정형 명세기법은 비정형 명세기법에 비해 표현이 간결하다./"
}, {
  "question" : "소프트웨어 개발 단계에서 요구 분석 과정에 대한 설명으로 거리가 먼 것은?",
  "answer" : "2.개발 비용이 가장 많이 소요되는 단계이다.",
  "commentary" : "\"자료흐름도, 자료 사전 등이 효과적으로 이용될 수 있다.\"는 요구 분석 과정에서 일어나는 일들 중 가장 일반적인 것 중 하나이며, 다른 보기들과 마찬가지로 요구 분석 결과를 문서화하고 구체적인 명세를 위해 도구를 활용하는 것이 중요하다. 그러나 \"개발 비용이 가장 많이 소요되는 단계이다.\"는 요구 분석 과정에서 가장 큰 비용이 드는 이유는, 이 단계에서 시스템의 요구사항을 정확하게 파악하지 못하면 개발 후에 수정이나 추가 작업이 필요해지기 때문이다. 따라서 요구 분석 단계에서 충분한 시간과 노력을 투자하여 정확한 요구사항을 파악하는 것이 중요하다.",
  "choices" : "1.분석 결과의 문서화를 통해 향후 유지보수에 유용하게 활용 할 수 있다./2.개발 비용이 가장 많이 소요되는 단계이다./3.자료흐름도, 자료 사전 등이 효과적으로 이용될 수 있다./4.보다 구체적인 명세를 위해 소단위 명세서(Mini-Spec)가 활용될 수 있다./"
}, {
  "question" : "애자일 방법론에 해당하지 않는 것은?",
  "answer" : "4.모듈중심 개발",
  "commentary" : "애자일 방법론은 변화에 대응하기 쉽고 고객의 요구사항에 빠르게 대응할 수 있는 방법론으로, 작은 주기로 개발을 진행하고 피드백을 받아 지속적으로 개선하는 것이 특징입니다. 이에 반해, 모듈중심 개발은 개발을 모듈 단위로 나누어 개발하는 방법론으로, 애자일 방법론과는 다른 개발 방법론입니다. 따라서, 애자일 방법론에 해당하지 않습니다.",
  "choices" : "1.기능중심 개발/2.스크럼/3.익스트림 프로그래밍/4.모듈중심 개발/"
}, {
  "question" : "클라이언트와 서버 간의 통신을 담당하는 시스템 소프트웨어를 무엇이라고 하는가?",
  "answer" : "3.미들웨어",
  "commentary" : "미들웨어는 클라이언트와 서버 간의 통신을 중개하고 관리하는 시스템 소프트웨어입니다. 따라서 이 문제에서는 미들웨어가 가장 적절한 답입니다. 웨어러블은 착용 가능한 기기를 의미하며, 하이웨어는 고성능 컴퓨터 하드웨어를 의미합니다. 응용 소프트웨어는 사용자가 직접 사용하는 소프트웨어를 의미합니다.",
  "choices" : "1.웨어러블/2.하이웨어/3.미들웨어/4.응용 소프트웨어/"
}, {
  "question" : "GoF(Gangs of Four) 디자인 패턴 분류에 해당하지 않는 것은?",
  "answer" : "4.추상 패턴",
  "commentary" : "\"추상 패턴\"은 GoF 디자인 패턴 분류에 해당하지 않는다. 이유는 GoF 디자인 패턴은 객체지향 디자인 패턴을 분류한 것이며, 추상 패턴은 객체지향 디자인 패턴이 아니기 때문이다. 추상 패턴은 일반적인 디자인 패턴이 아니며, 추상화와 관련된 개념을 다루는 것이다.",
  "choices" : "1.생성 패턴/2.구조 패턴/3.행위 패턴/4.추상 패턴/"
}, {
  "question" : "바람직한 소프트웨어 설계 지침이 아닌 것은?",
  "answer" : "3.모듈 간의 결합도는 강할수록 바람직하다.",
  "commentary" : "\"모듈 간의 결합도는 강할수록 바람직하다.\"는 올바른 소프트웨어 설계 지침이 아닙니다. 강한 결합도는 모듈 간의 의존성이 높아져서 유지보수와 확장이 어려워지기 때문입니다. 따라서 모듈 간의 결합도는 약할수록 바람직합니다.",
  "choices" : "1.적당한 모듈의 크기를 유지한다./2.모듈 간의 접속 관계를 분석하여 복잡도와 중복을 줄인다./3.모듈 간의 결합도는 강할수록 바람직하다./4.모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다./"
}, {
  "question" : "소프트웨어 패키징 도구 활용 시 고려 사항으로 틀린 것은?",
  "answer" : "2.보안을 위하여 이기종 연동을 고려하지 않아도 된다.",
  "commentary" : "\"보안을 위하여 이기종 연동을 고려하지 않아도 된다.\"가 틀린 이유는 다양한 시스템 간에 소프트웨어 패키지를 전달하고 설치하는 경우가 많기 때문입니다. 이기종 시스템 간에 패키지를 전달할 때는 보안 문제를 고려하여 적절한 보안 프로토콜을 사용해야 합니다. 따라서 이기종 연동을 고려하지 않으면 보안 위험이 발생할 수 있습니다.",
  "choices" : "1.반드시 내부 콘텐츠에 대한 암호화 및 보안을 고려한다./2.보안을 위하여 이기종 연동을 고려하지 않아도 된다./3.사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다./4.제품 소프트웨어 종류에 적합한 암호화 알고리즘을 적용한다./"
}, {
  "question" : "EAI(Enterprise Application Integration) 구축유형 중 Hybrid에 대한 설명으로 틀린 것은?",
  "answer" : "4.중간에 미들웨어를 두지 않고 각 애플리케이션을 point to point로 연결한다.",
  "commentary" : "중간에 미들웨어를 두지 않고 각 애플리케이션을 point to point로 연결하는 것은 Hybrid 방식이 아니라 Point-to-Point 방식이다. Hybrid 방식은 Hub & Spoke와 Message Bus를 혼합하여 사용하는 방식이며, 필요에 따라 두 가지 방식을 조합하여 EAI 구현이 가능하다. 또한 데이터 병목 현상을 최소화할 수 있다는 것도 Hybrid 방식의 장점 중 하나이다.",
  "choices" : "1.Hub & Spoke와 Message Bus의 혼합방식이다./2.필요한 경우 한 가지 방식으로 EAI구현이 가능하다./3.데이터 병목현상을 최소화할 수 있다./4.중간에 미들웨어를 두지 않고 각 애플리케이션을 point to point로 연결한다./"
}, {
  "question" : "소스코드 품질분석 도구 중 정적분석 도구가 아닌 것은?",
  "answer" : "3.valance",
  "commentary" : "정적분석 도구는 소스코드를 분석하여 코드의 오류, 버그, 보안 취약점 등을 찾아내는 도구입니다. 따라서 \"valance\"는 정적분석 도구가 아닙니다. \"valance\"는 소프트웨어 프로젝트 관리 도구로, 프로젝트 일정, 예산, 리소스 등을 관리하는 기능을 제공합니다.",
  "choices" : "1.pmd/2.checkstyle/3.valance/4.cppcheck/"
}, {
  "question" : "다음 Postfix 연산식에 대한 연산결과로 옳은 것은?",
  "answer" : "2.42",
  "commentary" : null,
  "choices" : "1.35/2.42/3.77/4.360/"
}, {
  "question" : "인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 것으로 거리가 먼 것은?",
  "answer" : "3.SMTP",
  "commentary" : "SMTP는 이메일 전송 프로토콜로, 인터페이스 보안을 위한 네트워크 영역에 적용되는 것이 아니라 이메일 전송을 위한 프로토콜이기 때문에 거리가 먼 것이다. IPSec는 인터넷 프로토콜 보안으로 네트워크 계층에서 보안을 제공하고, SSL과 S-HTTP는 웹 서버와 클라이언트 간의 통신 보안을 위한 프로토콜이다.",
  "choices" : "1.IPSec/2.SSL/3.SMTP/4.S-HTTP/"
}, {
  "question" : "검증(Validation) 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 검사하는 기법은?",
  "answer" : "4.알파 검사",
  "commentary" : "알파 검사는 개발자와 사용자가 함께 검사하는 기법으로, 개발 초기 단계에서 오류와 사용상의 문제점을 발견하고 수정할 수 있도록 돕는 검증 기법입니다. 따라서 개발자의 장소에서 사용자와 함께 검사하는 것이 특징입니다. 디버깅 검사는 오류를 찾아 수정하는 기법, 형상 검사는 개발된 소프트웨어의 버전 관리를 위한 기법, 자료구조 검사는 소프트웨어의 자료구조에 대한 검사를 의미합니다.",
  "choices" : "1.디버깅 검사/2.형상 검사/3.자료구조 검사/4.알파 검사/"
}, {
  "question" : "다음 초기 자료에 대하여 삽입 정렬(Insertion Sort)을 이용하여 오름차순 정렬할 경우 1회전 후의 결과는?",
  "answer" : "4.3, 8, 4, 9, 7",
  "commentary" : "1회전 후에는 첫 번째 원소인 3은 이미 정렬된 상태이므로 그대로 둔다. 두 번째 원소인 8은 첫 번째 원소인 3보다 크므로 그대로 둔다. 세 번째 원소인 4는 두 번째 원소인 8보다 작으므로 위치를 바꾼다. 따라서 3, 8, 4, 9, 7이 된다. 이유는 삽입 정렬은 현재 위치에서 그 이전의 원소들과 비교하여 자신이 들어갈 위치를 찾아 삽입하는 방식으로 정렬하기 때문이다.",
  "choices" : "1.3, 4, 8, 7, 9/2.3, 4, 9, 7, 8/3.7, 8, 3, 4, 9/4.3, 8, 4, 9, 7/"
}, {
  "question" : "소프트웨어 설치 매뉴얼에 대한 설명으로 틀린 것은?",
  "answer" : "3.설치 매뉴얼은 개발자 기준으로 작성한다.",
  "commentary" : "\"설치 매뉴얼은 개발자 기준으로 작성한다.\"는 틀린 설명입니다. 설치 매뉴얼은 사용자가 쉽게 따라할 수 있도록 작성되어야 하며, 따라서 사용자 중심으로 작성되어야 합니다. 개발자 기준으로 작성하면 사용자가 이해하기 어렵고, 설치 과정에서 문제가 발생할 가능성이 높아집니다.",
  "choices" : "1.설치과정에서 표시될 수 있는 예외상황에 관련 내용을 별도로 구분하여 설명한다./2.설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명한다./3.설치 매뉴얼은 개발자 기준으로 작성한다./4.설치 매뉴얼에는 목차, 개요, 기본사항 등이 기본적으로 포함되어야 한다./"
}, {
  "question" : "인터페이스 구현 검증 도구가 아닌 것은?",
  "answer" : "1.ESB",
  "commentary" : "ESB는 인터페이스 구현 검증 도구가 아니라, 기업 내부 시스템 간 통신을 위한 통합 플랫폼이기 때문에 정답입니다. xUnit, STAF, NTAF는 모두 소프트웨어 테스트 자동화를 위한 도구로, 인터페이스 구현 검증에 사용될 수 있습니다.",
  "choices" : "1.ESB/2.xUnit/3.STAF/4.NTAF/"
}, {
  "question" : "소프트웨어 형상 관리에서 관리 항목에 포함되지 않는 것은?",
  "answer" : "4.프로젝트 개발 비용",
  "commentary" : "소프트웨어 형상 관리는 소프트웨어 개발과 관련된 모든 항목을 관리하는 것이 목적입니다. 따라서 \"프로젝트 개발 비용\"은 소프트웨어 개발과 직접적으로 관련이 있지만, 형상 관리의 범주에는 포함되지 않습니다. 이는 소프트웨어 개발 프로세스에서 비용 관리와 관련된 항목으로, 형상 관리와는 별개의 관리 분야입니다.",
  "choices" : "1.프로젝트 요구 분석서/2.소스 코드/3.운영 및 설치 지침서/4.프로젝트 개발 비용/"
}, {
  "question" : "다음 설명에 해당하는 것은?",
  "answer" : "2.내부 스키마",
  "commentary" : "위 그림은 데이터베이스의 구조를 나타내는 스키마 중 하나인 \"내부 스키마\"를 나타낸다. 내부 스키마는 데이터베이스의 물리적인 구조를 정의하며, 데이터가 실제로 어떻게 저장되는지를 나타낸다. 따라서 내부 스키마는 데이터베이스 시스템의 구현과 밀접한 관련이 있다.",
  "choices" : "1.외부 스키마/2.내부 스키마/3.개념 스키마/4.슈퍼 스키마/"
}, {
  "question" : "다음 트리에 대한 INORDER 운행 결과는?",
  "answer" : "1.D B A E C F",
  "commentary" : "INORDER 운행은 왼쪽 서브트리, 루트 노드, 오른쪽 서브트리 순으로 운행하는 것이다. 따라서 이 트리의 INORDER 운행 결과는 \"D B A E C F\" 이다. 왼쪽 서브트리는 D, B, A 이고, 오른쪽 서브트리는 E, C, F 이다. 따라서 왼쪽 서브트리의 INORDER 운행 결과인 \"D B A\" 다음에 루트 노드인 \"E\"가 오고, 그 다음에 오른쪽 서브트리의 INORDER 운행 결과인 \"C F\"가 온다. 따라서 전체적인 INORDER 운행 결과는 \"D B A E C F\" 이다.",
  "choices" : "1.D B A E C F/2.A B D C E F/3.D B E C F A/4.A B C D E F/"
}, {
  "question" : "n 개의 노드로 구성된 무방향 그래프의 최대 간선수는?",
  "answer" : "3.n(n－1)／2",
  "commentary" : "무방향 그래프에서 각 노드는 다른 모든 노드와 연결될 수 있으므로, 각 노드는 n-1개의 간선을 가질 수 있습니다. 따라서 n개의 노드가 모두 n-1개의 간선을 가지면, 그래프의 총 간선 수는 n(n-1)이 됩니다. 그러나 이 간선 수는 각 간선이 두 번씩 계산되었으므로, 최종적으로 총 간선 수는 n(n-1)/2가 됩니다. 따라서 정답은 \"n(n－1)／2\"입니다.",
  "choices" : "1.n－1/2.n／2/3.n(n－1)／2/4.n(n＋1)/"
}, {
  "question" : "다음이 설명하는 테스트 용어는?",
  "answer" : "3.테스트 오라클",
  "commentary" : "위 그림은 테스트 오라클을 나타내고 있습니다. 테스트 오라클은 테스트 결과를 검증하기 위한 기준이나 규칙을 말합니다. 즉, 테스트 케이스를 실행한 결과가 예상한 결과와 일치하는지를 판단하는 기준이 되는 것입니다. 따라서, 정답은 \"테스트 오라클\"입니다.",
  "choices" : "1.테스트 케이스/2.테스트 시나리오/3.테스트 오라클/4.테스트 데이터/"
}, {
  "question" : "빌드 자동화 도구에 대한 설명으로 틀린 것은?",
  "answer" : "4.Jenkins는 Groovy 기반으로 한 오픈소스로 안드로이드 앱 개발 환경에서 사용된다.",
  "commentary" : "정답은 \"Jenkins는 Groovy 기반으로 한 오픈소스로 안드로이드 앱 개발 환경에서 사용된다.\" 이다. 이유는 Jenkins는 안드로이드 앱 개발 환경에서 사용되는 것이 아니라, 지속적인 통합 및 배포를 위한 자동화 도구로 널리 사용되며, 다양한 프로그래밍 언어와 툴체인을 지원한다.",
  "choices" : "1.Gradle은 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행한다./2.빌드 자동화 도구는 지속적인 통합개발환경 에 서 유용하게 활용된다./3.빌드 자동화 도구에는 Ant, Gradle, Jenkins등이 있다./4.Jenkins는 Groovy 기반으로 한 오픈소스로 안드로이드 앱 개발 환경에서 사용된다./"
}, {
  "question" : "저작권 관리 구성 요소에 대한 설명이 틀린 것은?",
  "answer" : "2.콘텐츠 분배자(Contents Distributor) : 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능",
  "commentary" : null,
  "choices" : "1.콘텐츠 제공자(Contents Provider) : 콘텐츠를 제공하는 저작권자/2.콘텐츠 분배자(Contents Distributor) : 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능/3.클리어링 하우스(Clearing House) : 키 관리 및 라이선스 발급 관리/4.DRM 컨트롤러 : 배포된 콘텐츠의 이용 권한을 통제/"
}, {
  "question" : "블랙박스 테스트 기법으로 거리가 먼 것은?",
  "answer" : "1.기초 경로 검사",
  "commentary" : "기초 경로 검사는 프로그램의 모든 가능한 경로를 식별하고 각 경로를 한 번 이상 실행하여 프로그램의 오류를 찾는 데 사용되는 테스트 기법입니다. 따라서 다른 세 가지 옵션인 동치 클래스 분해, 경계값 분석, 원인 결과 그래프는 특정 입력 값에 대한 테스트를 중점적으로 수행하는 데 비해, 기초 경로 검사는 프로그램의 전반적인 동작을 테스트하는 데 초점을 맞추고 있습니다. 이러한 이유로 기초 경로 검사는 블랙박스 테스트 기법 중에서 거리가 먼 것으로 선택됩니다.",
  "choices" : "1.기초 경로 검사/2.동치 클래스 분해/3.경계값 분석/4.원인 결과 그래프/"
}, {
  "question" : "해싱함수 중 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방식은?",
  "answer" : "2.폴딩법",
  "commentary" : "해싱함수 중 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방식은 폴딩법이다. 이는 레코드 키를 여러 부분으로 나누어 각 부분을 더하거나 XOR하여 홈 주소를 생성하기 때문에, 레코드 키의 일부분만을 이용하여 해시값을 생성할 수 있어서 효율적이다. 또한, 레코드 키의 길이가 다른 경우에도 적용할 수 있어서 유용하다.",
  "choices" : "1.제산법/2.폴딩법/3.기수변환법/4.숫자분석법/"
}, {
  "question" : "다음에서 설명하는 클린 코드 작성 원칙은?",
  "answer" : "2.단순성",
  "commentary" : "단순성은 코드를 간결하고 명확하게 작성하는 것을 의미합니다. 위의 코드에서도 변수명과 함수명이 명확하게 작성되어 있고, 불필요한 코드가 없어서 코드를 이해하기 쉽습니다. 이는 코드의 가독성을 높이고 유지보수를 용이하게 만들어줍니다. 따라서 단순성은 클린 코드 작성의 중요한 원칙 중 하나입니다.",
  "choices" : "1.다형성/2.단순성/3.추상화/4.의존성/"
}, {
  "question" : "디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?",
  "answer" : "3.콘텐츠 오류 감지 및 복구",
  "commentary" : "콘텐츠 오류 감지 및 복구는 디지털 저작권 관리(DRM) 기술과 거리가 먼 것이다. 이는 콘텐츠의 무결성을 보장하고, 오류가 발생했을 때 복구할 수 있도록 하는 기술로, DRM과는 별개의 기술이다. 즉, DRM은 콘텐츠의 저작권 보호를 위한 기술이며, 콘텐츠 오류 감지 및 복구는 콘텐츠의 품질 유지를 위한 기술이다.",
  "choices" : "1.콘텐츠 암호화 및 키 관리/2.콘텐츠 식별체계 표현/3.콘텐츠 오류 감지 및 복구/4.라이선스 발급 및 관리/"
}, {
  "question" : "다음 설명과 관련 있는 트랜잭션의 특징은?",
  "answer" : "4.Atomicity",
  "commentary" : "트랜잭션은 \"Atomicity\" 특징을 가지고 있다. Atomicity는 트랜잭션이 하나의 원자적인 작업 단위로 실행되어 중간에 어떠한 문제가 발생하더라도 모든 작업이 완전히 실행되거나 전혀 실행되지 않는 것을 의미한다. 즉, 트랜잭션 내의 모든 작업이 성공적으로 완료되면 모든 작업이 커밋되고, 하나의 작업이라도 실패하면 모든 작업이 롤백되어 이전 상태로 되돌아간다는 것이다.",
  "choices" : "1.Durability/2.Isolation/3.Consistency/4.Atomicity/"
}, {
  "question" : "데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?",
  "answer" : "3.CRUD 분석",
  "commentary" : "CRUD 분석은 데이터베이스에서 가장 기본적인 작업인 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete) 연산을 통해 데이터베이스에 영향을 주는 프로세스와 테이블 간의 매트릭스를 만들어서 트랜잭션을 분석하는 것입니다. 이를 통해 데이터베이스의 안정성과 일관성을 유지하며, 데이터베이스의 성능을 최적화할 수 있습니다. 따라서 CRUD 분석은 데이터베이스 설계와 운영에서 매우 중요한 역할을 합니다.",
  "choices" : "1.CASE 분석/2.일치 분석/3.CRUD 분석/4.연관성 분석/"
}, {
  "question" : "정규화된 엔티티, 속성, 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법은?",
  "answer" : "2.반정규화",
  "commentary" : "반정규화는 정규화된 데이터 모델에서 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법입니다. 따라서 이 중에서 반정규화가 정답입니다.",
  "choices" : "1.인덱스정규화/2.반정규화/3.집단화/4.머징/"
}, {
  "question" : "학생 테이블을 생성한 후, 성별 필드가 누락되어 이를 추가하려고 한다. 이에 적합한 SQL 명령어는?",
  "answer" : "2.ALTER",
  "commentary" : "정답은 \"ALTER\"이다. \"ALTER\"는 이미 존재하는 테이블의 구조를 변경할 때 사용하는 SQL 명령어이다. 따라서 성별 필드를 추가하기 위해서는 \"ALTER\" 명령어를 사용해야 한다. \"INSERT\"는 새로운 레코드를 추가할 때 사용하는 명령어이고, \"DROP\"은 테이블 자체를 삭제할 때 사용하는 명령어이다. \"MODIFY\"는 필드의 데이터 타입이나 크기를 변경할 때 사용하는 명령어이다.",
  "choices" : "1.INSERT/2.ALTER/3.DROP/4.MODIFY/"
}, {
  "question" : "정규화의 필요성으로 거리가 먼 것은?",
  "answer" : "2.중복 데이터의 활성화",
  "commentary" : "중복 데이터가 존재하면 데이터의 일관성이 깨지고, 데이터의 수정 및 삭제 시에도 이상현상이 발생할 가능성이 높아집니다. 따라서 중복 데이터를 최소화하고 데이터 구조를 안정화시키기 위해 정규화가 필요합니다.",
  "choices" : "1.데이터 구조의 안정성 최대화/2.중복 데이터의 활성화/3.수정, 삭제 시 이상현상의 최소화/4.테이블 불일치 위험의 최소화/"
}, {
  "question" : "개체-관계 모델의 E-R 다이어그램에서 사용되는 기호와 그 의미의 연결이 틀린 것은?",
  "answer" : "2.삼각형 - 속성",
  "commentary" : "E-R 다이어그램에서 삼각형은 개체 타입이 아닌 속성을 나타냅니다. 개체 타입은 사각형으로 표시됩니다. 삼각형은 속성을 나타내며, 속성은 개체 타입과 관련된 특성을 나타냅니다. 따라서 정답은 \"삼각형 - 속성\"입니다.",
  "choices" : "1.사각형 - 개체 타입/2.삼각형 - 속성/3.선 - 개체타입과 속성을 연결/4.마름모 - 관계 타입/"
}, {
  "question" : "다음 SQL문에서 빈칸에 들어갈 내용으로 옳은 것은?",
  "answer" : "2.SET",
  "commentary" : "이 SQL문은 UPDATE 문으로, 특정 테이블의 데이터를 수정하는 쿼리입니다. SET은 업데이트할 열(column)과 값을 지정하는 구문입니다. 따라서 정답은 \"SET\"입니다. FROM은 데이터를 가져올 테이블을 지정하는 구문, INTO는 데이터를 새로운 테이블에 삽입하는 구문, TO는 데이터를 이동시키는 구문입니다.",
  "choices" : "1.FROM/2.SET/3.INTO/4.TO/"
}, {
  "question" : "릴레이션에 있는 모든 튜플에 대해 유일성은 만족시키지만 최소성은 만족시키지 못하는 키는?",
  "answer" : "3.슈퍼키",
  "commentary" : "슈퍼키는 릴레이션에서 유일성을 만족시키는 하나 이상의 속성들의 집합이며, 최소성을 만족시키지 못할 수 있습니다. 따라서 슈퍼키는 후보키나 기본키로 선택되지 않습니다. 반면에 후보키는 유일성과 최소성을 모두 만족시키는 속성 또는 속성의 집합이며, 기본키는 후보키 중에서 선택된 주 식별자입니다. 외래키는 다른 릴레이션의 기본키를 참조하는 속성입니다.",
  "choices" : "1.후보키/2.기본키/3.슈퍼키/4.외래키/"
}, {
  "question" : "DBA가 사용자 PARK에게 테이블 [STUDENT]의 데이터를 갱신할 수 있는 시스템 권한을 부여하고자 하는 SQL문을 작성하고자 한다. 다음에 주어진 SQL문의 빈칸을 알맞게 채운 것은?",
  "answer" : "3.㉠ UPDATE, ㉡ ON",
  "commentary" : "SQL문: GRANT UPDATE ON STUDENT TO PARK; - \"UPDATE\"는 권한의 종류를 나타내는 키워드이다. - \"ON\"은 권한을 부여할 대상 테이블을 지정하는 키워드이다. 따라서 정답은 \"㉠ UPDATE, ㉡ ON\"이다. - \"INSERT\"는 데이터를 삽입하는 키워드이며, \"INTO\"는 삽입할 테이블을 지정하는 키워드이다. - \"ALTER\"는 테이블 구조를 변경하는 키워드이며, \"TO\"는 변경할 대상을 지정하는 키워드이다. - \"REPLACE\"는 데이터를 대체하는 키워드이며, \"IN\"은 대체할 테이블을 지정하는 키워드이다.",
  "choices" : "1.㉠ INSERT, ㉡ INTO/2.㉠ ALTER, ㉡ TO/3.㉠ UPDATE, ㉡ ON/4.㉠ REPLACE, ㉡ IN/"
}, {
  "question" : "관계대수에 대한 설명으로 틀린 것은?",
  "answer" : "4.원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 비절차적방법이다.",
  "commentary" : "\"원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 비절차적방법이다.\"가 틀린 설명입니다. 관계대수는 주어진 릴레이션 조작을 위한 연산의 집합이며, 일반 집합 연산과 순수 관계 연산으로 구분됩니다. 또한, 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시합니다.",
  "choices" : "1.주어진 릴레이션 조작을 위한 연산의 집합이다./2.일반 집합 연산과 순수 관계 연산으로 구분된다./3.질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다./4.원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 비절차적방법이다./"
}, {
  "question" : "다음 SQL문의 실행 결과는?",
  "answer" : "3.",
  "commentary" : null,
  "choices" : "1./2./3./4./"
}, {
  "question" : "로킹(Locking) 기법에 대한 설명으로 틀린 것은?",
  "answer" : "2.로킹 단위가 작아지면 병행성 수준이 낮아진다.",
  "commentary" : "로킹 단위가 작아지면 병행성 수준이 낮아진다는 설명이 틀린 것이다. 로킹 단위가 작아지면 더 많은 객체가 로킹될 수 있어서 병행성 수준이 높아질 수 있다. 로킹 단위가 커지면 로크 수가 작아져서 로킹 오버헤드가 감소한다는 것은 맞다. 데이터베이스도 로킹 단위가 될 수 있다는 것은 맞다. 로킹의 대상이 되는 객체의 크기를 로킹 단위라고 하는 것도 맞다.",
  "choices" : "1.로킹의 대상이 되는 객체의 크기를 로킹 단위라고 한다./2.로킹 단위가 작아지면 병행성 수준이 낮아진다./3.데이터베이스도 로킹 단위가 될 수 있다./4.로킹 단위가 커지면 로크 수가 작아 로킹 오버헤드가 감소한다./"
}, {
  "question" : "사용자 X1에게 department 테이블에 대한 검색 연산을 회수하는 명령은?",
  "answer" : "3.revoke select on department from X1;",
  "commentary" : "정답은 \"revoke select on department from X1;\"이다. \"delete select on department to X1;\"은 올바른 구문이 아니며, \"remove select on department from X1;\"은 존재하지 않는 구문이다. \"grant select on department from X1;\"은 권한을 부여하는 명령어이지만, 문제에서는 권한을 회수하는 것이 요구되고 있기 때문에 올바르지 않다. 따라서, \"revoke select on department from X1;\"이 올바른 구문이다. 이 명령어는 사용자 X1에게 부여된 department 테이블에 대한 검색 권한을 회수하는 명령어이다.",
  "choices" : "1.delete select on department to X1;/2.remove select on department from X1;/3.revoke select on department from X1;/4.grant select on department from X1;/"
}, {
  "question" : "뷰(VIEW)에 대한 설명으로 틀린 것은?",
  "answer" : "3.뷰의 정의는 기본 테이블과 같이 ALTER문을 이용하여 변경한다.",
  "commentary" : "\"뷰의 정의는 기본 테이블과 같이 ALTER문을 이용하여 변경한다.\"이 틀린 것이다. 뷰의 정의는 CREATE VIEW 문을 사용하여 정의하며, ALTER VIEW 문을 사용하여 변경할 수 있다.",
  "choices" : "1.뷰 위에 또 다른 뷰를 정의할 수 있다./2.뷰에 대한 조작에서 삽입, 갱신, 삭제 연산은 제약이 따른다./3.뷰의 정의는 기본 테이블과 같이 ALTER문을 이용하여 변경한다./4.뷰가 정의된 기본 테이블이 제거되면 뷰도 자동적으로 제거된다./"
}, {
  "question" : "데이터 모델에 표시해야 할 요소로 거리가 먼 것은?",
  "answer" : "2.출력 구조",
  "commentary" : "다른 요소들은 데이터 모델의 구성 요소로서 데이터의 구조와 관계를 표현하는 것이지만, 출력 구조는 데이터 모델의 외부에서 데이터를 표시하는 방법에 대한 것이므로 데이터 모델에 표시할 필요가 없다. 따라서 출력 구조가 데이터 모델에 표시해야 할 요소로서는 거리가 먼 것이다.",
  "choices" : "1.논리적 데이터 구조/2.출력 구조/3.연산/4.제약조건/"
}, {
  "question" : "제 3정규형에서 보이스코드 정규형(BCNF)으로 정규화하기 위한 작업은?",
  "answer" : "4.결정자가 후보키가 아닌 함수 종속 제거",
  "commentary" : "BCNF는 제 3정규형에서 발생할 수 있는 결정자가 후보키가 아닌 함수 종속을 제거하여 얻을 수 있는 정규형이다. 이는 하나의 속성이 다른 속성의 값을 결정하는 경우, 결정자가 후보키가 아니면 문제가 발생할 수 있기 때문이다. 따라서 BCNF로 정규화하기 위해서는 결정자가 후보키가 아닌 함수 종속을 제거해야 한다.",
  "choices" : "1.원자 값이 아닌 도메인을 분해/2.부분 함수 종속 제거/3.이행 함수 종속 제거/4.결정자가 후보키가 아닌 함수 종속 제거/"
}, {
  "question" : "A1, A2, A3 3개 속성을 갖는 한 릴레이션에서 A1의 도메인은 3개 값, A2의 도메인은 2개 값, A3의 도메인은 4개 값을 갖는다. 이 릴레이션에 존재할 수 있는 가능한 튜플(Tuple)의 최대 수는?",
  "answer" : "1.24",
  "commentary" : "릴레이션에 존재할 수 있는 가능한 튜플의 최대 수는 각 속성의 도메인 값들의 곱과 같다. 따라서, A1의 도메인 값이 3개, A2의 도메인 값이 2개, A3의 도메인 값이 4개 이므로, 가능한 튜플의 최대 수는 3 x 2 x 4 = 24 이다. 따라서, 정답은 \"24\"이다.",
  "choices" : "1.24/2.12/3.8/4.9/"
}, {
  "question" : "데이터베이스 설계 시 물리적 설계 단계에서 수행하는 사항이 아닌 것은?",
  "answer" : "4.목표 DBMS에 맞는 스키마 설계",
  "commentary" : "목표 DBMS에 맞는 스키마 설계는 논리적 설계 단계에서 수행하는 사항이기 때문에 물리적 설계 단계에서는 수행하지 않는다. 물리적 설계 단계에서는 저장 레코드 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계 등의 작업을 수행한다.",
  "choices" : "1.저장 레코드 양식 설계/2.레코드 집중의 분석 및 설계/3.접근 경로 설계/4.목표 DBMS에 맞는 스키마 설계/"
}, {
  "question" : "한 릴레이션 스키마가 4개 속성, 2개 후보키 그리고 그 스키마의 대응 릴레이션 인스턴스가 7개 튜플을 갖는다면 그 릴레이션의 차수(degree)는?",
  "answer" : "3.4",
  "commentary" : "릴레이션의 차수는 릴레이션 스키마에 속한 속성의 수를 의미한다. 따라서 이 문제에서는 릴레이션 스키마가 4개 속성을 갖고 있으므로, 릴레이션의 차수는 4이다. 후보키와 튜플의 수는 릴레이션의 차수와는 직접적인 연관이 없다.",
  "choices" : "1.1/2.2/3.4/4.7/"
}, {
  "question" : "데이터웨어하우스의 기본적인 OLAP(on-line analytical processing) 연산이 아닌 것은?",
  "answer" : "1.translate",
  "commentary" : "\"Translate\"는 OLAP 연산 중 하나가 아니기 때문에 정답입니다. \"Roll-up\", \"dicing\", \"drill-down\"은 OLAP 연산의 기본적인 형태로, 데이터를 다양한 각도에서 분석하고 요약하는 데 사용됩니다. \"Roll-up\"은 상위 수준의 데이터로 집계하고 \"drill-down\"은 하위 수준의 데이터로 세분화합니다. \"Dicing\"은 다차원 데이터를 잘라서 특정 부분 집합을 분석하는 것을 의미합니다.",
  "choices" : "1.translate/2.roll-up/3.dicing/4.drill-down/"
}, {
  "question" : "UNIX SHELL 환경 변수를 출력하는 명령어가 아닌 것은?",
  "answer" : "1.configenv",
  "commentary" : "\"configenv\"는 UNIX SHELL에서 사용되는 환경 변수를 출력하는 명령어가 아니기 때문에 정답이다. \"printenv\", \"env\", \"setenv\"는 모두 UNIX SHELL에서 사용되는 환경 변수를 출력하거나 설정하는 명령어이다.",
  "choices" : "1.configenv/2.printenv/3.env/4.setenv/"
}, {
  "question" : "Java 프로그래밍 언어의 정수 데이터 타입 중 'long'의 크기는?",
  "answer" : "4.8byte",
  "commentary" : "'long'은 64비트 크기의 정수 데이터 타입으로, 8바이트의 메모리 공간을 차지합니다. 이는 'int'와 같은 32비트 크기의 정수 데이터 타입보다 두 배 큰 범위의 값을 저장할 수 있습니다. 따라서 'long'은 매우 큰 정수 값을 다룰 때 유용하게 사용됩니다.",
  "choices" : "1.1byte/2.2byte/3.4byte/4.8byte/"
}, {
  "question" : "Java에서 사용되는 출력 함수가 아닌 것은?",
  "answer" : "3.System.out.printing( )",
  "commentary" : "정답은 \"System.out.printing( )\"입니다. 이유는 Java에서 출력 함수는 \"System.out.print( )\", \"System.out.println( )\", \"System.out.printf( )\"이 있지만 \"System.out.printing( )\"은 존재하지 않기 때문입니다. 따라서 이 함수는 사용할 수 없습니다.",
  "choices" : "1.System.out.print( )/2.System.out.println( )/3.System.out.printing( )/4.System.out.printf( )/"
}, {
  "question" : "운영체제에서 커널의 기능이 아닌 것은?",
  "answer" : "2.사용자 인터페이스",
  "commentary" : "커널은 운영체제의 핵심 부분으로, 하드웨어와 소프트웨어 간의 인터페이스 역할을 합니다. 따라서 커널의 주요 기능은 하드웨어 자원 관리, 프로세스 관리, 메모리 관리, 파일 시스템 관리 등입니다. 반면에 사용자 인터페이스는 운영체제의 일부분이지만, 커널의 기능은 아닙니다. 사용자 인터페이스는 사용자와 컴퓨터 간의 상호작용을 위한 인터페이스로, 그래픽 사용자 인터페이스(GUI)나 명령 줄 인터페이스(CLI) 등이 있습니다. 따라서 \"사용자 인터페이스\"가 커널의 기능이 아닌 것입니다.",
  "choices" : "1.프로세스 생성, 종료/2.사용자 인터페이스/3.기억 장치 할당, 회수/4.파일 시스템 관리/"
}, {
  "question" : "OSI 7계층에서 단말기 사이에 오류 수정과 흐름제어를 수행하여 신뢰성 있고 명확한 데이터를 전달하는 계층은?",
  "answer" : "1.전송 계층",
  "commentary" : "전송 계층은 단말기 사이에 데이터를 전송하면서 오류 수정과 흐름제어를 수행하여 신뢰성 있고 명확한 데이터를 전달하는 역할을 합니다. 이를 위해 전송 계층은 TCP 프로토콜과 UDP 프로토콜을 사용합니다. 따라서 OSI 7계층에서 단말기 사이에 오류 수정과 흐름제어를 수행하여 신뢰성 있고 명확한 데이터를 전달하는 계층은 전송 계층입니다.",
  "choices" : "1.전송 계층/2.응용 계층/3.세션 계층/4.표현 계층/"
}, {
  "question" : "다음 쉘 스크립트의 의미로 옳은 것은?",
  "answer" : "2.wow 사용자가 로그인할 때까지 반복문을 수행한다.",
  "commentary" : null,
  "choices" : "1.wow 사용자가 로그인한 경우에만 반복문을 수행한다./2.wow 사용자가 로그인할 때까지 반복문을 수행한다./3.wow 문자열을 복사한다./4.wow 사용자에 대한 정보를 무한 반복하여 출력한다./"
}, {
  "question" : "다음 자바 코드를 실행한 결과는?",
  "answer" : "4.Unresolved compilation problem 오류 발생",
  "commentary" : null,
  "choices" : "1.x＝7 y＝0/2.x＝6 y＝-1/3.x＝7 y＝-1/4.Unresolved compilation problem 오류 발생/"
}, {
  "question" : "다음 파이썬으로 구현된 프로그램의 실행 결과로 옳은 것은?",
  "answer" : "3.[0, 20, 40, 60]",
  "commentary" : null,
  "choices" : "1.[20, 60]/2.[60, 20]/3.[0, 20, 40, 60]/4.[10, 30, 50, 70]/"
}, {
  "question" : "공통모듈의 재사용 범위에 따른 분류가 아닌 것은?",
  "answer" : "2.더미코드 재사용",
  "commentary" : "더미코드 재사용은 실제로 코드를 재사용하는 것이 아니라, 테스트나 디버깅 등을 위해 임시로 작성한 코드를 재사용하는 것을 말합니다. 따라서 공통모듈의 재사용 범위에 따른 분류와는 관련이 없습니다.",
  "choices" : "1.컴포넌트 재사용/2.더미코드 재사용/3.함수와 객체 재사용/4.애플리케이션 재사용/"
}, {
  "question" : "다음과 같은 프로세스가 차례로 큐에 도착하였을 때, SJF(Shortest Job First) 정책을 사용할 경우 가장 먼저 처리되는 작업은?",
  "answer" : "4.P4",
  "commentary" : "SJF 정책은 도착한 작업 중에서 실행 시간이 가장 짧은 작업을 먼저 처리하는 방식입니다. 따라서, 위의 프로세스에서 P4가 실행 시간이 가장 짧기 때문에 가장 먼저 처리됩니다.",
  "choices" : "1.P1/2.P2/3.P3/4.P4/"
}, {
  "question" : "4개의 페이지를 수용할 수 있는 주기억장치가 있으며, 초기에는 모두 비어 있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, FIFO 페이지 교체 알고리즘을 사용할 경우 페이지 결함의 발생 횟수는?",
  "answer" : "1.6회",
  "commentary" : "주어진 페이지 프레임이 4개이므로, 처음 4개의 페이지 참조는 모두 페이지 결함이 발생하지 않는다. 그러나 5번째 페이지 참조부터는 새로운 페이지를 적재하기 위해 기존의 페이지 중 하나를 교체해야 한다. 따라서 5번째 페이지 참조에서는 페이지 결함이 발생하며, 이때 가장 먼저 적재된 페이지인 1번 페이지가 교체된다. 이후 6, 7, 8번째 페이지 참조에서도 페이지 결함이 발생하며, 각각 2, 3, 4번 페이지가 교체된다. 마지막으로 9번째 페이지 참조에서는 이미 적재된 페이지 중에서 참조할 페이지가 있으므로 페이지 결함이 발생하지 않는다. 따라서 페이지 결함의 발생 횟수는 총 6회이다.",
  "choices" : "1.6회/2.7회/3.8회/4.9회/"
}, {
  "question" : "TCP 흐름제어기법 중 프레임이 손실되었을 때, 손실된 프레임 1개를 전송하고 수신자의 응답을 기다리는 방식으로 한 번에 프레임 1개만 전송할 수 있는 기법은?",
  "answer" : "3.Stop and Wait",
  "commentary" : "Stop and Wait 기법은 송신자가 프레임을 전송하면, 수신자는 해당 프레임을 받았다는 응답을 보내고, 송신자는 이 응답을 받아야 다음 프레임을 전송할 수 있는 방식입니다. 따라서, 손실된 프레임이 있을 경우에는 해당 프레임을 다시 전송하고, 수신자의 응답을 기다려야 합니다. 이러한 방식으로 한 번에 하나의 프레임만 전송할 수 있기 때문에 Stop and Wait 기법이라고 합니다.",
  "choices" : "1.Slow Start/2.Sliding Window/3.Stop and Wait/4.Congestion Avoidance/"
}, {
  "question" : "결합도(Coupling)에 대한 설명으로 틀린 것은?",
  "answer" : "1.데이터 결합도(Data Coupling)는 두 모듈이 매개변수로 자료를 전달할 때, 자료구조 형태로 전달되어 이용될 때 데이터가 결합되어 있다고 한다.",
  "commentary" : "정답은 \"데이터 결합도(Data Coupling)는 두 모듈이 매개변수로 자료를 전달할 때, 자료구조 형태로 전달되어 이용될 때 데이터가 결합되어 있다고 한다.\"가 아니다. 데이터 결합도는 모듈 간에 데이터를 전달하는 방식에 따라 결합도를 나타내는 것이며, 자료구조 형태로 전달되는 것이 아니라 매개변수로 전달되는 것이다.",
  "choices" : "1.데이터 결합도(Data Coupling)는 두 모듈이 매개변수로 자료를 전달할 때, 자료구조 형태로 전달되어 이용될 때 데이터가 결합되어 있다고 한다./2.내용 결합도(Content Coupling)는 하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때 두 모듈은 내용적으로 결합되어 있다고 한다./3.공통 결합도(Common Coupling)는 두 모듈이 동일한 전역 데이터를 접근한다면 공통결합 되어 있다고 한다./4.결합도(Coupling)는 두 모듈간의 상호작용, 또는 의존도 정도를 나타내는 것이다./"
}, {
  "question" : "응집도의 종류 중 서로 간에 어떠한 의미 있는 연관관계도 지니지 않은 기능 요소로 구성되는 경우이며, 서로 다른 상위 모듈에 의해 호출되어 처리상의 연관성이 없는 서로 다른 기능을 수행하는 경우의 응집도는?",
  "answer" : "4.Coincidental Cohesion",
  "commentary" : "Coincidental Cohesion은 기능 요소들이 서로 의미 있는 연관관계를 가지지 않고, 처리상의 연관성이 없는 서로 다른 기능을 수행하는 경우를 말한다. 즉, 우연히 같은 모듈에 묶인 것이라고 할 수 있다. 다른 종류의 응집도들은 모듈 내부의 기능 요소들이 서로 연관되어 있는 정도에 따라 구분되는 반면, Coincidental Cohesion은 그 어떠한 연관성도 없는 기능 요소들로 이루어진 경우이다.",
  "choices" : "1.Functional Cohesion/2.Sequential Cohesion/3.Logical Cohesion/4.Coincidental Cohesion/"
}, {
  "question" : "자바에서 사용하는 접근제어자의 종류가 아닌 것은?",
  "answer" : "1.internal",
  "commentary" : "정답은 \"internal\"입니다. 이유는 자바에서는 \"internal\" 접근제어자가 존재하지 않기 때문입니다. 대신에 자바에서는 \"protected\" 접근제어자가 존재합니다. \"protected\" 접근제어자는 같은 패키지 내에서는 접근이 가능하고, 다른 패키지에서는 상속받은 클래스에서만 접근이 가능합니다.",
  "choices" : "1.internal/2.private/3.default/4.public/"
}, {
  "question" : "UDP 특성에 해당되는 것은?",
  "answer" : "3.흐름제어나 순서제어가 없어 전송속도가 빠르다.",
  "commentary" : "UDP는 흐름제어나 순서제어가 없기 때문에 데이터를 전송하는 과정에서 추가적인 제어 정보를 주고받지 않아도 되어 전송속도가 빠르다는 특성이 있습니다. 이는 TCP와는 달리 데이터 전송 후 ACK를 받지 않는다는 것을 의미합니다.",
  "choices" : "1.데이터 전송 후, ACK를 받는다./2.송신 중에 링크를 유지 관리하므로 신뢰성이 높다./3.흐름제어나 순서제어가 없어 전송속도가 빠르다./4.제어를 위한 오버헤드가 크다./"
}, {
  "question" : "다음과 같은 세그먼트 테이블을 가지는 시스템에서 논리 주소(2, 176)에 대한 물리 주소는?",
  "answer" : "1.398",
  "commentary" : null,
  "choices" : "1.398/2.400/3.1928/4.1930/"
}, {
  "question" : "TCP/IP에서 사용되는 논리주소를 물리주소로 변환시켜 주는 프로토콜은?",
  "answer" : "2.ARP",
  "commentary" : "ARP는 Address Resolution Protocol의 약자로, TCP/IP에서 사용되는 논리주소인 IP 주소를 해당 장치의 물리주소인 MAC 주소로 변환시켜 주는 프로토콜입니다. 따라서 ARP가 정답입니다.",
  "choices" : "1.TCP/2.ARP/3.FTP/4.IP/"
}, {
  "question" : "C언어에서 구조체를 사용하여 데이터를 처리할 때 사용하는 것은?",
  "answer" : "3.struct",
  "commentary" : "구조체는 C언어에서 데이터를 그룹화하고 관리하기 위해 사용하는 데이터 타입이다. 구조체를 사용하면 여러 개의 변수를 하나의 논리적인 단위로 묶어서 처리할 수 있으며, 이를 통해 코드의 가독성과 유지보수성을 높일 수 있다. 따라서 C언어에서 구조체를 사용하여 데이터를 처리할 때는 \"struct\"를 사용한다.",
  "choices" : "1.for/2.scanf/3.struct/4.abstract/"
}, {
  "question" : "PHP에서 사용 가능한 연산자가 아닌 것은?",
  "answer" : "2.#",
  "commentary" : "정답은 \"#\"입니다. \"@\"은 변수나 함수 이름 앞에 사용되는 연산자로서, \"＜＞\"는 비교 연산자로서, \"===\"는 일치 연산자로서 PHP에서 모두 사용 가능한 연산자입니다. 하지만 \"#\"은 PHP에서 사용되지 않는 연산자입니다.",
  "choices" : "1.@/2.#/3.＜＞/4.===/"
}, {
  "question" : "이용자가 인터넷과 같은 공중망에 사설망을 구축하여 마치 전용망을 사용하는 효과를 가지는 보안 솔루션은?",
  "answer" : "4.VPN",
  "commentary" : "VPN은 Virtual Private Network의 약자로, 인터넷과 같은 공중망에 사설망을 구축하여 마치 전용망을 사용하는 효과를 가지는 보안 솔루션입니다. 이를 통해 인터넷을 통해 전송되는 데이터를 암호화하여 보호하고, 외부에서의 침입을 막아줍니다. 따라서 VPN은 보안성이 높은 인터넷 연결을 제공하며, 원격지에서 안전하게 업무를 처리할 수 있도록 도와줍니다.",
  "choices" : "1.ZIGBEE/2.KDD/3.IDS/4.VPN/"
}, {
  "question" : "CMM(Capability Maturity Model) 모델의 레벨로 옳지 않은 것은?",
  "answer" : "3.계획단계",
  "commentary" : "CMM 모델의 레벨로 옳지 않은 것은 \"최적단계\"가 아니라 \"계획단계\"입니다. CMM 모델은 소프트웨어 개발 프로세스의 성숙도를 5단계로 나누어 평가하는 모델입니다. 이 중 \"최적단계\"는 가장 높은 단계로, 프로세스의 지속적인 개선과 최적화가 이루어지는 단계입니다. \"계획단계\"는 CMM 모델에서 2단계로, 프로세스의 목표를 설정하고 계획을 수립하는 단계입니다.",
  "choices" : "1.최적단계/2.관리단계/3.계획단계/4.정의단계/"
}, {
  "question" : "다음 설명에 해당하는 생명주기 모형으로 가장 옳은 것은?",
  "answer" : "3.폭포수 모형",
  "commentary" : "위 그림은 폭포수 모형으로, 개발 단계를 순차적으로 진행하며 이전 단계가 완료되어야 다음 단계로 넘어가는 선형적인 모형이다. 각 단계에서는 이전 단계에서 정의된 요구사항을 기반으로 설계, 구현, 검증, 유지보수 등의 작업이 이루어진다. 이 모형은 초기 개발 비용이 높고 변경이 어렵지만, 요구사항이 명확하고 변동이 적은 프로젝트에 적합하다.",
  "choices" : "1.패키지 모형/2.코코모 모형/3.폭포수 모형/4.관계형 모델/"
}, {
  "question" : "서비스 지향 아키텍처 기반 애플리케이션을 구성하는 층이 아닌 것은?",
  "answer" : "3.제어 클래스층",
  "commentary" : "제어 클래스층은 서비스 지향 아키텍처에서 사용되지 않는다. 대신, 서비스 지향 아키텍처에서는 표현층, 프로세스층, 비즈니스층으로 구성된다. 제어 클래스층은 일반적으로 모델-뷰-컨트롤러(MVC) 아키텍처에서 사용된다.",
  "choices" : "1.표현층/2.프로세스층/3.제어 클래스층/4.비즈니스층/"
}, {
  "question" : "다음 내용이 설명하는 스토리지 시스템은?",
  "answer" : "1.DAS",
  "commentary" : "이 스토리지 시스템은 \"DAS\" (Direct Attached Storage)이다. 이는 컴퓨터에 직접 연결되어 있는 스토리지 시스템으로, 네트워크를 통해 다른 컴퓨터와 공유되지 않는다. 그림에서 보이는 것처럼, 스토리지 디바이스가 컴퓨터에 직접 연결되어 있기 때문에 데이터 전송 속도가 빠르고 안정적이다.",
  "choices" : "1.DAS/2.NAS/3.N-SCREEN/4.NFC/"
}, {
  "question" : "소프트웨어 개발 프레임워크의 적용 효과로 볼 수 없는 것은?",
  "answer" : "2.기술종속으로 인한 선행사업자 의존도 증대",
  "commentary" : "소프트웨어 개발 프레임워크의 적용으로 기술종속으로 인한 선행사업자 의존도가 증대될 수 있는 이유는, 프레임워크가 특정 기술에 의존하고 있을 경우, 해당 기술을 사용하는 선행사업자가 필요하게 되기 때문입니다. 이는 다른 사업자들과의 경쟁력을 저하시키고, 비용 증대 등의 문제를 야기할 수 있습니다. 따라서, 이는 소프트웨어 개발 프레임워크의 적용 효과로 볼 수 없습니다.",
  "choices" : "1.공통 컴포넌트 재사용으로 중복 예산 절감/2.기술종속으로 인한 선행사업자 의존도 증대/3.표준화된 연계모듈 활용으로 상호 운용성 향상/4.개발표준에 의한 모듈화로 유지보수 용이/"
}, {
  "question" : "SoftTech사에서 개발된 것으로 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구는?",
  "answer" : "4.SADT",
  "commentary" : "SADT는 구조적 분석 기법 중 하나로, 블록 다이어그램을 사용하여 시스템의 구조와 기능을 분석하는 방법이다. 따라서 구조적 요구 분석을 위해 블록 다이어그램을 채택한 자동화 도구는 SADT이다.",
  "choices" : "1.SREM/2.PSL/PSA/3.HIPO/4.SADT/"
}, {
  "question" : "익스트림 프로그래밍 (eXtreme Programming)의 5가지 가치에 속하지 않는 것은?",
  "answer" : "4.고객 배제",
  "commentary" : "고객 배제는 XP의 가치 중 하나가 아니며, XP는 고객과의 긴밀한 협력을 강조합니다. 고객의 요구사항을 이해하고 그에 맞게 소프트웨어를 개발하는 것이 XP의 핵심 가치 중 하나입니다. 따라서 고객 배제는 XP의 가치와 상반됩니다.",
  "choices" : "1.의사소통/2.단순성/3.피드백/4.고객 배제/"
}, {
  "question" : "다음은 정보의 접근통제 정책에 대한 설명이다. (ㄱ)에 들어갈 내용으로 옳은 것은?",
  "answer" : "2.MAC",
  "commentary" : "정보의 접근통제 정책 중 MAC은 Mandatory Access Control의 약자로, 각각의 사용자나 프로세스에 대해 미리 정해진 보안 정책에 따라 접근 권한을 부여하는 방식이다. 따라서, 사용자나 프로세스의 권한에 따라 접근을 허용하거나 거부하는 것이 아니라, 미리 정해진 보안 정책에 따라 접근 권한을 부여하므로 보안성이 높다. 따라서, 이 중에서 \"MAC\"이 정답이다.",
  "choices" : "1.NAC/2.MAC/3.SDAC/4.AAC/"
}, {
  "question" : "소프트웨어 개발 모델 중 나선형 모델의 4가지 주요 활동이 순서대로 나열된 것은?",
  "answer" : "2.Ⓐ-Ⓓ-Ⓒ-Ⓑ순으로 반복",
  "commentary" : "나선형 모델은 반복적인 개발 프로세스를 가지고 있으며, 각 반복마다 요구사항 분석, 설계, 구현, 테스트의 4가지 주요 활동을 순서대로 수행합니다. 이때, 각 반복마다 발생하는 위험을 최소화하기 위해 초기에 위험 분석을 수행하고, 이를 바탕으로 계획을 수립합니다. 따라서 \"Ⓐ-Ⓓ-Ⓒ-Ⓑ순으로 반복\"인 이유는, 초기에 위험 분석을 수행하고 계획을 수립한 후, 요구사항 분석, 설계, 구현, 테스트를 순서대로 수행하며, 이후에 다시 위험 분석을 수행하여 반복을 진행하기 때문입니다.",
  "choices" : "1.Ⓐ-Ⓑ-Ⓓ-Ⓒ순으로 반복/2.Ⓐ-Ⓓ-Ⓒ-Ⓑ순으로 반복/3.Ⓐ-Ⓑ-Ⓒ-Ⓓ순으로 반복/4.Ⓐ-Ⓒ-Ⓑ-Ⓓ순으로 반복/"
}, {
  "question" : "소프트웨어 비용 추정모형(estimation models)이 아닌 것은?",
  "answer" : "4.PERT",
  "commentary" : "PERT는 프로젝트 일정 관리 모형으로, 소프트웨어 비용 추정 모형이 아니다. PERT는 프로젝트 일정을 추정하고 관리하기 위한 방법론으로, 프로젝트의 작업들을 분해하고 각 작업의 소요 시간과 선행 관계를 고려하여 전체 프로젝트 일정을 계산한다. 따라서 PERT는 소프트웨어 개발 비용 추정에 직접적으로 사용되지 않는다.",
  "choices" : "1.COCOMO/2.Putnam/3.Function-Point/4.PERT/"
}, {
  "question" : "공개키 암호화 방식에 대한 설명으로 틀린 것은?",
  "answer" : "1.공개키로 암호화된 메시지는 반드시 공개키로 복호화 해야 한다.",
  "commentary" : "정답은 \"공개키로 암호화된 메시지는 반드시 공개키로 복호화 해야 한다.\"가 아니다. 공개키 암호화 방식은 공개키와 개인키를 사용하여 암호화와 복호화를 수행하는 암호화 방식이다. 공개키로 암호화된 메시지는 개인키로 복호화할 수 있으며, 개인키로 암호화된 메시지는 공개키로 복호화할 수 있다. 따라서 \"공개키로 암호화된 메시지는 반드시 공개키로 복호화 해야 한다.\"는 틀린 설명이다. 공개키 암호화 방식은 비대칭 암호기법이라고도 불리며, 대표적인 기법으로는 RSA 기법이 있다. 이 방식은 키 분배가 용이하고, 관리해야 할 키 개수가 적다는 장점이 있다.",
  "choices" : "1.공개키로 암호화된 메시지는 반드시 공개키로 복호화 해야 한다./2.비대칭 암호기법이라고도 한다./3.대표적인 기법은 RSA 기법이 있다./4.키 분배가 용이하고, 관리해야 할 키 개수가 적다./"
}, {
  "question" : "다음이 설명하는 다중화 기술은?",
  "answer" : "1.Wavelength Division Multiplexing",
  "commentary" : "위 그림은 다중화 기술 중 하나인 \"Wavelength Division Multiplexing\"을 나타냅니다. 이 기술은 다수의 광신호를 하나의 광섬유에 전송하기 위해 사용됩니다. 각 광신호는 서로 다른 파장을 가지고 있으며, 이를 이용하여 하나의 광섬유에서 여러 개의 광신호를 전송할 수 있습니다. 따라서, \"Wavelength Division Multiplexing\"은 파장을 이용한 다중화 기술입니다.",
  "choices" : "1.Wavelength Division Multiplexing/2.Frequency Division Multiplexing/3.Code Division Multiplexing/4.Time Division Multiplexing/"
}, {
  "question" : "웹페이지에 악의적인 스크립트를 포함시켜 사용자 측에서 실행되게 유도함으로써, 정보유출 등의 공격을 유발할 수 있는 취약점은?",
  "answer" : "4.XSS",
  "commentary" : "XSS는 Cross-Site Scripting의 약자로, 웹페이지에 악의적인 스크립트를 삽입하여 사용자 측에서 실행되게 유도함으로써 공격을 유발하는 취약점입니다. 이를 통해 공격자는 사용자의 쿠키 정보 등을 탈취하거나, 사용자의 브라우저를 제어하여 악성코드를 다운로드하거나, 사용자를 다른 사이트로 리디렉션시키는 등의 공격을 수행할 수 있습니다. 따라서 XSS는 정보유출 등의 공격을 유발할 수 있는 취약점으로 분류됩니다.",
  "choices" : "1.Ransomware/2.Pharming/3.Phishing/4.XSS/"
}, {
  "question" : "CBD(Component Based Development) 에 대한 설명으로 틀린 것은?",
  "answer" : "4.1960년대까지 가장 많이 적용되었던 소프트웨어 개발 방법",
  "commentary" : "CBD(Component Based Development)는 소프트웨어 개발 방법론 중 하나로, 소프트웨어를 구성하는 컴포넌트들을 개별적으로 개발하고 이를 조합하여 전체 소프트웨어를 완성하는 방법입니다. 이 방법은 개발 기간을 단축하고 생산성을 향상시키며, 새로운 기능 추가가 쉬운 확장성과 소프트웨어 재사용이 가능하다는 장점이 있습니다. 하지만 CBD는 1960년대까지 가장 많이 적용되었던 소프트웨어 개발 방법이 아니라, 최근에 많이 사용되는 방법 중 하나입니다.",
  "choices" : "1.개발 기간 단축으로 인한 생산성 향상/2.새로운 기능 추가가 쉬운 확장성/3.소프트웨어 재사용이 가능/4.1960년대까지 가장 많이 적용되었던 소프트웨어 개발 방법/"
}, {
  "question" : "소프트웨어 정의 데이터센터(SDDC : Software Defined Data Center)에 대한 설명으로 틀린 것은?",
  "answer" : "4.특정 하드웨어 에 종속되어 특화된 업무를 서비스하기에 적합하다.",
  "commentary" : "\"특정 하드웨어에 종속되어 특화된 업무를 서비스하기에 적합하다\"는 설명이 틀린 것입니다. SDDC는 모든 자원을 가상화하여 서비스하기 때문에 특정 하드웨어에 종속되지 않고 유연하게 운영이 가능합니다. 따라서 다양한 업무에 적합하다는 특징이 있습니다.",
  "choices" : "1.컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의한다./2.인력 개입 없이 소프트웨어 조작만으로 자동 제어 관리한다./3.데이터센터 내 모든 자원을 가상화하여 서비스한다./4.특정 하드웨어 에 종속되어 특화된 업무를 서비스하기에 적합하다./"
}, {
  "question" : "컴퓨터 운영체제의 커널에 보안 기능을 추가한 것으로 운영체제의 보안상 결함으로 인하여 발생 가능한 각종 해킹으로부터 시스템을 보호하기 위하여 사용되는 것은?",
  "answer" : "4.Secure OS",
  "commentary" : "Secure OS는 컴퓨터 운영체제의 커널에 보안 기능을 추가하여 시스템을 보호하는 운영체제이다. 따라서 보기 중에서 Secure OS가 운영체제의 보안상 결함으로 인한 해킹으로부터 시스템을 보호하기 위한 것이다. GPIB는 General Purpose Interface Bus의 약자로 측정 및 제어 장비와의 통신을 위한 인터페이스이며, CentOS는 리눅스 계열의 운영체제이다. XSS는 웹 애플리케이션에서 발생하는 취약점 중 하나로, 크로스 사이트 스크립팅(Cross-Site Scripting)의 약자이다.",
  "choices" : "1.GPIB/2.CentOS/3.XSS/4.Secure OS/"
}, {
  "question" : "NS(Nassi-Schneiderman) chart에 대한 설명으로 거리가 먼 것은?",
  "answer" : "3.주로 화살표를 사용하여 논리적인 제어구조로 흐름을 표현한다.",
  "commentary" : "NS(Nassi-Schneiderman) chart는 논리적인 제어구조를 표현하기 위해 주로 화살표를 사용하는 도형식 표현 방법이다. 이를 통해 연속, 선택 및 다중 선택, 반복 등의 제어논리 구조를 명확하게 표현할 수 있다. 또한 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합하다.",
  "choices" : "1.논리의 기술에 중점을 둔 도형식 표현 방법이다./2.연속, 선택 및 다중 선택, 반복 등의 제어논리 구조로 표현한다./3.주로 화살표를 사용하여 논리적인 제어구조로 흐름을 표현한다./4.조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합하다./"
}, {
  "question" : "다음 내용에 적합한 용어는?",
  "answer" : "1.MapReduce",
  "commentary" : "위 그림은 대용량 데이터를 처리하는 분산처리 시스템인 Hadoop의 아키텍처를 나타내고 있습니다. 이 시스템에서 데이터 처리를 위해 사용되는 프로그래밍 모델이 \"MapReduce\" 입니다. MapReduce는 데이터를 분산 처리하여 병렬 처리를 가능하게 하며, 데이터 처리 과정을 Map과 Reduce 단계로 나누어 처리합니다. 따라서, 이 그림에서는 Hadoop 시스템에서 데이터 처리를 위해 사용되는 MapReduce가 적합한 용어입니다. SQL은 데이터베이스 관리 시스템에서 사용되는 쿼리 언어이며, Hijacking은 해킹 기법 중 하나이며, Logs는 로그 파일을 의미합니다.",
  "choices" : "1.MapReduce/2.SQL/3.Hijacking/4.Logs/"
}, {
  "question" : "소프트웨어 프로세스에 대한 개선 및 능력 측정 기준에 대한 국제 표준은?",
  "answer" : "4.SPICE",
  "commentary" : "SPICE는 소프트웨어 프로세스 개선 및 능력 측정에 대한 국제 표준으로, 소프트웨어 개발 프로세스를 평가하고 개선하기 위한 프레임워크를 제공합니다. 이를 통해 조직은 소프트웨어 개발 프로세스를 효과적으로 관리하고 개선할 수 있습니다. 따라서 SPICE가 정답입니다.",
  "choices" : "1.ISO 14001/2.IEEE 802.5/3.IEEE 488/4.SPICE/"
}, {
  "question" : "요구사항 분석 시에 필요한 기술로 가장 거리가 먼 것은?",
  "answer" : "3.설계 및 코딩 기술",
  "commentary" : "요구사항 분석은 소프트웨어 개발의 초기 단계로, 사용자의 요구사항을 파악하고 이를 바탕으로 시스템을 설계하는 과정이다. 이 과정에서 청취와 인터뷰 질문 기술, 분석과 중재기술, 관찰 및 모델 작성 기술 등이 필요하다. 그러나 설계 및 코딩 기술은 요구사항 분석 이전에 이루어지는 단계인 시스템 설계와 구현 단계에서 필요한 기술이므로, 요구사항 분석 시에는 가장 거리가 먼 기술이다.",
  "choices" : "1.청취와 인터뷰 질문 기술/2.분석과 중재기술/3.설계 및 코딩 기술/4.관찰 및 모델 작성 기술/"
}, {
  "question" : "다음 내용이 설명하는 디자인 패턴은?",
  "answer" : "3.Factory Method 패턴",
  "commentary" : "위 그림은 Factory Method 패턴을 나타낸다. Factory Method 패턴은 객체를 생성하는 인터페이스를 정의하고, 이를 서브클래스에서 구현하여 객체를 생성하는 패턴이다. 위 그림에서는 Creator 클래스가 이 역할을 하고, ConcreteCreator1과 ConcreteCreator2가 Creator 클래스를 상속받아 객체를 생성한다. 따라서 정답은 \"Factory Method 패턴\"이다.",
  "choices" : "1.Visitor패턴/2.Observer패턴/3.Factory Method 패턴/4.Bridge 패턴/"
}, {
  "question" : "럼바우 객체 지향 분석과 거리가 먼 것은?",
  "answer" : "4.정적 모델링",
  "commentary" : "럼바우 객체 지향 분석에서는 객체 모델링을 중요하게 다루며, 객체들의 속성과 행위를 분석하여 객체 간의 관계를 파악하는 것이 핵심입니다. 반면에 정적 모델링은 시스템의 구조와 상태를 나타내는 모델링 기법으로, 객체 지향 분석과는 거리가 있습니다. 정적 모델링은 시스템의 구성 요소들을 정적으로 분석하여 시스템의 구조를 파악하는 것이 목적입니다. 따라서 정적 모델링이 럼바우 객체 지향 분석과 거리가 먼 것입니다.",
  "choices" : "1.기능 모델링/2.동적 모델링/3.객체 모델링/4.정적 모델링/"
}, {
  "question" : "애자일 기법에 대한 설명으로 맞지 않은 것은?",
  "answer" : "2.계획에 중점을 두어 변경 대응이 난해하다.",
  "commentary" : "애자일 기법은 계획보다는 변화에 대응하는 능력을 중요시하므로 \"계획에 중점을 두어 변경 대응이 난해하다.\"는 맞지 않는 설명입니다. 애자일 기법은 계획을 유연하게 조정하며, 고객과의 소통과 피드백을 통해 지속적으로 개선해 나가는 방식을 취합니다.",
  "choices" : "1.절차와 도구보다 개인과 소통을 중요하게 생각한다./2.계획에 중점을 두어 변경 대응이 난해하다./3.소프트웨어가 잘 실행되는데 가치를 둔다./4.고객과의 피드백을 중요하게 생각한다./"
}, {
  "question" : "미들웨어 솔루션의 유형에 포함되지 않는 것은?",
  "answer" : "2.Web Server",
  "commentary" : "Web Server는 미들웨어 솔루션의 유형에 포함되지 않는다. Web Server는 클라이언트의 HTTP 요청을 받아 정적인 웹 페이지를 제공하는 서버 소프트웨어이며, 동적인 컨텐츠를 처리하기 위해서는 WAS와 같은 미들웨어 솔루션과 함께 사용되어야 한다. 따라서 Web Server는 WAS나 ORB와 같은 미들웨어 솔루션의 하위 개념으로 볼 수 있다.",
  "choices" : "1.WAS/2.Web Server/3.RPC/4.ORB/"
}, {
  "question" : "UML에서 시퀀스 다이어그램의 구성 항목에 해당하지 않는 것은?",
  "answer" : "3.확장",
  "commentary" : "시퀀스 다이어그램의 구성 항목은 생명선, 실행, 메시지이다. 확장은 유스케이스 다이어그램에서 사용되는 용어이며, 시나리오의 흐름을 더 자세하게 설명하기 위해 사용된다. 따라서 확장은 시퀀스 다이어그램의 구성 항목에 해당하지 않는다.",
  "choices" : "1.생명선/2.실행/3.확장/4.메시지/"
}, {
  "question" : "객체지향에서 정보 은닉과 가장 밀접한 관계가 있는 것은?",
  "answer" : "1.Encapsulation",
  "commentary" : "정보 은닉은 객체지향 프로그래밍에서 데이터와 그 데이터를 다루는 메서드를 하나로 묶어 캡슐화(encapsulation)하는 것을 의미합니다. 이를 통해 객체의 내부 구현을 외부로부터 숨기고, 객체 간의 상호작용을 보다 안전하고 효율적으로 할 수 있습니다. 따라서 정보 은닉과 가장 밀접한 관계가 있는 것은 \"Encapsulation\"입니다.",
  "choices" : "1.Encapsulation/2.Class/3.Method/4.Instance/"
}, {
  "question" : "디자인 패턴 중에서 행위적 패턴에 속하지 않는 것은?",
  "answer" : "3.프로토타입 (Prototype) 패턴",
  "commentary" : "프로토타입 (Prototype) 패턴은 생성 패턴에 속하며, 객체를 생성하는 방법 중 하나로써, 기존 객체를 복제하여 새로운 객체를 생성하는 방법을 제공합니다. 따라서, 행위적 패턴이 아닌 생성 패턴에 속합니다. 반면에, 커맨드 패턴, 옵저버 패턴, 상태 패턴은 모두 행위적 패턴에 속합니다.",
  "choices" : "1.커맨드 (Command) 패턴/2.옵저버 (Observer) 패턴/3.프로토타입 (Prototype) 패턴/4.상태 (State) 패턴/"
}, {
  "question" : "UI 설계 원칙 중 누구나 쉽게 이해하고 사용할 수 있어야 한다는 원칙은?",
  "answer" : "3.직관성",
  "commentary" : "\"직관성\"은 사용자가 쉽게 이해하고 사용할 수 있는 인터페이스를 제공하는 것을 의미합니다. 사용자가 복잡한 기능을 이해하지 않고도 쉽게 사용할 수 있도록 UI를 설계하는 것이 중요합니다. 이는 사용자의 만족도와 생산성을 높이는 데에 큰 역할을 합니다.",
  "choices" : "1.희소성/2.유연성/3.직관성/4.멀티운용성/"
}, {
  "question" : "코드의 기본 기능으로 거리가 먼 것은?",
  "answer" : "1.복잡성",
  "commentary" : "복잡성은 코드의 기본 기능 중에서 가장 거리가 먼 것입니다. 이는 코드가 복잡하면 유지보수가 어렵고 오류가 발생할 가능성이 높아지기 때문입니다. 따라서 코드를 작성할 때는 가독성과 유지보수성을 고려하여 가능한 간결하고 명확한 코드를 작성해야 합니다.",
  "choices" : "1.복잡성/2.표준화/3.분류/4.식별/"
}, {
  "question" : "다음 ( ) 안에 들어갈 내용으로 옳은 것은?",
  "answer" : "1.협약(Contract)",
  "commentary" : "이미지에서 보이는 것은 블록체인 기술에서 사용되는 스마트 컨트랙트(Smart Contract)의 코드이다. 스마트 컨트랙트는 블록체인 상에서 실행되는 계약으로, 이를 통해 양 당사자 간에 협약이 이루어진다. 따라서 정답은 \"협약(Contract)\"이다.",
  "choices" : "1.협약(Contract)/2.프로토콜(Protocol)/3.패턴(Pattern)/4.관계(Relation)/"
}, {
  "question" : "UML에서 활용되는 다이어그램 중, 시스템의 동작을 표현하는 행위(Behavioral) 다이어그램에 해당하지 않는 것은?",
  "answer" : "4.배치 다이어그램(Deployment Diagram)",
  "commentary" : null,
  "choices" : "1.유스케이스 다이어그램(Use Case Diagram)/2.시퀀스 다이어그램(Sequence Diagram)/3.활동 다이어그램(Activity Diagram)/4.배치 다이어그램(Deployment Diagram)/"
}, {
  "question" : "객체 지향 소프트웨어 공학에서 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것은?",
  "answer" : "2.클래스",
  "commentary" : "클래스는 객체 지향 소프트웨어 공학에서 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것입니다. 즉, 클래스는 객체들의 공통된 속성과 동작을 정의하고, 이를 기반으로 객체를 생성할 수 있도록 합니다. 따라서 클래스가 정답입니다.",
  "choices" : "1.트랜지션/2.클래스/3.시퀀스/4.서브루틴/"
}, {
  "question" : "아래의 UML 모델에서 '차' 클래스와 각 클래스의 관계로 옳은 것은?",
  "answer" : "3.일반화 관계",
  "commentary" : "'차' 클래스는 '승용차', '트럭', '버스' 클래스들의 공통적인 특성을 가지고 있으므로, 이들 클래스들과 '일반화 관계'를 가진다. 이 관계는 상위 클래스인 '차'가 하위 클래스인 '승용차', '트럭', '버스'들의 공통적인 특성을 상속받는 것을 의미한다. 따라서 정답은 \"일반화 관계\"이다.",
  "choices" : "1.추상화 관계/2.의존 관계/3.일반화 관계/4.그룹 관계/"
}, {
  "question" : "객체지향 소프트웨어 설계시 디자인 패턴을 구성하는 요소로서 가장 거리가 먼 것은?",
  "answer" : "1.개발자이름",
  "commentary" : "정답: \"개발자이름\" 문제 및 배경: 객체지향 소프트웨어 설계시 디자인 패턴은 일종의 설계 템플릿으로, 공통적인 문제를 해결하기 위한 해결책을 제공한다. 디자인 패턴은 객체지향 소프트웨어 개발에서 중요한 역할을 하며, 개발자들은 이를 잘 이해하고 활용해야 한다. 사례: 디자인 패턴은 객체지향 소프트웨어 개발에서 매우 중요한 역할을 한다. 예를 들어, MVC 패턴은 모델, 뷰, 컨트롤러로 구성되어 있으며, 이를 이용하여 소프트웨어를 구조화하고 유지보수성을 높일 수 있다. 샘플코드: 디자인 패턴은 일종의 설계 템플릿이므로, 구체적인 샘플코드는 패턴마다 다르다. 예를 들어, 싱글톤 패턴은 객체를 하나만 생성하도록 보장하는 패턴으로, 다음과 같은 코드로 구현할 수 있다. ``` public class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } ``` 하지만 이 문제에서는 디자인 패턴을 구성하는 요소로서 가장 거리가 먼 것을 물어보고 있으므로, 샘플코드는 정답과 직접적인 연관이 없다. 따라서 정답은 \"개발자이름\"이다.",
  "choices" : "1.개발자이름/2.문제 및 배경/3.사례/4.샘플코드/"
}, {
  "question" : "자료 사전에서 자료의 반복을 의미하는 것은?",
  "answer" : "3.{ }",
  "commentary" : "\"{ }\"는 중괄호로, 자료의 반복을 의미하는 반면, 다른 선택지들은 그렇지 않기 때문에 정답입니다. 중괄호 안에 있는 자료는 반복적으로 나타날 수 있습니다.",
  "choices" : "1.=/2.( )/3.{ }/4.[ ]/"
}, {
  "question" : "객체지향 설계 원칙 중, 서브타입(상속받은 하위 클래스)은 어디에서나 자신의 기반타입(상위클래스)으로 교체할 수 있어야 함을 의미하는 원칙은?",
  "answer" : "3.LSP(Liskov Substitution Principle)",
  "commentary" : "LSP는 상위 클래스와 하위 클래스 간의 교체 가능성을 보장하여 다형성을 지원하고, 이를 통해 유연하고 확장 가능한 코드를 작성할 수 있도록 돕는 객체지향 설계 원칙입니다. 즉, 하위 클래스는 상위 클래스의 모든 기능을 사용할 수 있어야 하며, 상위 클래스에서 정의한 규약을 준수해야 합니다. 이를 통해 코드의 일관성과 안정성을 유지할 수 있습니다. ISP는 인터페이스를 작은 단위로 분리하여 의존성을 낮추는 원칙, DIP는 추상화를 통해 의존성을 역전시키는 원칙, SRP는 클래스나 모듈은 하나의 책임만 가져야 한다는 원칙입니다.",
  "choices" : "1.ISP(Interface Segregation Principle)/2.DIP(Dependency Inversion Principle)/3.LSP(Liskov Substitution Principle)/4.SRP(Single Responsibility Principle)/"
}, {
  "question" : "자료흐름도(Data Flow Diagram)의 구성요소로 옳은 것은?",
  "answer" : "2.process, data flow, data store, terminator",
  "commentary" : "자료흐름도의 구성요소는 process(처리), data flow(자료흐름), data store(자료저장소), terminator(종료점)로 이루어져 있습니다. - Process: 시스템 내에서 수행되는 작업을 나타냅니다. 입력된 자료를 처리하여 출력 자료를 생성하는 작업을 수행합니다. - Data flow: 시스템 내에서 자료가 이동하는 경로를 나타냅니다. 입력 자료가 처리되어 출력 자료로 변환되는 과정에서 자료가 이동하는 경로를 표현합니다. - Data store: 시스템 내에서 자료가 저장되는 장소를 나타냅니다. 처리된 자료를 저장하거나, 다음 처리를 위해 입력 자료를 저장하는 등의 역할을 수행합니다. - Terminator: 시스템과 외부 환경 간의 경계를 나타냅니다. 시스템과 상호작용하는 외부 요소를 표현합니다. 따라서, 옳은 구성요소는 \"process, data flow, data store, terminator\" 입니다.",
  "choices" : "1.process, data flow, data store, comment/2.process, data flow, data store, terminator/3.data flow, data store, terminator, data dictionary/4.process, data store, terminator, mini-spec/"
}, {
  "question" : "CASE(Computer-Aided Software Engineering)도구에 대한 설명으로 거리가 먼 것은?",
  "answer" : "4.2000년대 이후 소개되었으며, 객체지향 시스템에 한해 효과적으로 활용된다.",
  "commentary" : "\"2000년대 이후 소개되었으며, 객체지향 시스템에 한해 효과적으로 활용된다.\"는 다른 보기들과 달리 CASE 도구의 출현 시기와 활용 분야에 대한 구체적인 정보를 제공하고 있다. 다른 보기들은 CASE 도구의 기능과 장점에 대한 설명이지만, 이 보기는 CASE 도구의 역사와 특정 분야에서의 활용 가능성에 대한 정보를 제공하고 있다.",
  "choices" : "1.소프트웨어 개발 과정의 일부 또는 전체를 자동화하기 위한 도구이다./2.표준화된 개발 환경 구축 및 문서 자동화 기능을 제공한다./3.작업 과정 및 데이터 공유를 통해 작업자간 커뮤니케이션을 증대한다./4.2000년대 이후 소개되었으며, 객체지향 시스템에 한해 효과적으로 활용된다./"
}, {
  "question" : "인터페이스 요구 사항 검토 방법에 대한 설명이 옳은 것은?",
  "answer" : "2.동료검토 : 요구 사항 명세서 작성자가 요구 사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견",
  "commentary" : "인터페이스 요구 사항 검토 방법 중 동료검토는 요구 사항 명세서 작성자가 요구 사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견하는 방법이다. 즉, 작성자와 다른 동료들이 함께 모여 요구 사항 명세서를 검토하고, 작성자가 설명하면서 이해관계자들이 의견을 내고 결함을 발견하는 방법이다.",
  "choices" : "1.리팩토링 : 작성자 이외의 전문 검토 그룹이 요구사항 명세서를 상세히 조사하여 결함, 표준 위배, 문제점 등을 파악/2.동료검토 : 요구 사항 명세서 작성자가 요구 사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견/3.인스펙션 : 자동화된 요구 사항 관리 도구를 이용하여 요구 사항 추적성과 일관성을 검토/4.CASE 도구 : 검토 자료를 회의 전에 배포해서 사전 검토한 후 짧은 시간 동안 검토 회의를 진행하면서 결함을 발견/"
}, {
  "question" : "인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 솔루션과 거리가 먼 것은?",
  "answer" : "3.SMTP",
  "commentary" : "SMTP는 이메일 전송 프로토콜로, 인터페이스 보안을 위한 네트워크 영역에 적용될 수 있는 솔루션과는 거리가 먼 것입니다. IPSec는 가상 사설망(VPN)을 구성하거나 데이터 암호화를 위해 사용되며, SSL과 S-HTTP는 웹 서버와 클라이언트 간의 암호화 통신을 위해 사용됩니다. 하지만 SMTP는 이메일 전송에 사용되는 프로토콜로, 이메일 보안을 위한 다른 솔루션들이 존재합니다.",
  "choices" : "1.IPSec/2.SSL/3.SMTP/4.S-HTTP/"
}, {
  "question" : "소프트웨어 공학의 기본 원칙이라고 볼 수 없는 것은?",
  "answer" : "4.최대한 많은 인력 투입",
  "commentary" : "\"최대한 많은 인력 투입\"은 소프트웨어 공학의 기본 원칙이 아니라 비효율적인 방법이기 때문에 선택지에서 제외되었습니다. 인력 투입이 많다고 해서 반드시 품질이 높아지는 것은 아니며, 오히려 프로젝트 일정과 예산을 초과할 수 있습니다. 따라서 효율적인 인력 배분과 관리가 필요합니다.",
  "choices" : "1.품질 높은 소프트웨어 상품 개발/2.지속적인 검증 시행/3.결과에 대한 명확한 기록 유지/4.최대한 많은 인력 투입/"
}, {
  "question" : "패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준은?",
  "answer" : "3.ISO/IEC 12119",
  "commentary" : "ISO/IEC 12119은 소프트웨어 제품의 품질 요구사항과 테스트를 위한 국제 표준이다. 이 표준은 소프트웨어 제품의 기능, 신뢰성, 사용성, 효율성, 유지보수성 등 다양한 측면에서의 품질 요구사항을 제시하며, 이를 검증하기 위한 테스트 방법과 절차를 제공한다. 따라서 패키지 소프트웨어의 품질을 평가하고 개선하기 위해서는 ISO/IEC 12119 표준을 참고하여 테스트를 수행하는 것이 중요하다.",
  "choices" : "1.ISO/IEC 2196/2.IEEE 19554/3.ISO/IEC 12119/4.ISO/IEC 14959/"
}, {
  "question" : "다음 중 클린 코드 작성원칙으로 거리가 먼 것은?",
  "answer" : "2.중복이 최대화된 코드 작성",
  "commentary" : "정답은 \"중복이 최대화된 코드 작성\"입니다. 중복이 최대화된 코드 작성은 코드의 재사용성을 떨어뜨리고 유지보수를 어렵게 만들기 때문에 클린 코드 작성 원칙에 어긋납니다. 코드에서 중복을 최소화하고, 함수나 클래스 등의 모듈화를 통해 코드의 재사용성을 높이는 것이 좋습니다. 이를 통해 코드의 가독성과 유지보수성을 높일 수 있습니다.",
  "choices" : "1.누구든지 쉽게 이해하는 코드 작성/2.중복이 최대화된 코드 작성/3.다른 모듈에 미치는 영향 최소화/4.단순, 명료한 코드 작성/"
}, {
  "question" : "블랙박스 테스트의 유형으로 틀린 것은?",
  "answer" : "4.조건, 루프 검사",
  "commentary" : "조건, 루프 검사는 화이트박스 테스트의 유형이며, 블랙박스 테스트의 유형은 \"경계값 분석\", \"오류 예측\", \"동등 분할 기법\"입니다.",
  "choices" : "1.경계값 분석/2.오류 예측/3.동등 분할 기법/4.조건, 루프 검사/"
}, {
  "question" : "제어흐름 그래프가 다음과 같을 때 McCabe의 cyclomatic 수는 얼마인가?",
  "answer" : "2.4",
  "commentary" : "제어흐름 그래프에서 McCabe의 cyclomatic 수는 분기점의 개수에 1을 더한 값과 같다. 이 그래프에서 분기점은 총 3개이므로, cyclomatic 수는 3+1=4가 된다.",
  "choices" : "1.3/2.4/3.5/4.6/"
}, {
  "question" : "다음 자료에 대하여 선택(Selection) 정렬을 이용하여 오름차순으로 정렬하고자 한다. 3회전 후의 결과로 옳은 것은?",
  "answer" : "4.14, 17, 35, 40, 37",
  "commentary" : "선택 정렬은 가장 작은 값을 찾아서 맨 앞으로 보내는 과정을 반복하여 정렬하는 알고리즘이다. 1회전에서는 14가 가장 작은 값이므로 맨 앞으로 보내고, 2회전에서는 17이 두 번째로 작은 값이므로 두 번째 자리로 보내고, 3회전에서는 35과 37 중에서 작은 값인 35를 찾아서 세 번째 자리로 보내고, 4회전에서는 40이 가장 큰 값이므로 마지막 자리에 위치시킨다. 따라서 \"14, 17, 35, 40, 37\"가 옳은 정렬 결과이다.",
  "choices" : "1.14, 17, 37, 40, 35/2.14, 37, 17, 40, 35/3.17, 14, 37, 35, 40/4.14, 17, 35, 40, 37/"
}, {
  "question" : "형상 관리 도구의 주요 기능으로 거리가 먼 것은?",
  "answer" : "1.정규화(Normalization)",
  "commentary" : "정규화는 형상 관리 도구의 주요 기능이 아니라 데이터베이스 설계에서 사용되는 용어이다. 따라서 정규화가 거리가 먼 것이다. 형상 관리 도구의 주요 기능으로는 체크인, 체크아웃, 커밋 등이 있다.",
  "choices" : "1.정규화(Normalization)/2.체크인(Check-in)/3.체크아웃(Check-out)/4.커밋(commit)/"
}, {
  "question" : "다음 트리를 Preorder 운행법으로 운행할 경우 가장 먼저 탐색되는 것은?",
  "answer" : "1.A",
  "commentary" : "Preorder 운행법은 루트 노드를 가장 먼저 탐색하는 방법이다. 따라서 이 트리에서 가장 먼저 탐색되는 것은 루트 노드인 \"A\"이다. 이어서 \"A\"의 왼쪽 서브트리를 탐색하면 \"B\"가, \"B\"의 왼쪽 서브트리를 탐색하면 \"D\"가, \"D\"의 왼쪽 서브트리를 탐색하면 \"G\"가 탐색된다. 따라서 Preorder 운행법으로 운행할 경우 가장 먼저 탐색되는 것은 \"A\"이고, 이어서 \"B\", \"D\", \"G\"가 탐색된다.",
  "choices" : "1.A/2.B/3.D/4.G/"
}, {
  "question" : "소프트웨어 품질 목표 중 주어진 시간동안 주어진 기능을 오류없이 수행하는 정도를 나타내는 것은?",
  "answer" : "3.신뢰성",
  "commentary" : "주어진 시간동안 주어진 기능을 오류없이 수행하는 것은 소프트웨어의 신뢰성을 나타냅니다. 이는 사용자가 소프트웨어를 안정적으로 사용할 수 있는지 여부를 결정하는 중요한 요소 중 하나입니다. 따라서 정답은 \"신뢰성\"입니다.",
  "choices" : "1.직관성/2.사용 용이성/3.신뢰성/4.이식성/"
}, {
  "question" : "알고리즘 설계 기법으로 거리가 먼 것은?",
  "answer" : "3.Static Block",
  "commentary" : "\"Static Block\"은 알고리즘 설계 기법이 아니라, 클래스나 인터페이스가 로딩될 때 실행되는 정적 블록을 의미합니다. 따라서 \"Static Block\"은 알고리즘 설계 기법 중에서 거리가 가장 먼 것입니다.",
  "choices" : "1.Divide and Conquer/2.Greedy/3.Static Block/4.Backtracking/"
}, {
  "question" : "제품 소프트웨어의 형상 관리 역할로 틀린 것은?",
  "answer" : "3.프로젝트 개발비용을 효율적으로 관리",
  "commentary" : "\"프로젝트 개발비용을 효율적으로 관리\"는 제품 소프트웨어의 형상 관리 역할이 아닙니다. 형상 관리는 주로 이전 리버전이나 버전에 대한 정보에 접근 가능하여 배포본 관리에 유용하고, 불필요한 사용자의 소스 수정을 제한하며, 동일한 프로젝트에 대해 여러 개발자가 동시에 개발할 수 있도록 지원하는 역할을 합니다.",
  "choices" : "1.형상 관리를 통해 이전 리버전이나 버전에 대한 정보에 접근 가능하여 배포본 관리에 유용/2.불필요한 사용자의 소스 수정 제한/3.프로젝트 개발비용을 효율적으로 관리/4.동일한 프로젝트에 대해 여러 개발자 동시 개발 가능/"
}, {
  "question" : "제품 소프트웨어 패키징 도구 활용 시 고려사항이 아닌 것은?",
  "answer" : "4.내부 콘텐츠에 대한 보안은 고려하지 않는다.",
  "commentary" : "제품 소프트웨어 패키징 도구는 제품을 패키징하고 배포하기 위한 도구로, 사용자 편의성, 이기종 연동 등을 고려하여 제작된다. 따라서 내부 콘텐츠에 대한 보안은 패키징 도구의 고려사항이 아니다. 이는 보안 전문가들이 따로 보안 검토를 거쳐야 하는 문제이다.",
  "choices" : "1.제품 소프트웨어의 종류에 적합한 암호화 알고리즘을 고려한다./2.추가로 다양한 이기종 연동을 고려한다./3.사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다./4.내부 콘텐츠에 대한 보안은 고려하지 않는다./"
}, {
  "question" : "디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?",
  "answer" : "3.콘텐츠 오류 감지 및 복구",
  "commentary" : "디지털 저작권 관리(DRM) 기술은 콘텐츠의 불법 복제 및 배포를 방지하기 위한 기술로, 콘텐츠 암호화 및 키 관리, 콘텐츠 식별체계 표현, 라이센스 발급 및 관리 등이 포함됩니다. 하지만 콘텐츠 오류 감지 및 복구는 DRM과는 거리가 먼 기술입니다. 이는 콘텐츠의 오류를 감지하고 복구하는 기술로, 콘텐츠의 무결성을 보장하기 위한 것입니다. 따라서 콘텐츠 오류 감지 및 복구는 DRM과는 별개의 기술로 분류됩니다.",
  "choices" : "1.콘텐츠 암호화 및 키 관리/2.콘텐츠 식별체계 표현/3.콘텐츠 오류 감지 및 복구/4.라이센스 발급 및 관리/"
}, {
  "question" : "물리데이터 저장소의 파티션 설계에서 파티션 유형으로 옳지 않은 것은?",
  "answer" : "4.유닛분할(Unit Partitioning)",
  "commentary" : "유닛분할(Unit Partitioning)은 파티션을 일정한 크기의 블록으로 분할하는 것으로, 데이터의 특성에 따라 유연하게 조절할 수 없어서 파티션 설계에서 사용되지 않는 유형입니다. 범위분할(Range Partitioning), 해시분할(Hash Partitioning), 조합분할(Composite Partitioning)은 데이터의 특성에 따라 파티션을 유연하게 조절할 수 있어서 파티션 설계에서 사용됩니다.",
  "choices" : "1.범위분할(Range Partitioning)/2.해시분할(Hash Partitioning)/3.조합분할(Composite Partitioning)/4.유닛분할(Unit Partitioning)/"
}, {
  "question" : "다음이 설명하는 애플리케이션 통합 테스트 유형은?",
  "answer" : "1.하향식 통합 테스트",
  "commentary" : "위 그림에서는 모듈들이 하나의 중심 모듈에 통합되는 것을 보여주고 있으며, 이는 하향식 통합 테스트의 예시입니다. 하향식 통합 테스트는 상위 모듈에서 하위 모듈로 통합해가며 진행되는 테스트 방법으로, 각 모듈이 개별적으로 테스트된 후 하위 모듈과 통합되어 전체 시스템이 완성됩니다.",
  "choices" : "1.하향식 통합 테스트/2.상향식 통합 테스트/3.회귀 테스트/4.빅뱅 테스트/"
}, {
  "question" : "인터페이스 구현시 사용하는 기술 중 다음 내용이 설명하는 것은?",
  "answer" : "4.AJAX",
  "commentary" : "이미 로드된 웹 페이지를 다시 로드하지 않고도 서버와 데이터를 비동기적으로 주고받을 수 있는 기술이다. 즉, 사용자가 페이지를 요청할 때마다 전체 페이지를 다시 로드하지 않고 필요한 부분만 업데이트하여 빠르고 부드러운 사용자 경험을 제공할 수 있다.",
  "choices" : "1.Procedure/2.Trigger/3.Greedy/4.AJAX/"
}, {
  "question" : "소프트웨어 재공학이 소프트웨어의 재개발에 비해 갖는 장점으로 거리가 먼 것은?",
  "answer" : "4.개발시간의 증가",
  "commentary" : "소프트웨어 재공학은 기존 소프트웨어를 수정하거나 개선하는 것이므로 처음부터 새로운 소프트웨어를 개발하는 것보다는 비용이 적게 듭니다. 또한 기존 소프트웨어의 문제점을 파악하고 수정하는 과정에서 시스템 명세의 오류를 발견하고 이를 수정할 수 있습니다. 또한 기존 소프트웨어를 재사용하므로 위험부담도 감소합니다. 하지만 소프트웨어 재공학은 기존 소프트웨어를 수정하므로 개발시간이 증가할 수 있습니다.",
  "choices" : "1.위험부담 감소/2.비용 절감/3.시스템 명세의 오류억제/4.개발시간의 증가/"
}, {
  "question" : "알파, 베타 테스트와 가장 밀접한 연관이 있는 테스트 단계는?",
  "answer" : "2.인수 테스트",
  "commentary" : "알파, 베타 테스트는 개발자나 제품 관리자가 직접 수행하는 테스트이며, 이전에 이미 단위 테스트와 통합 테스트가 수행되어 완성된 제품을 대상으로 한다. 이때, 인수 테스트는 최종 사용자가 실제로 사용하는 환경에서 제품의 기능, 성능, 안정성 등을 평가하는 테스트이다. 따라서 알파, 베타 테스트와 가장 밀접한 연관이 있는 테스트 단계는 인수 테스트이다.",
  "choices" : "1.단위 테스트/2.인수 테스트/3.통합 테스트/4.시스템 테스트/"
}, {
  "question" : "다음 트리의 차수(degree)는?",
  "answer" : "2.3",
  "commentary" : "트리의 차수란 각 노드가 가지는 자식 노드의 수를 말합니다. 따라서, 각 노드의 차수를 살펴보면 1번 노드는 2개의 자식 노드를 가지고 있고, 2번 노드는 3개의 자식 노드를 가지고 있으므로, 가장 큰 차수는 3입니다. 따라서 정답은 \"3\"입니다.",
  "choices" : "1.2/2.3/3.4/4.5/"
}, {
  "question" : "릴레이션 R의 모든 결정자(determinant)가 후보키이면 그 릴레이션 R은 어떤 정규형에 속하는가?",
  "answer" : "3.보이스/코드 정규형",
  "commentary" : "만약 릴레이션 R의 모든 결정자가 후보키이면, 이는 함수적 종속성이 완전하게 유지되는 상태입니다. 이러한 상태에서는 어떤 속성도 다른 속성에 의존하지 않으므로, 보이스/코드 정규형에 속합니다. 다른 정규형들은 함수적 종속성이 일부만 유지되는 경우에 해당합니다.",
  "choices" : "1.제 1 정규형/2.제 2 정규형/3.보이스/코드 정규형/4.제 4 정규형/"
}, {
  "question" : "다음 관계형 데이터 모델에 대한 설명으로 옳은 것은?",
  "answer" : "4.relation 1개, attribute 3개, tuple 5개",
  "commentary" : "주어진 데이터 모델에서는 하나의 Relation만 존재하며, 이 Relation은 \"고객\"을 나타낸다. 이 Relation은 3개의 Attribute를 가지고 있으며, 이는 \"고객번호\", \"고객이름\", \"고객주소\"이다. 또한, 이 Relation은 5개의 Tuple을 가지고 있으며, 이는 각각의 Tuple이 하나의 고객 정보를 나타내기 때문이다. 따라서, 정답은 \"relation 1개, attribute 3개, tuple 5개\"이다.",
  "choices" : "1.relation 3개, attribute 3개, tuple 5개/2.relation 3개, attribute 5개, tuple 3개/3.relation 1개, attribute 5개, tuple 3개/4.relation 1개, attribute 3개, tuple 5개/"
}, {
  "question" : "Commit과 Rollback 명령어에 의해 보장 받는 트랜잭션의 특성은?",
  "answer" : "3.원자성",
  "commentary" : "Commit과 Rollback 명령어는 트랜잭션의 원자성을 보장합니다. 원자성은 트랜잭션이 하나의 논리적인 작업 단위로 처리되어야 함을 의미합니다. 즉, 트랜잭션 내의 모든 작업이 성공적으로 완료되면 Commit 명령어를 통해 모든 변경 사항이 영구적으로 저장되고, 하나라도 실패하면 Rollback 명령어를 통해 모든 변경 사항이 취소되어 이전 상태로 되돌아갑니다. 이러한 과정에서 트랜잭션의 일관성과 무결성이 보장되며, 데이터베이스의 신뢰성이 유지됩니다.",
  "choices" : "1.병행성/2.보안성/3.원자성/4.로그/"
}, {
  "question" : "관계 데이터베이스인 테이블 R1에 대한 아래 SQL 문의 실행결과로 옳은 것은?",
  "answer" : "2.",
  "commentary" : null,
  "choices" : "1./2./3./4./"
}, {
  "question" : "DCL(Data Control Language) 명령어가 아닌 것은?",
  "answer" : "4.SELECT",
  "commentary" : "SELECT는 DML(Data Manipulation Language) 명령어로 데이터를 조회하고 검색하는데 사용되며, DCL(Data Control Language) 명령어는 데이터베이스의 권한과 보안을 관리하는 명령어이므로 SELECT는 DCL 명령어가 아니다.",
  "choices" : "1.COMMIT/2.ROLLBACK/3.GRANT/4.SELECT/"
}, {
  "question" : "병행제어 기법 중 로킹에 대한 설명으로 옳지 않은 것은?",
  "answer" : "4.로킹의 단위가 커지면 데이터베이스 공유도가 증가한다.",
  "commentary" : "\"로킹의 단위가 커지면 데이터베이스 공유도가 증가한다.\"는 옳은 설명이다. 로킹 단위가 커지면 여러 개의 객체를 하나의 단위로 묶어서 로킹하므로, 해당 객체에 대한 접근이 필요한 모든 프로세스가 로킹을 해제하기 전까지는 해당 객체에 대한 접근이 불가능하다. 따라서 로킹 단위가 커지면 데이터베이스 공유도가 증가한다.",
  "choices" : "1.로킹의 대상이 되는 객체의 크기를 로킹 단위라고 한다./2.데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다./3.로킹의 단위가 작아지면 로킹 오버헤드가 증가한다./4.로킹의 단위가 커지면 데이터베이스 공유도가 증가한다./"
}, {
  "question" : "관계 데이터모델의 무결성 제약 중 기본키 값의 속성 값이 널(Null)값이 아닌 원자 값을 갖는 성질은?",
  "answer" : "1.개체 무결성",
  "commentary" : "기본키 값의 속성 값이 널(Null)값이 아닌 원자 값을 갖는 성질은 \"개체 무결성\"이다. 개체 무결성은 각 테이블의 기본키 값이 반드시 존재하고, 중복되지 않으며 널(Null)값이 될 수 없는 것을 보장하는 제약 조건이다. 따라서 기본키 값은 항상 원자 값이어야 하며, 널(Null)값이 될 수 없다.",
  "choices" : "1.개체 무결성/2.참조 무결성/3.도메인 무결성/4.튜플의 유일성/"
}, {
  "question" : "뷰(View)의 장점이 아닌 것은?",
  "answer" : "1.뷰 자체로 인덱스를 가짐",
  "commentary" : "\"뷰 자체로 인덱스를 가짐\"은 뷰의 장점이 아닙니다. 뷰는 데이터베이스에서 테이블과 유사한 개념으로, 특정 조건에 따라 필요한 데이터만 선택하여 보여주는 가상의 테이블입니다. 따라서 뷰는 데이터 보안 용이, 논리적 독립성 제공, 사용자 데이터 관리 용이 등의 장점을 가지고 있습니다. 하지만 뷰 자체로 인덱스를 가지는 것은 아니며, 뷰를 생성할 때 기존 테이블의 인덱스를 활용할 수 있습니다.",
  "choices" : "1.뷰 자체로 인덱스를 가짐/2.데이터 보안 용이/3.논리적 독립성 제공/4.사용자 데이터 관리 용이/"
}, {
  "question" : "분산 데이터베이스의 투명성(Transparency)에 해당 하지 않는 것은?",
  "answer" : "4.Media Access Transparency",
  "commentary" : "분산 데이터베이스에서의 투명성은 사용자나 응용 프로그램이 분산 데이터베이스를 사용할 때 분산 시스템의 내부 동작을 알 필요 없이 일관된 인터페이스를 제공하는 것을 말합니다. 따라서 \"Media Access Transparency\"는 분산 데이터베이스의 투명성에 해당하지 않습니다. 이는 데이터가 저장된 미디어(하드디스크, SSD 등)에 대한 접근 방법에 대한 투명성을 의미하는데, 이는 분산 데이터베이스의 구성과는 직접적인 연관성이 없기 때문입니다.",
  "choices" : "1.Location Transparency/2.Replication Transparency/3.Failure Transparency/4.Media Access Transparency/"
}, {
  "question" : "정규화의 목적으로 옳지 않은 것은?",
  "answer" : "3.중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 야기한다.",
  "commentary" : "정규화의 목적은 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 줄이는 것이 아니라, 이상 현상을 제거하고 데이터의 일관성과 무결성을 유지하는 것입니다. 중복을 배제하는 것은 정규화의 과정 중 하나일 뿐입니다.",
  "choices" : "1.어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만든다./2.데이터 삽입시 릴레이션을 재구성할 필요성을 줄인다./3.중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 야기한다./4.효과적인 검색 알고리즘을 생성할 수 있다./"
}, {
  "question" : "다음에 해당하는 함수 종속의 추론 규칙은?",
  "answer" : "2.이행 규칙",
  "commentary" : "이 함수 종속의 추론 규칙은 이행 규칙이다. 이유는 A → B, B → C가 주어졌을 때, A → C를 유도할 수 있기 때문이다. 이는 B를 중간 단계로 사용하여 A와 C를 연결하는 것이 가능하기 때문이다.",
  "choices" : "1.분해 규칙/2.이행 규칙/3.반사 규칙/4.결합 규칙/"
}, {
  "question" : "다음 R과 S 두 릴레이션에 대한 Division 연산의 수행 결과는?",
  "answer" : "4.",
  "commentary" : "Division 연산은 릴레이션 R에서 모든 튜플이 릴레이션 S의 모든 튜플과 매칭되는 경우에만 결과로 해당 튜플을 포함한다. 따라서, R에서 A와 B가 모두 1인 경우에만 S의 모든 튜플과 매칭되므로, 결과는 \"\" 이다.",
  "choices" : "1./2./3./4./"
}, {
  "question" : "player 테이블에는 player_name, team_id, height 컬럼이 존재한다. 아래 SQL문에서 문법적 오류가 있는 부분은?",
  "answer" : "4.(4)",
  "commentary" : "SQL문에서 문법적 오류가 있는 부분은 \"(3)\"이다. SELECT 문에서 player_name, team_id, height 컬럼을 선택하고 있지만, FROM 절에서 해당 컬럼들이 속한 테이블인 player 테이블을 지정해주지 않았기 때문이다. 따라서, FROM 절에 \"FROM player\"를 추가해주어야 한다.",
  "choices" : "1.(1)/2.(2)/3.(3)/4.(4)/"
}, {
  "question" : "데이터베이스 로그(log)를 필요로 하는 회복 기법은?",
  "answer" : "1.즉각 갱신 기법",
  "commentary" : "즉각 갱신 기법은 데이터를 변경할 때마다 로그를 즉시 기록하여 데이터베이스의 일관성을 유지하는 회복 기법이다. 다른 세 가지 기법은 모두 데이터 변경 시 로그를 기록하지만, 즉각 갱신 기법과는 달리 로그를 기록하는 시점이 다르다. 따라서 즉각 갱신 기법은 데이터베이스의 신뢰성을 높이는 데 효과적이다.",
  "choices" : "1.즉각 갱신 기법/2.대수적 코딩 방법/3.타임 스탬프 기법/4.폴딩 기법/"
}, {
  "question" : "DML(Data Manipulation Language) 명령어가 아닌 것은?",
  "answer" : "3.ALTER",
  "commentary" : "ALTER은 데이터를 조작하는 명령어가 아니라 데이터베이스의 구조를 변경하는 명령어이기 때문에 DML(Data Manipulation Language) 명령어가 아니다. INSERT, UPDATE, DELETE는 데이터를 조작하는 명령어이다.",
  "choices" : "1.INSERT/2.UPDATE/3.ALTER/4.DELETE/"
}, {
  "question" : "다음과 같이 위쪽 릴레이션을 아래쪽 릴레이션으로 정규화를 하였을 때 어떤 정규화 작업을 한 것인가?",
  "answer" : "1.제1정규형",
  "commentary" : "위쪽 릴레이션은 중복된 데이터가 존재하며, 각 속성이 원자값을 가지지 않고 다중값을 가지고 있습니다. 따라서 이를 제1정규형으로 정규화하였습니다. 제1정규형은 각 속성이 원자값을 가지도록 분해하는 것을 의미합니다.",
  "choices" : "1.제1정규형/2.제2정규형/3.제3정규형/4.제4정규형/"
}, {
  "question" : "관계대수의 순수관계 연산자가 아닌 것은?",
  "answer" : "2.Cartesian Product",
  "commentary" : "Cartesian Product는 두 개의 릴레이션에서 모든 가능한 조합을 만들어 새로운 릴레이션을 생성하는 연산자이기 때문에, 순수관계 연산자가 아닙니다. 다른 연산자들은 릴레이션에서 특정 조건에 맞는 튜플을 선택하거나, 특정 속성만을 선택하거나, 두 릴레이션에서 공통된 속성을 기준으로 나누는 등의 작업을 수행합니다.",
  "choices" : "1.Select/2.Cartesian Product/3.Division/4.Project/"
}, {
  "question" : "다음 중 SQL의 집계 함수(aggregation function)가 아닌 것은?",
  "answer" : "4.CREATE",
  "commentary" : "\"CREATE\"는 SQL에서 데이터베이스나 테이블을 생성하는 명령어이며, 집계 함수(aggregation function)가 아닙니다. AVG, COUNT, SUM은 데이터를 집계하여 결과를 반환하는 함수들입니다.",
  "choices" : "1.AVG/2.COUNT/3.SUM/4.CREATE/"
}, {
  "question" : "릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상을 의미하는 것은?",
  "answer" : "4.anomaly",
  "commentary" : "\"anomaly\"는 릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 현상을 의미한다. 이는 데이터의 일관성과 정확성을 해치며, 데이터베이스의 성능을 저하시키는 원인이 될 수 있다. 따라서 이러한 현상을 방지하기 위해 정규화(normalization)과 같은 데이터베이스 설계 기법을 사용하게 된다.",
  "choices" : "1.normalization/2.rollback/3.cardinality/4.anomaly/"
}, {
  "question" : "릴레이션에 대한 설명으로 거리가 먼 것은?",
  "answer" : "4.한 릴레이션에 포함된 튜플 사이에는 순서가 있다.",
  "commentary" : "한 릴레이션에 포함된 튜플 사이에는 순서가 있다는 것은 릴레이션에서 튜플의 순서가 중요하다는 것을 의미합니다. 이는 특정 애트리뷰트를 기준으로 정렬하거나, 특정 튜플을 참조하기 위해 인덱스를 사용하는 등의 작업에서 중요한 역할을 합니다. 따라서 릴레이션에서 튜플의 순서는 유지되어야 합니다.",
  "choices" : "1.튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다./2.한 릴레이션에 포함된 튜플들은 모두 상이하다./3.애트리뷰트는 논리적으로 쪼갤 수 없는 원자값으로 저장한다./4.한 릴레이션에 포함된 튜플 사이에는 순서가 있다./"
}, {
  "question" : "다음 자바 프로그램 조건문에 대해 삼항 조건 연산자를 사용하여 옳게 나타낸 것은?",
  "answer" : "1.int i = 7, j = 9; int k; k = (i＞j)?(i – j):(i + j);",
  "commentary" : "정답은 \"int i = 7, j = 9; int k; k = (i＞j)?(i – j):(i + j);\" 이다. 이유는 삼항 조건 연산자는 조건식이 참(true)이면 첫 번째 표현식을, 거짓(false)이면 두 번째 표현식을 반환한다. 따라서 i가 j보다 크면 i-j를, 그렇지 않으면 i+j를 k에 대입하게 된다.",
  "choices" : "1.int i = 7, j = 9; int k; k = (i＞j)?(i – j):(i + j);/2.int i = 7, j = 9; int k; k = (i＜j)?(i – j):(i + j);/3.int i = 7, j = 9; int k; k = (i＞j)?(i + j):(i - j);/4.int i = 7, j = 9; int k; k = (i＜j)?(i + j):(i - j);/"
}, {
  "question" : "다음 내용이 설명하는 소프트웨어 취약점은?",
  "answer" : "3.버퍼 오버플로",
  "commentary" : "이미 할당된 버퍼의 크기를 초과하여 데이터를 입력하면, 해당 데이터가 메모리 영역을 침범하여 다른 데이터나 코드를 덮어쓰는 취약점을 버퍼 오버플로라고 합니다. 그림에서는 입력한 데이터가 버퍼를 초과하여 다른 메모리 영역을 침범하는 것을 보여주고 있습니다. 따라서 정답은 \"버퍼 오버플로\"입니다.",
  "choices" : "1.FTP 바운스 공격/2.SQL 삽입/3.버퍼 오버플로/4.디렉토리 접근 공격/"
}, {
  "question" : "다음 중 bash 쉘 스크립트에서 사용할 수 있는 제어문이 아닌 것은?",
  "answer" : "3.repeat_do",
  "commentary" : "\"repeat_do\"는 bash 쉘 스크립트에서 사용할 수 없는 제어문입니다. 이유는 bash 쉘 스크립트에서는 \"repeat_do\"라는 제어문이 존재하지 않기 때문입니다. \"if\", \"for\", \"while\"은 bash 쉘 스크립트에서 자주 사용되는 제어문입니다.",
  "choices" : "1.if/2.for/3.repeat_do/4.while/"
}, {
  "question" : "IPv6에 대한 설명으로 틀린 것은?",
  "answer" : "1.32비트의 주소체계를 사용한다.",
  "commentary" : "정답은 \"32비트의 주소체계를 사용한다.\" 이다. IPv6는 128비트의 주소체계를 사용한다. 이는 IPv4의 주소 고갈 문제를 해결하기 위해 도입된 것이다. IPv6는 멀티미디어의 실시간 처리가 가능하고, IPv4보다 보안성이 강화되며, 자동으로 네트워크 환경구성이 가능하다는 장점이 있다.",
  "choices" : "1.32비트의 주소체계를 사용한다./2.멀티미디어의 실시간 처리가 가능하다./3.IPv4보다 보안성이 강화되었다./4.자동으로 네트워크 환경구성이 가능하다./"
}, {
  "question" : "효과적인 모듈 설계를 위한 유의사항으로 거리가 먼 것은?",
  "answer" : "3.모듈의 기능은 예측이 가능해야 하며 지나치게 제한적 이여야 한다.",
  "commentary" : "모듈의 기능이 지나치게 제한적이지 않으면 다른 모듈과의 결합도가 높아져서 모듈 간의 의존성이 높아지고, 이로 인해 유지보수가 어려워질 수 있습니다. 따라서 모듈의 기능은 예측 가능하면서도 필요한 기능을 충분히 수행할 수 있도록 설계해야 합니다.",
  "choices" : "1.모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다./2.복잡도와 중복성을 줄이고 일관성을 유지시킨다./3.모듈의 기능은 예측이 가능해야 하며 지나치게 제한적 이여야 한다./4.유지보수가 용이해야 한다./"
}, {
  "question" : "HRN 방식으로 스케줄링 할 경우, 입력된 작업이 다음과 같을 때 처리되는 작업 순서로 옳은 것은?",
  "answer" : "3.D→B→C→A",
  "commentary" : "HRN 방식은 우선순위가 높은 작업을 먼저 처리하는 방식이다. 이를 위해 각 작업의 대기 시간과 작업 시간을 이용하여 우선순위를 계산한다. 먼저, 각 작업의 대기 시간을 계산해보면 다음과 같다. - 작업 A: 0 - 작업 B: 2 - 작업 C: 4 - 작업 D: 6 다음으로, 각 작업의 작업 시간을 이용하여 HRN 우선순위를 계산해보면 다음과 같다. - 작업 A: 1 / 3 = 0.33 - 작업 B: 2 / 2 = 1 - 작업 C: 4 / 2 = 2 - 작업 D: 6 / 1 = 6 따라서, 작업 D가 가장 높은 우선순위를 가지므로 가장 먼저 처리되어야 한다. 그 다음으로는 작업 B, C, A 순으로 처리되어야 한다. 따라서 정답은 \"D→B→C→A\"이다.",
  "choices" : "1.A→B→C→D/2.A→C→B→D/3.D→B→C→A/4.D→A→B→C/"
}, {
  "question" : "운영체제에 대한 설명으로 거리가 먼 것은?",
  "answer" : "3.운영체제의 종류로는 매크로 프로세서, 어셈블러, 컴파일러 등이 있다.",
  "commentary" : "운영체제의 종류로는 매크로 프로세서, 어셈블러, 컴파일러 등이 있다는 설명이 거리가 먼 것입니다. 이는 운영체제가 아닌 개발 도구들이기 때문입니다. 운영체제는 다중 사용자와 다중 응용프로그램 환경하에서 자원의 현재 상태를 파악하고 자원 분배를 위한 스케줄링을 담당하며, CPU, 메모리 공간, 기억 장치, 입출력 장치 등의 자원을 관리하고, 입출력 장치와 사용자 프로그램을 제어합니다.",
  "choices" : "1.다중 사용자와 다중 응용프로그램 환경하에서 자원의 현재 상태를 파악하고 자원 분배를 위한 스케줄링을 담당한다./2.CPU, 메모리 공간, 기억 장치, 입출력 장치 등의 자원을 관리한다./3.운영체제의 종류로는 매크로 프로세서, 어셈블러, 컴파일러 등이 있다./4.입출력 장치와 사용자 프로그램을 제어한다./"
}, {
  "question" : "배치 프로그램의 필수 요소에 대한 설명으로 틀린 것은?",
  "answer" : "4.무결성은 주어진 시간 내에 처리를 완료할 수 있어야 하고, 동시에 동작하고 있는 다른 애플리케이션을 방해하지 말아야 한다.",
  "commentary" : "틀린 것은 없다. 모든 요소가 배치 프로그램의 필수 요소이며, 무결성은 주어진 시간 내에 처리를 완료할 수 있어야 하고, 동시에 동작하고 있는 다른 애플리케이션을 방해하지 말아야 한다는 것은 배치 프로그램이 안정적으로 동작할 수 있도록 중요한 요소 중 하나이다.",
  "choices" : "1.자동화는 심각한 오류 상황 외에는 사용자의 개입 없이 동작해야 한다./2.안정성은 어떤 문제가 생겼는지, 언제 발생했는지 등을 추적할 수 있어야 한다./3.대용량 데이터는 대용량의 데이터를 처리할 수 있어야 한다./4.무결성은 주어진 시간 내에 처리를 완료할 수 있어야 하고, 동시에 동작하고 있는 다른 애플리케이션을 방해하지 말아야 한다./"
}, {
  "question" : "TCP 프로토콜에 대한 설명으로 거리가 먼 것은?",
  "answer" : "2.기본 헤더 크기는 100byte이고 160byte까지 확장 가능하다.",
  "commentary" : "기본 헤더 크기가 100byte이고 160byte까지 확장 가능한 것은 TCP 헤더의 크기에 대한 설명이며, 나머지 보기들은 TCP 프로토콜의 특징들에 대한 설명이다.",
  "choices" : "1.신뢰성이 있는 연결 지향형 전달 서비스이다./2.기본 헤더 크기는 100byte이고 160byte까지 확장 가능하다./3.스트림 전송 기능을 제공한다./4.순서제어, 오류제어, 흐름제어 기능을 제공한다./"
}, {
  "question" : "다음이 설명하는 응집도의 유형은?",
  "answer" : "4.절차적 응집도",
  "commentary" : "이 그림은 하나의 기능을 수행하기 위해 여러 단계의 절차를 거치는 모습을 보여주고 있습니다. 따라서 이는 절차적 응집도입니다.",
  "choices" : "1.기능적 응집도/2.우연적 응집도/3.논리적 응집도/4.절차적 응집도/"
}, {
  "question" : "OSI-7Layer에서 링크의 설정과 유지 및 종료를 담당하며, 노드간의 오류제어와 흐름제어 기능을 수행하는 계층은?",
  "answer" : "1.데이터링크 계층",
  "commentary" : "데이터링크 계층은 OSI-7Layer에서 링크의 설정과 유지 및 종료를 담당하며, 노드간의 오류제어와 흐름제어 기능을 수행하는 계층입니다. 이 계층은 물리 계층에서 전송된 비트열을 프레임으로 구성하고, 이를 논리적인 단위로 분할하여 각각의 프레임에 대한 주소와 제어 정보를 추가합니다. 또한, 이 계층에서는 오류 검출과 수정을 위한 기능도 수행합니다. 따라서, 데이터링크 계층이 링크의 안정성과 신뢰성을 보장하는 중요한 역할을 수행하고 있습니다.",
  "choices" : "1.데이터링크 계층/2.물리 계층/3.세션 계층/4.응용 계층/"
}, {
  "question" : "다음 중 가장 결합도가 강한 것은?",
  "answer" : "3.common coupling",
  "commentary" : "가장 결합도가 강한 것은 \"common coupling\"이다. 이는 모듈들이 공통적인 전역 변수나 자료 구조를 공유하고, 이를 통해 서로 의존하게 되는 경우를 의미한다. 이러한 결합도는 모듈 간의 의존성이 매우 높아져서 하나의 모듈이 수정되면 다른 모듈들도 영향을 받을 가능성이 높아진다. 따라서 이러한 결합도는 모듈화의 목적에 부합하지 않으며, 유지보수와 확장성 측면에서도 좋지 않다.",
  "choices" : "1.data coupling/2.stamp coupling/3.common coupling/4.control coupling/"
}, {
  "question" : "메모리 관리 기법 중 Worst fit 방법을 사용할 경우 10K 크기의 프로그램 실행을 위해서는 어느 부분에 할당되는가?",
  "answer" : "4.NO.5",
  "commentary" : null,
  "choices" : "1.NO.2/2.NO.3/3.NO.4/4.NO.5/"
}, {
  "question" : "200.1.1.0/24 네트워크를 FLSM 방식을 이용하여 10개의 Subnet으로 나누고 ip subnet-zero를 적용했다. 이때 서브네팅된 네트워크 중 10번째 네트워크의 broadcast IP주소는?",
  "answer" : "1.200.1.1.159",
  "commentary" : "FLSM 방식을 이용하여 10개의 Subnet으로 나누었으므로, 2의 4승인 16개의 호스트 비트가 필요하다. 따라서 서브넷 마스크는 255.255.255.240이 된다. 이때 10번째 서브넷은 200.1.1.144/28이 된다. 이 서브넷의 마지막 호스트 IP는 200.1.1.159이므로, 이 서브넷의 broadcast IP주소는 마지막 호스트 IP에서 1을 더한 200.1.1.160이 아니라, 마지막 호스트 IP에서 1을 뺀 200.1.1.159이 된다. 따라서 정답은 \"200.1.1.159\"이다.",
  "choices" : "1.200.1.1.159/2.201.1.5.175/3.202.1.11.254/4.203.1.255.245/"
}, {
  "question" : "다음은 사용자로부터 입력받은 문자열에서 처음과 끝의 3글자를 추출한 후 합쳐서 출력하는 파이썬 코드에서 ㉠에 들어갈 내용은?",
  "answer" : "3.string[0:3] + string[-3:]",
  "commentary" : "정답은 \"string[0:3] + string[-3:]\"입니다. 이유는 다음과 같습니다. - \"string[0:3]\"은 문자열의 처음부터 3번째 글자까지 추출하는 슬라이싱입니다. - \"string[-3:]\"은 문자열의 끝에서부터 3번째 글자부터 끝까지 추출하는 슬라이싱입니다. - 두 슬라이싱 결과를 \"+\" 연산자로 합치면 처음과 끝의 3글자를 추출한 후 합쳐진 문자열이 만들어집니다.",
  "choices" : "1.string[1:3] + string[-3:]/2.string[:3] + string[-3:-1]/3.string[0:3] + string[-3:]/4.string[0:] + string[:-1]/"
}, {
  "question" : "파이썬의 변수 작성 규칙 설명으로 옳지 않은 것은?",
  "answer" : "3.변수 이름의 중간에 공백을 사용할 수 있다.",
  "commentary" : "변수 이름의 중간에 공백을 사용할 수 없다는 것이 옳지 않은 설명입니다. 변수 이름은 공백 없이 작성해야 합니다. 공백 대신에 밑줄(_)을 사용할 수 있습니다. 이유는 파이썬에서 공백은 문장의 구분을 위해 사용되기 때문입니다. 변수 이름에 공백이 포함되면 파이썬은 그것을 문장의 일부로 인식하게 되어 문법 오류가 발생합니다.",
  "choices" : "1.첫 자리에 숫자를 사용할 수 없다./2.영문 대문자/소문자, 숫자, 밑줄(_)의 사용이 가능하다./3.변수 이름의 중간에 공백을 사용할 수 있다./4.이미 사용되고 있는 예약어는 사용할 수 없다./"
}, {
  "question" : "어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어신호를 이용하여 통신하는 경우이며, 하위 모듈에서 상위 모듈로 제어신호가 이동하여 상위 모듈에게 처리 명령을 부여하는 권리 전도현상이 발생하게 되는 결합도는?",
  "answer" : "3.control coupling",
  "commentary" : "제어신호를 이용하여 다른 모듈의 내부 논리를 제어하는 결합도를 \"control coupling\"이라고 한다. 이는 하위 모듈에서 상위 모듈로 제어신호가 이동하여 상위 모듈에게 처리 명령을 부여하는 권리 전도현상이 발생하기 때문이다. 즉, 상위 모듈이 하위 모듈의 내부 동작을 직접적으로 제어하게 되는 것이다. 이는 모듈 간의 의존성이 높아져 유지보수와 확장성이 저하될 수 있다.",
  "choices" : "1.data coupling/2.stamp coupling/3.control coupling/4.common coupling/"
}, {
  "question" : "다음 C 프로그램의 결과 값은?",
  "answer" : "3.25",
  "commentary" : "이 프로그램은 두 개의 변수 a와 b를 선언하고, a에 10을 대입하고 b에 15를 대입한 후, a와 b를 더한 값을 출력하는 프로그램이다. 따라서 a와 b를 더한 값인 25가 출력된다.",
  "choices" : "1.15/2.19/3.25/4.27/"
}, {
  "question" : "UNIX에서 새로운 프로세스를 생성하는 명령어는?",
  "answer" : "3.fork",
  "commentary" : "정답은 \"fork\"이다. \"fork\"는 UNIX에서 새로운 프로세스를 생성하는 시스템 콜이다. 이 명령어를 사용하면 현재 실행 중인 프로세스의 복제본이 생성되어 새로운 프로세스가 만들어진다. 이 새로운 프로세스는 부모 프로세스와 동일한 코드와 데이터를 가지지만, 자신만의 고유한 프로세스 ID를 가진다. 이를 통해 여러 개의 프로세스를 동시에 실행하고, 병렬 처리를 할 수 있다.",
  "choices" : "1.ls/2.cat/3.fork/4.chmod/"
}, {
  "question" : "C언어에서 정수 자료형으로 옳은 것은?",
  "answer" : "1.int",
  "commentary" : "정수 자료형은 소수점 이하를 가지지 않는 숫자를 다루는 자료형이다. 따라서 \"int\"가 정답이다. \"float\"와 \"double\"은 소수점 이하를 가지는 실수 자료형이고, \"char\"는 문자 자료형이다.",
  "choices" : "1.int/2.float/3.char/4.double/"
}, {
  "question" : "물리적인 사물과 컴퓨터에 동일하게 표현되는 가상의 모델로 실제 물리적인 자산 대신 소프트웨어로 가상화함으로써 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있고, 자산 최적화, 돌발사고 최소화, 생산성 증가 등 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬 수 있는 모델은?",
  "answer" : "3.디지털 트윈",
  "commentary" : "디지털 트윈은 물리적인 자산을 소프트웨어로 가상화하여 정확한 정보를 얻을 수 있고, 이를 통해 자산 최적화와 돌발사고 최소화, 생산성 증가 등의 효율성을 높일 수 있는 모델입니다. 따라서 \"최적화\"와 \"돌발사고 최소화\", \"생산성 증가\"와 관련된 단어들이 포함된 보기 중에서 디지털 트윈이 정답입니다. \"실행 시간\"과 \"N-Screen\"은 디지털 트윈과 직접적인 관련이 없는 단어들입니다.",
  "choices" : "1.최적화/2.실행 시간/3.디지털 트윈/4.N-Screen/"
}, {
  "question" : "정보보안의 3대 요소에 해당하지 않는 것은?",
  "answer" : "2.휘발성",
  "commentary" : "정보보안의 3대 요소는 기밀성, 무결성, 가용성입니다. 이 중에서 휘발성은 정보보안의 요소가 아닙니다. 휘발성은 물질이 기체나 증기로 변하는 성질을 말하며, 정보보안과는 관련이 없습니다.",
  "choices" : "1.기밀성/2.휘발성/3.무결성/4.가용성/"
}, {
  "question" : "다음 빈칸에 알맞은 기술은",
  "answer" : "4.Mashup",
  "commentary" : "\"Mashup\"은 여러 개의 서로 다른 소스에서 가져온 데이터나 기능을 조합하여 새로운 애플리케이션을 만드는 기술입니다. 위의 이미지에서도 여러 개의 아이콘이 섞여있는 것을 볼 수 있습니다. 따라서 \"Mashup\"이 정답입니다.",
  "choices" : "1.Quantum Key Distribution/2.Digital Rights Management/3.Grayware/4.Mashup/"
}, {
  "question" : "기능점수(Functional Point)모형에서 비용산정에 이용되는 요소가 아닌 것은?",
  "answer" : "1.클래스 인터페이스",
  "commentary" : "기능점수 모형에서 비용산정에 이용되는 요소는 명령어(사용자 질의수), 데이터파일, 출력보고서입니다. 이들은 시스템의 기능적인 측면을 나타내는 것으로, 시스템의 기능을 수행하는 데 필요한 요소들입니다. 반면, 클래스 인터페이스는 시스템의 구조적인 측면을 나타내는 것으로, 시스템의 내부 구조와 관련된 것입니다. 따라서, 클래스 인터페이스는 비용산정에 이용되지 않습니다.",
  "choices" : "1.클래스 인터페이스/2.명령어(사용자 질의수)/3.데이터파일/4.출력보고서/"
}, {
  "question" : "블록 암호화 방식이 아닌 것은?",
  "answer" : "2.RC4",
  "commentary" : "RC4은 스트림 암호화 방식이므로 블록 암호화 방식이 아니다. DES, AES, SEED은 블록 암호화 방식이다.",
  "choices" : "1.DES/2.RC4/3.AES/4.SEED/"
}, {
  "question" : "Putnam 모형을 기초로 해서 만든 자동화 추정 도구는?",
  "answer" : "2.SLIM",
  "commentary" : "Putnam 모형은 소프트웨어 개발 프로젝트의 크기와 복잡도를 추정하는 모델이다. SLIM은 Putnam 모형을 기반으로 한 자동화 추정 도구로, 소프트웨어 개발 프로젝트의 크기, 비용, 일정 등을 추정할 수 있다. 따라서 SLIM이 Putnam 모형을 기반으로 한 자동화 추정 도구임을 알 수 있다.",
  "choices" : "1.SQLR/30/2.SLIM/3.MESH/4.NFV/"
}, {
  "question" : "큰 숫자를 소인수 분해하기 어렵다는 기반 하에 1978년 MIT에 의해 제안된 공개키 암호화 알고리즘은?",
  "answer" : "4.RSA",
  "commentary" : "RSA 알고리즘은 큰 소수를 이용하여 공개키와 개인키를 생성하고, 이를 이용하여 암호화와 복호화를 수행하는 알고리즘이다. 이 알고리즘은 소인수분해 문제의 어려움을 기반으로 하여 안전성이 높은 암호화 방식으로 인정받고 있으며, 현재까지도 많이 사용되고 있다. 따라서, RSA가 큰 숫자를 소인수 분해하기 어렵다는 기반 하에 제안된 공개키 암호화 알고리즘이라는 이유로 정답이다.",
  "choices" : "1.DES/2.ARIA/3.SEED/4.RSA/"
}, {
  "question" : "COCOMO 모델의 프로젝트 유형으로 거리가 먼 것은?",
  "answer" : "4.Sequentail",
  "commentary" : "COCOMO 모델의 프로젝트 유형 중에서 \"Sequentail\"이 거리가 먼 것은, 이유는 다음과 같다. \"Sequentail\"은 프로젝트의 규모가 크고 복잡하며, 개발에 필요한 시간과 비용이 많이 드는 유형이다. 또한, 이 유형의 프로젝트는 개발 단계가 일련의 단계로 진행되어야 하며, 각 단계가 완료되어야 다음 단계로 진행할 수 있다. 이러한 특성 때문에 \"Sequentail\" 프로젝트는 개발 과정에서 발생할 수 있는 문제를 미리 예측하고 대처할 수 있는 체계적인 계획과 관리가 필요하다. 따라서, \"Sequentail\"은 COCOMO 모델에서 거리가 먼 프로젝트 유형 중 하나이다.",
  "choices" : "1.Organic/2.Semi-detached/3.Embedded/4.Sequentail/"
}, {
  "question" : "빅데이터 분석 기술 중 대량의 데이터를 분석하여 데이터 속에 내재되어 있는 변수 사이의 상호관례를 규명하여 일정한 패턴을 찾아내는 기법은?",
  "answer" : "1.Data Mining",
  "commentary" : "Data Mining은 대량의 데이터를 분석하여 내재되어 있는 변수 사이의 상호관계를 찾아내는 기술이다. 이를 통해 데이터 속에 숨겨진 패턴을 발견하고, 이를 활용하여 예측 모델을 만들거나 의사결정을 지원하는 등의 다양한 활용이 가능하다. 따라서, 위의 보기 중에서 Data Mining이 대량의 데이터를 분석하여 패턴을 찾아내는 기술이기 때문에 정답이 된다.",
  "choices" : "1.Data Mining/2.Wm-Bus/3.Digital Twin/4.Zigbee/"
}, {
  "question" : "기존 무선 랜의 한계 극복을 위해 등장하였으며, 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신, 홈네트워킹, 공공 안전 등의 특수목적을 위한 새로운 방식의 네트워크 기술을 의미하는 것은?",
  "answer" : "4.Mesh Network",
  "commentary" : "Mesh Network는 기존 무선 랜의 한계를 극복하기 위해 등장한 새로운 방식의 네트워크 기술로, 대규모 디바이스의 네트워크 생성에 최적화되어 있습니다. 이는 각 디바이스가 서로 연결되어 네트워크를 형성하며, 중앙 집중식이 아닌 분산형 구조를 가지고 있어서 더욱 안정적이고 확장성이 높은 특징을 가지고 있습니다.",
  "choices" : "1.Software Defined Perimeter/2.Virtual Private Network/3.Local Area Network/4.Mesh Network/"
}, {
  "question" : "DDoS 공격과 연관이 있는 공격 방법은?",
  "answer" : "2.Tribe Flood Network",
  "commentary" : "Tribe Flood Network는 DDoS 공격을 수행하는 봇넷 중 하나로, 대규모의 컴퓨터들을 감염시켜 공격 대상 서버에 대량의 데이터를 보내서 서비스를 마비시키는 공격을 수행합니다. 따라서 DDoS 공격과 연관이 있습니다. Secure shell은 원격으로 안전하게 컴퓨터를 제어하기 위한 프로토콜이며, Nimda와 Deadlock은 각각 컴퓨터 바이러스와 웜으로, DDoS 공격과는 직접적인 연관이 없습니다.",
  "choices" : "1.Secure shell/2.Tribe Flood Network/3.Nimda/4.Deadlock/"
}, {
  "question" : "CPM 네트워크가 다음과 같을 때 임계경로의 소요기일은?",
  "answer" : "3.14일",
  "commentary" : null,
  "choices" : "1.10일/2.12일/3.14일/4.16일/"
}, {
  "question" : "RIP(Routing Information Protocol)에 대한 설명으로 틀린 것은?",
  "answer" : "3.최대 홉 카운트를 115홉 이하로 한정하고 있다.",
  "commentary" : "RIP는 최대 홉 카운트를 15로 한정하고 있으며, 이는 라우팅 루프를 방지하기 위한 것이다. 따라서 \"최대 홉 카운트를 115홉 이하로 한정하고 있다.\"는 틀린 설명이다.",
  "choices" : "1.거리 벡터 라우팅 프로토콜이라고도 한다./2.소규모 네트워크 환경에 적합하다./3.최대 홉 카운트를 115홉 이하로 한정하고 있다./4.최단경로탐색에는 Bellman-Ford 알고리즘을 사용한다./"
}, {
  "question" : "소프트웨어 생명주기 모형 중 고전적 생명주기 모형으로 선형 순차적 모델이라고도 하며, 타당성 검토, 계획, 요구사항 분석, 구현, 테스트, 유지보수의 단계를 통해 소프트웨어를 개발하는 모형은?",
  "answer" : "1.폭포수 모형",
  "commentary" : "폭포수 모형은 개발 단계를 선형적으로 진행하는 모형으로, 이전 단계가 완료되어야 다음 단계로 진행할 수 있다. 따라서 각 단계가 순차적으로 진행되며, 이전 단계에서 발생한 문제점을 다음 단계에서 수정하는 방식으로 개발이 이루어진다. 이러한 특징 때문에 요구사항 분석 단계에서 충분한 검토와 검증이 이루어지지 않으면 나중에 문제가 발생할 수 있다.",
  "choices" : "1.폭포수 모형/2.애자일 모형/3.컴포넌트 기반 방법론/4.6GT 모형/"
}, {
  "question" : "소프트웨어 개발 모델 중 나선형 모델의 4가지 주요 활동이 순서대로 나열된 것은?",
  "answer" : "2.Ⓐ-Ⓓ-Ⓒ-Ⓑ 순으로 반복",
  "commentary" : "나선형 모델은 계획, 위험 분석, 개발 및 평가라는 4가지 주요 활동을 순차적으로 반복하면서 소프트웨어를 개발하는 모델이다. 따라서 \"Ⓐ-Ⓓ-Ⓒ-Ⓑ 순으로 반복\"인 이유는 계획, 위험 분석, 개발, 평가의 순서로 진행하다가 문제가 발생하면 다시 계획부터 시작하여 위험 분석, 개발, 평가를 반복하는 과정에서 순서가 반복되기 때문이다.",
  "choices" : "1.Ⓐ-Ⓑ-Ⓓ-Ⓒ 순으로 반복/2.Ⓐ-Ⓓ-Ⓒ-Ⓑ 순으로 반복/3.Ⓐ-Ⓑ-Ⓒ-Ⓓ 순으로 반복/4.Ⓐ-Ⓒ-Ⓑ-Ⓓ 순으로 반복/"
}, {
  "question" : "전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?",
  "answer" : "1.합성 중심",
  "commentary" : "합성 중심은 전체 시스템을 구성하는 작은 블록들을 만들어서 조합하는 방법으로 소프트웨어를 완성시키는 재사용 방법입니다. 이 방법은 작은 블록들을 조합하여 다양한 기능을 가진 큰 시스템을 만들 수 있으며, 유지보수와 확장성이 용이합니다. 따라서 소프트웨어 개발에서 가장 많이 사용되는 방법 중 하나입니다.",
  "choices" : "1.합성 중심/2.생성 중심/3.분리 중심/4.구조 중심/"
}, {
  "question" : "다음 JAVA코드에서 밑줄로 표시된 부분에는 어떤 보안 약점이 존재하는가? (단, key는 암호화 키를 저장하는 변수이다.)",
  "answer" : "3.하드코드된 암호화 키 사용",
  "commentary" : "하드코드된 암호화 키 사용은 암호화 키를 코드 내에 직접 입력하는 것으로, 코드가 유출되면 암호화된 데이터를 해독할 수 있는 보안 약점이 존재한다. 따라서 암호화 키는 코드 내에 직접 입력하지 않고, 안전한 저장소에 보관하고 필요할 때마다 호출하여 사용해야 한다.",
  "choices" : "1.무결성 검사 없는 코드 다운로드/2.중요 자원에 대한 잘못된 권한 설정/3.하드코드된 암호화 키 사용/4.적절한 인증없는 중요 기능 허용/"
}, {
  "question" : "소프트웨어 개발 표준 중 소프트웨어 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준은?",
  "answer" : "3.SPICE",
  "commentary" : "정답은 \"SPICE\"입니다. SPICE는 Software Process Improvement and Capability Determination의 약자로, 소프트웨어 개발 표준 중 하나입니다. 이 표준은 소프트웨어 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준입니다. SPICE는 소프트웨어 개발 프로세스를 6가지 능력 수준으로 분류하고, 각 능력 수준에 대한 평가 지침을 제공합니다. 이를 통해 조직은 자신의 소프트웨어 개발 프로세스를 평가하고 개선할 수 있습니다.",
  "choices" : "1.SCRUM/2.ISO/IEC 12509/3.SPICE/4.CASE/"
}, {
  "question" : "실무적으로 검증된 개발보안 방법론 중 하나로써 SW보안의 모범 사례를 SDLC(Software Development Life Cycle)에 통합한 소프트웨어 개발 보안 생명주기 방법론은?",
  "answer" : "4.Seven Touchpoints",
  "commentary" : "\"Seven Touchpoints\"는 소프트웨어 개발 보안 생명주기 방법론 중 하나로, SDLC의 일곱 단계에서 보안 검증을 수행하는 방법론입니다. 이 방법론은 실무적으로 검증되어 있으며, 보안 취약점을 조기에 발견하고 수정함으로써 보안 위협을 최소화할 수 있습니다. 따라서 \"Seven Touchpoints\"가 정답입니다. \"CLASP\"는 \"Comprehensive, Lightweight Application Security Process\"의 약자로, 소프트웨어 개발 보안 생명주기 방법론 중 하나입니다. \"CWE\"는 \"Common Weakness Enumeration\"의 약자로, 보안 취약점을 분류하는 방법론입니다. \"PIMS\"는 \"Privacy Information Management System\"의 약자로, 개인정보 보호를 위한 정보보호 관리 체계입니다.",
  "choices" : "1.CLASP/2.CWE/3.PIMS/4.Seven Touchpoints/"
}, {
  "question" : "다음 LAN의 네트워크 토폴로지는?",
  "answer" : "1.버스형",
  "commentary" : "이 네트워크 토폴로지는 모든 컴퓨터가 하나의 케이블에 연결되어 있으며, 데이터가 이 케이블을 통해 전송되는 \"버스형\" 토폴로지입니다. 각 컴퓨터는 데이터를 받아들이거나 필요한 경우 데이터를 보내는 데 사용할 수 있는 공유 케이블에 직접 연결됩니다. 이러한 구성은 비교적 간단하고 저렴하지만, 케이블의 단일 점오류(single point of failure) 문제가 발생할 수 있습니다.",
  "choices" : "1.버스형/2.성형/3.링형/4.그물형/"
}, {
  "question" : "검토회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후 짧은 검토 회의를 통해 오류를 조기에 검출하는데 목적을 두는 요구 사항 검토 방법은?",
  "answer" : "3.워크 스루",
  "commentary" : "워크 스루는 요구사항 명세서를 미리 배포하여 사전 검토한 후 짧은 검토 회의를 통해 오류를 조기에 검출하는 방법입니다. 이 방법은 검토회의 전에 요구사항 명세서를 미리 배포하여 검토를 사전에 진행하므로, 검토 회의에서 발견되는 오류를 조기에 검출할 수 있습니다. 따라서 워크 스루는 오류를 조기에 검출하여 비용과 시간을 절약할 수 있는 효과적인 요구사항 검토 방법입니다.",
  "choices" : "1.빌드 검증/2.동료 검토/3.워크 스루/4.개발자 검토/"
}, {
  "question" : "코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는?",
  "answer" : "3.순차 코드",
  "commentary" : "순차 코드는 일정한 규칙에 따라 일련번호를 부여하는 방식으로, 순서대로 증가하는 번호를 사용하여 코드를 부여합니다. 이 방식은 코드 부여가 간단하고 일련번호를 통해 쉽게 구분할 수 있어 유용합니다. 따라서 정답은 \"순차 코드\"입니다.",
  "choices" : "1.연상 코드/2.블록 코드/3.순차 코드/4.표의 숫자 코드/"
}, {
  "question" : "객체지향 프로그램에서 데이터를 추상화하는 단위는?",
  "answer" : "2.클래스",
  "commentary" : "객체지향 프로그램에서 데이터를 추상화하는 단위는 클래스입니다. 클래스는 객체를 생성하기 위한 템플릿으로, 객체의 속성과 행위를 정의합니다. 즉, 클래스는 데이터와 해당 데이터를 다루는 메소드를 포함하고 있으며, 이를 통해 데이터를 추상화하고 캡슐화할 수 있습니다. 상속성과 메시지는 객체지향 프로그래밍의 특징이지만, 데이터를 추상화하는 단위는 클래스입니다.",
  "choices" : "1.메소드/2.클래스/3.상속성/4.메시지/"
}, {
  "question" : "데이터 흐름도(DFD)의 구성요소에 포함되지 않는 것은?",
  "answer" : "4.data dictionary",
  "commentary" : "데이터 흐름도(DFD)의 구성요소는 \"process\", \"data flow\", \"data store\"로 이루어져 있습니다. \"data dictionary\"는 DFD에서 사용되는 용어 및 데이터 정의를 기록하는 도구이지만, DFD의 직접적인 구성요소는 아니기 때문에 정답이 아닙니다.",
  "choices" : "1.process/2.data flow/3.data store/4.data dictionary/"
}, {
  "question" : "소프트웨어 설계시 구축된 플랫폼의 성능특성 분석에 사용되는 측정 항목이 아닌 것은?",
  "answer" : "4.서버 튜닝(Server Tuning)",
  "commentary" : "서버 튜닝은 성능특성 분석에 사용되는 측정 항목이 아니라, 성능특성을 개선하기 위한 방법 중 하나이다. 서버 튜닝은 서버의 하드웨어, 소프트웨어, 네트워크 등을 조정하여 성능을 최적화하는 작업을 말한다. 따라서, 서버 튜닝은 성능특성 분석의 결과를 바탕으로 수행되는 작업이며, 측정 항목이 아니다.",
  "choices" : "1.응답시간(Response Time)/2.가용성(Availability)/3.사용률(Utilization)/4.서버 튜닝(Server Tuning)/"
}, {
  "question" : "UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호로 맞는 것은?",
  "answer" : "1.《 》",
  "commentary" : null,
  "choices" : "1.《 》/2.(( ))/3.{{ }}/4.[[ ]]/"
}, {
  "question" : "GoF(Gang of Four)의 디자인 패턴에서 행위 패턴에 속하는 것은?",
  "answer" : "2.Visitor",
  "commentary" : "행위 패턴은 객체들 간의 상호작용과 책임 분배에 관한 패턴으로, \"Builder\", \"Prototype\", \"Bridge\"는 생성 패턴에 속합니다. 하지만 \"Visitor\"는 객체 구조를 변경하지 않고도 새로운 동작을 추가할 수 있는 패턴으로, 행위 패턴에 속합니다. 따라서 정답은 \"Visitor\"입니다.",
  "choices" : "1.Builder/2.Visitor/3.Prototype/4.Bridge/"
}, {
  "question" : "자료 사전에서 자료의 생략을 의미하는 기호는?",
  "answer" : "4.(　)",
  "commentary" : null,
  "choices" : "1.{ }/2.**/3.=/4.(　)/"
}, {
  "question" : "트랜잭션이 올바르게 처리되고 있는지 데이터를 감시하고 제어하는 미들웨어는?",
  "answer" : "3.TP monitor",
  "commentary" : "TP monitor는 트랜잭션 처리를 감시하고 제어하는 미들웨어로, 분산 환경에서 여러 서버와 클라이언트 간의 통신을 관리하며 데이터 일관성과 안정성을 보장합니다. 따라서 트랜잭션이 올바르게 처리되고 있는지 데이터를 감시하고 제어하는 미들웨어로서 TP monitor가 적합한 선택지입니다. RPC는 원격 프로시저 호출, ORB는 객체 요청 브로커, HUB는 중앙 집중식 통신 제어 시스템을 의미합니다.",
  "choices" : "1.RPC/2.ORB/3.TP monitor/4.HUB/"
}, {
  "question" : "UI 설계 원칙에서 누구나 쉽게 이해하고 사용할 수 있어야 한다는 것은?",
  "answer" : "2.직관성",
  "commentary" : "UI 설계 원칙에서 \"직관성\"은 사용자가 쉽게 이해하고 사용할 수 있어야 한다는 것을 의미합니다. 즉, 사용자가 어떤 기능을 사용하려면 복잡한 과정을 거치거나 많은 시간을 들이지 않고도 직관적으로 이해하고 사용할 수 있어야 합니다. 이는 사용자 경험을 향상시키고, 사용자들이 제품을 좋아하고 자주 사용하게 만들어줍니다.",
  "choices" : "1.유효성/2.직관성/3.무결성/4.유연성/"
}, {
  "question" : "XP(eXtreme Programming)의 5가지 가치로 거리가 먼 것은?",
  "answer" : "3.정형분석",
  "commentary" : "XP의 5가지 가치 중에서 \"정형분석\"은 다른 가치들과는 거리가 먼 것입니다. 이는 XP가 민첩한 개발 방법론으로서, 빠르게 변화하는 요구사항에 대응하기 위해 빠른 프로토타이핑과 테스트 주도 개발(TDD) 등의 방법을 사용하는 반면, 정형분석은 요구사항을 상세하게 분석하고 설계하는 전통적인 방법론입니다. 따라서 XP에서는 정형분석보다는 빠른 프로토타이핑과 TDD 등의 방법을 사용하여 빠르게 개발하고, 필요에 따라 요구사항을 수정하며 개발을 진행합니다.",
  "choices" : "1.용기/2.의사소통/3.정형분석/4.피드백/"
}, {
  "question" : "UML 모델에서 사용하는 Structural Diagram 에 속하지 않은 것은?",
  "answer" : "4.Activity Diagram",
  "commentary" : "Structural Diagram은 시스템의 구조와 구성 요소 간의 관계를 나타내는 다이어그램으로, 클래스, 객체, 컴포넌트 등을 다룹니다. 반면에 Activity Diagram은 시스템의 동적인 행위를 모델링하는 다이어그램으로, Structural Diagram에 속하지 않습니다. 따라서 정답은 Activity Diagram입니다.",
  "choices" : "1.Class Diagram/2.Object Diagram/3.Component Diagram/4.Activity Diagram/"
}, {
  "question" : "소프트웨어 개발 방법 중 요구사항 분석(requirements annalysis)과 거리가 먼 것은?",
  "answer" : "4.설계 명세서 작성",
  "commentary" : "요구사항 분석은 소프트웨어 개발 초기 단계에서 이루어지며, 사용자의 요구사항을 파악하고 문서화하는 과정입니다. 반면에 설계 명세서 작성은 요구사항 분석 이후에 이루어지는 단계로, 요구사항을 바탕으로 시스템의 구조와 동작 방식을 설계하는 과정입니다. 따라서 요구사항 분석과 거리가 먼 것은 설계 명세서 작성입니다.",
  "choices" : "1.비용과 일정에 대한 제약설정/2.타당성 조사/3.요구사항 정의 문서화/4.설계 명세서 작성/"
}, {
  "question" : "럼바우(Rumbaugh)의 객체지향 분석 절차를 가장 바르게 나열한 것은?",
  "answer" : "1.객체 모형→동적 모형→기능 모형",
  "commentary" : "객체지향 분석에서는 먼저 시스템을 구성하는 객체들을 식별하고, 이들 객체들의 속성과 상호작용을 파악하여 객체 모형을 만듭니다. 이후에는 객체들의 동작과 상호작용을 분석하여 동적 모형을 만들고, 마지막으로 시스템이 제공해야 하는 기능을 파악하여 기능 모형을 만듭니다. 따라서 가장 바르게 나열된 절차는 \"객체 모형→동적 모형→기능 모형\" 입니다.",
  "choices" : "1.객체 모형→동적 모형→기능 모형/2.객체 모형→기능 모형→동적 모형/3.기능 모형→동적 모형→객체 모형/4.기능 모형→객체 모형→동적 모형/"
}, {
  "question" : "공통 모듈에 대한 명세 기법 중 해당 기능에 대해 일관되게 이해하고 한 가지로 해석될 수 있도록 작성하는 원칙은?",
  "answer" : "2.명확성",
  "commentary" : "명확성은 공통 모듈에 대한 명세를 작성할 때 해당 기능에 대해 일관되게 이해하고 한 가지로 해석될 수 있도록 작성하는 원칙입니다. 이는 모듈의 기능을 명확하게 정의하고 모호한 해석을 방지하여 개발자들이 모듈을 보다 쉽게 이해하고 사용할 수 있도록 도와줍니다. 따라서 명확성은 공통 모듈의 효율적인 개발과 유지보수를 위해 매우 중요한 요소입니다.",
  "choices" : "1.상호작용성/2.명확성/3.독립성/4.내용성/"
}, {
  "question" : "객체지향 기법에서 클래스들 사이의 ‘부분-전체(part-whole)' 관계 또는 ’부분(is-a-part-of)'의 관계로 설명되는 연관성을 나타내는 용어는?",
  "answer" : "4.집단화",
  "commentary" : "정답은 \"집단화\"입니다. 집단화는 객체지향 프로그래밍에서 클래스들 사이의 '부분-전체' 관계를 나타내는 용어입니다. 즉, 한 클래스가 다른 클래스의 일부분이 되는 것을 의미합니다. 예를 들어, 자동차 클래스는 엔진, 바퀴, 핸들 등의 부품 클래스들의 집단화된 형태로 구성될 수 있습니다. 일반화는 상속 관계를 나타내는 용어이며, 추상화는 객체의 공통적인 특성을 추출하여 클래스로 정의하는 과정을 의미합니다. 캡슐화는 객체의 속성과 행위를 하나로 묶어 정보 은닉을 위한 기법입니다.",
  "choices" : "1.일반화/2.추상화/3.캡슐화/4.집단화/"
}, {
  "question" : "CASE가 갖고 있는 주요 기능이 아닌 것은?",
  "answer" : "3.언어번역",
  "commentary" : "CASE는 소프트웨어 개발 생명주기의 전 단계를 연결하고, 다양한 소프트웨어 개발 모형을 지원하며, 그래픽 지원을 제공하는데, 언어번역 기능은 갖고 있지 않습니다. CASE는 소프트웨어 개발 프로세스를 지원하는 도구로, 요구사항 분석, 설계, 구현, 테스트, 유지보수 등의 단계에서 사용됩니다.",
  "choices" : "1.그래픽 지원/2.소프트웨어 생명주기 전 단계의 연결/3.언어번역/4.다양한 소프트웨어 개발 모형 지원/"
}, {
  "question" : "DBMS 분석시 고려사항으로 거리가 먼 것은?",
  "answer" : "3.네트워크 구성도",
  "commentary" : "DBMS 분석시에는 가용성, 성능, 상호 호환성 등이 중요한 고려사항이지만, 네트워크 구성도는 DBMS 자체와는 직접적인 연관성이 적기 때문에 거리가 먼 것이다. 따라서 DBMS 분석시에는 네트워크 구성도보다는 DBMS의 기능, 성능, 안정성 등과 관련된 요소들이 더 중요하게 고려되어야 한다.",
  "choices" : "1.가용성/2.성능/3.네트워크 구성도/4.상호 호환성/"
}, {
  "question" : "HIPO(Hierarchy Input Process Output)에 대한 설명으로 거리가 먼 것은?",
  "answer" : "1.상향식 소프트웨어 개발을 위한 문서화 도구이다.",
  "commentary" : "\"상향식 소프트웨어 개발을 위한 문서화 도구이다.\"가 거리가 먼 것이 아니라, HIPO는 상향식 소프트웨어 개발을 위한 문서화 도구이다. HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있으며, 기능과 자료의 의존 관계를 동시에 표현할 수 있고, 보기 쉽고 이해하기 쉽다는 것은 HIPO의 특징이다.",
  "choices" : "1.상향식 소프트웨어 개발을 위한 문서화 도구이다./2.HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다./3.기능과 자료의 의존 관계를 동시에 표현할 수 있다./4.보기 쉽고 이해하기 쉽다./"
}, {
  "question" : "객체지향 분석 방법론 중 E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 것은?",
  "answer" : "1.Coad와 Yourdon 방법",
  "commentary" : "E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 것은 Coad와 Yourdon 방법이다. 이 방법은 객체지향 분석 방법론 중 하나로, 객체의 행위를 중심으로 모델링하며, 객체의 속성과 관계를 정의하고, 객체의 역할과 책임을 명확하게 정의하여 시스템을 구성하는 방법을 강조한다.",
  "choices" : "1.Coad와 Yourdon 방법/2.Booch 방법/3.Jacobson 방법/4.Wirfs-Brocks 방법/"
}, {
  "question" : "정렬된 N개의 데이터를 처리하는데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은?",
  "answer" : "4.합병정렬",
  "commentary" : "합병정렬은 분할정복 알고리즘을 사용하여 정렬하는 알고리즘이다. 데이터를 반으로 나누어 각각을 정렬한 후, 합병하여 전체를 정렬한다. 이 때, 분할과 합병 과정에서 각각 O(Nlog2N)의 시간이 소요되므로 전체적으로 O(Nlog2N)의 시간이 소요된다. 따라서, 정렬된 N개의 데이터를 처리하는데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은 합병정렬이다.",
  "choices" : "1.선택정렬/2.삽입정렬/3.버블정렬/4.합병정렬/"
}, {
  "question" : "White Box Testing 에 대한 설명으로 옳지 않은 것은?",
  "answer" : "1.Base Path Testing, Boundary Value Analysis가 대표적인 기법이다.",
  "commentary" : "\"Source Code 의 모든 문장을 한번 이상 수행함으로서 진행된다.\"가 옳지 않은 설명입니다. White Box Testing은 Source Code의 내부 구조를 이해하고, 모듈의 작동을 직접 관찰하여 테스트하는 방법입니다. Base Path Testing과 Boundary Value Analysis는 White Box Testing의 대표적인 기법 중 일부입니다.",
  "choices" : "1.Base Path Testing, Boundary Value Analysis가 대표적인 기법이다./2.Source Code 의 모든 문장을 한번 이상 수행함으로서 진행된다./3.모듈 안의 작동을 직접 관찰 할 수 있다./4.산출물의 각 기능별로 적절한 프로그램의 제어구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다./"
}, {
  "question" : "소프트웨어 품질 측정을 위해 개발자 관점에서 고려해야 할 항목으로 거리가 먼 것은?",
  "answer" : "4.간결성",
  "commentary" : "간결성은 소프트웨어의 코드나 문서 등이 복잡하지 않고 명확하게 작성되어 있어야 하기 때문에 개발자 관점에서 고려해야 할 항목 중에서는 다른 항목들과는 거리가 먼 것이다. 다른 항목들은 소프트웨어의 기능적인 측면을 중심으로 고려하는 반면, 간결성은 소프트웨어의 가독성과 유지보수성을 고려하는 측면에서 중요하다. 따라서 개발자는 코드를 작성할 때 간결하고 명확하게 작성하는 것이 중요하다.",
  "choices" : "1.정확성/2.무결성/3.사용성/4.간결성/"
}, {
  "question" : "인터페이스 구현 검증도구 중 아래에서 설명하는 것은?",
  "answer" : "2.STAF",
  "commentary" : "이미지에서 보이는 것은 STAF (Software Testing Automation Framework)의 로고이다. 따라서 정답은 \"STAF\"이다.",
  "choices" : "1.xUnit/2.STAF/3.FitNesse/4.RubyNode/"
}, {
  "question" : "EAI(Enterprise Application Integration)의 구축 유형으로 옳지 않은 것은?",
  "answer" : "4.Tree",
  "commentary" : "EAI의 구축 유형으로 \"Tree\"는 옳지 않은 것이다. 이유는 EAI에서 Tree 구조는 사용되지 않는다. EAI에서는 Point-to-Point, Hub&Spoke, Message Bus 등의 구축 유형이 사용된다.",
  "choices" : "1.Point-to-Point/2.Hub&Spoke/3.Message Bus/4.Tree/"
}, {
  "question" : "다음 트리를 전위 순회(preorder traversal)한 결과는?",
  "answer" : "4.+**/ABCDE",
  "commentary" : null,
  "choices" : "1.+*AB/*CDE/2.AB/C*D*E+/3.A/B*C*D+E/4.+**/ABCDE/"
}, {
  "question" : "인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 솔루션과 거리가 먼 것은?",
  "answer" : "2.SMTP",
  "commentary" : "SMTP는 이메일 전송 프로토콜로, 인터페이스 보안을 위한 네트워크 영역에 적용될 수 있는 솔루션과는 거리가 먼 것입니다. SMTP는 이메일을 전송하는 데 사용되는 프로토콜이며, 이메일 보안을 위한 다른 프로토콜과는 별개로 동작합니다. 반면, IPSec, SSL, S-HTTP 등은 네트워크 통신을 암호화하고 보안을 강화하는 프로토콜로, 인터페이스 보안을 위해 적용될 수 있는 솔루션으로 자주 사용됩니다.",
  "choices" : "1.IPSec/2.SMTP/3.SSL/4.S-HTTP/"
}, {
  "question" : "평가 점수에 따른 성적부여는 다음 표와 같다. 이를 구현한 소프트웨어를 경계값 분석 기법으로 테스트 하고자 할 때 다음 중 테스트 케이스의 입력 값으로 옳지 않은 것은?",
  "answer" : "3.90",
  "commentary" : "옳지 않은 입력 값은 \"101\"이다. 이유는 평가 점수는 0부터 100까지의 범위를 가지기 때문에 101은 유효하지 않은 입력 값이다. 따라서 이 경우에는 유효하지 않은 입력 값으로 처리되어야 한다. 정답이 \"90\"인 이유는 평가 점수가 90일 때, \"A\" 학점이 부여되기 때문이다. 이는 표에서 확인할 수 있다. 따라서 입력 값이 90일 때, 소프트웨어는 \"A\" 학점을 반환해야 한다.",
  "choices" : "1.59/2.80/3.90/4.101/"
}, {
  "question" : "반정규화(Denormalization) 유형중 중복 테이블을 추가하는 방법에 해당하지 않는 것은?",
  "answer" : "1.빌드 테이블의 추가",
  "commentary" : "반정규화에서 중복 테이블을 추가하는 방법에는 \"집계 테이블의 추가\", \"진행 테이블의 추가\", \"특정 부분만을 포함하는 테이블의 추가\"가 있습니다. 하지만 \"빌드 테이블의 추가\"는 반정규화에서 사용되는 용어가 아니며, 따라서 해당하지 않는 유형입니다.",
  "choices" : "1.빌드 테이블의 추가/2.집계 테이블의 추가/3.진행 테이블의 추가/4.특정 부분만을 포함하는 테이블의 추가/"
}, {
  "question" : "ISO/IEC 9126의 소프트웨어 품질 특성 중 기능성(Functionlity)의 하위 특성으로 옳지 않은 것은?",
  "answer" : "1.학습성",
  "commentary" : "ISO/IEC 9126의 소프트웨어 품질 특성 중 기능성(Functionality)의 하위 특성으로 \"학습성(Learnability)\"은 옳지 않은 것입니다. 이는 사용자가 새로운 시스템을 배우고 이해하는 능력을 나타내는 특성으로, 사용자 친화적인 인터페이스와 적절한 도움말 등을 제공하여 사용자가 시스템을 쉽게 학습할 수 있도록 지원하는 것이 목적입니다.",
  "choices" : "1.학습성/2.적합성/3.정확성/4.보안성/"
}, {
  "question" : "다음 트리의 차수(degree)와 단말 노드(terminal node)의 수는?",
  "answer" : "2.차수: 2, 단말 노드: 4",
  "commentary" : null,
  "choices" : "1.차수: 4, 단말 노드: 4/2.차수: 2, 단말 노드: 4/3.차수: 4, 단말 노드: 8/4.차수: 2, 단말 노드: 8/"
}, {
  "question" : "디지털 저작권 관리(DRM)의 기술 요소가 아닌 것은?",
  "answer" : "4.방화벽 기술",
  "commentary" : "방화벽 기술은 네트워크 보안 기술로, 외부로부터의 침입을 막는 역할을 합니다. 따라서 디지털 저작권 관리(DRM)와는 직접적인 연관성이 없습니다. 반면, 크랙 방지 기술, 정책 관리 기술, 암호화 기술은 DRM의 핵심 기술 요소로서, 디지털 콘텐츠의 불법 복제와 유포를 방지하고, 저작권자의 권리를 보호하는 역할을 합니다.",
  "choices" : "1.크랙 방지 기술/2.정책 관리 기술/3.암호화 기술/4.방화벽 기술/"
}, {
  "question" : "소프트 웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은?",
  "answer" : "3.Pareto의 법칙",
  "commentary" : "Pareto의 법칙은 \"20%의 원인이 80%의 결과를 일으킨다\"는 원리를 기반으로 한다. 소프트웨어 테스트에서도 이 원리가 적용되어, 전체 모듈 중 일부 모듈에서 발견된 오류가 전체 오류의 80%를 차지한다는 것을 의미한다. 따라서, Pareto의 법칙이 소프트웨어 테스트에서 오류 발견 패턴을 설명하는 데 사용된다.",
  "choices" : "1.Brooks의 법칙/2.Boehm의 법칙/3.Pareto의 법칙/4.Jackson의 법칙/"
}, {
  "question" : "소프트웨어 형상 관리의 의미로 적절한 것은?",
  "answer" : "2.개발 과정의 변경 사항을 관리하는 것",
  "commentary" : "소프트웨어 형상 관리는 개발 과정에서 발생하는 변경 사항을 관리하는 것입니다. 이를 통해 개발자들은 언제든지 이전 버전으로 돌아갈 수 있고, 여러 명이 함께 작업할 때 충돌을 방지하고 협업을 원활하게 할 수 있습니다. 따라서 \"개발 과정의 변경 사항을 관리하는 것\"이 적절한 답입니다.",
  "choices" : "1.비용에 관한 사항을 효율적으로 관리하는 것/2.개발 과정의 변경 사항을 관리하는 것/3.테스트 과정에서 소프트웨어를 통합하는 것/4.개발 인력을 관리하는 것/"
}, {
  "question" : "알고리즘 시간복잡도 O(1)이 의미하는 것은?",
  "answer" : "3.알고리즘 수행시간이 입력 데이터 수와 관계없이 일정",
  "commentary" : "알고리즘 시간복잡도 O(1)이 의미하는 것은 입력 데이터의 크기와 상관없이 알고리즘의 수행시간이 일정하다는 것입니다. 이는 알고리즘이 입력 데이터의 크기에 따라 처리하는 작업이 없거나, 입력 데이터의 크기와 상관없이 일정한 작업만 수행하는 경우에 해당됩니다. 따라서 \"알고리즘 수행시간이 입력 데이터 수와 관계없이 일정\"인 이유는 입력 데이터의 크기에 따라 처리하는 작업이 없거나, 일정한 작업만 수행하기 때문입니다.",
  "choices" : "1.컴퓨터 처리가 불가/2.알고리즘 입력 데이터 수가 한 개/3.알고리즘 수행시간이 입력 데이터 수와 관계없이 일정/4.알고리즘 길이가 입력 데이터보다 작음/"
}, {
  "question" : "소스코드 품질분석 도구 중 정적분석 도구가 아닌 것은?",
  "answer" : "3.valMeter",
  "commentary" : "정적분석 도구는 소스코드를 실행하지 않고 분석하여 오류나 버그를 찾는 도구이다. \"pmd\", \"cppcheck\", \"checkstyle\"은 모두 정적분석 도구이다. 하지만 \"valMeter\"는 동적분석 도구로, 소스코드를 실행하면서 메모리 누수나 성능 이슈 등을 찾는 도구이다. 따라서 \"valMeter\"는 정적분석 도구가 아니다.",
  "choices" : "1.pmd/2.cppcheck/3.valMeter/4.checkstyle/"
}, {
  "question" : "검증 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행하는 기법이며, 일반적으로 통제된 환경에서 사용자와 개발자가 함께 확인하면서 수행되는 검사는?",
  "answer" : "3.알파 검사",
  "commentary" : "알파 검사는 개발자와 사용자가 함께 통제된 환경에서 소프트웨어를 확인하면서 수행되는 검사 기법이기 때문입니다. 이는 개발 초기 단계에서 오류를 발견하고 수정할 수 있도록 도와주며, 사용자의 요구사항을 충족시키는지 확인할 수 있습니다. 따라서 알파 검사는 소프트웨어 품질을 향상시키는 데 중요한 역할을 합니다.",
  "choices" : "1.동치 분할 검사/2.형상 검사/3.알파 검사/4.베타 검사/"
}, {
  "question" : "하향식 통합에 있어서 모듈 간의 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈을 무엇이라고 하는가?",
  "answer" : "1.Stub",
  "commentary" : "Stub은 하향식 통합에서 모듈 간의 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈을 말한다. 이는 실제 모듈의 기능을 대신하여 호출되어 테스트를 수행하며, 특정한 값을 반환하거나 예외를 발생시키는 등의 동작을 수행한다. 따라서 Stub은 통합 테스트를 위해 필요한 모듈의 일부분을 대체하여 테스트를 수행할 수 있도록 도와주는 역할을 한다.",
  "choices" : "1.Stub/2.Driver/3.Procedure/4.Function/"
}, {
  "question" : "SW 패키징 도구 활용 시 고려 사항과 거리가 먼 것은?",
  "answer" : "3.보안상 단일 기종에서만 사용할 수 있도록 해야 한다.",
  "commentary" : "패키징 도구를 사용하여 만든 SW가 보안상 취약점을 가지고 있을 경우, 다양한 기종에서 사용될 경우 보안 위협이 발생할 가능성이 높아진다. 따라서 보안상 단일 기종에서만 사용할 수 있도록 제한하는 것이 중요하다. 이를 통해 보안성을 높일 수 있으며, 보안 위협에 대한 대응도 더욱 효과적으로 이루어질 수 있다.",
  "choices" : "1.패키징 시 사용자에게 배포되는 SW이므로 보안을 고려한다./2.사용자 편의성을 위한 복합성 및 비효율성 문제를 고려한다./3.보안상 단일 기종에서만 사용할 수 있도록 해야 한다./4.제품 SW 종류에 적합한 암호화 알고리즘을 적용한다./"
}, {
  "question" : "외계인코드(Alien Code)에 대한 설명으로 옳은 것은?",
  "answer" : "2.아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다.",
  "commentary" : "외계인코드는 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다. 즉, 이해하기 어렵거나 수정하기 어려운 코드를 의미한다.",
  "choices" : "1.프로그램의 로직이 복잡하여 이해하기 어려운 프로그램을 의미한다./2.아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다./3.오류가 없어 디버깅 과정이 필요 없는 프로그램을 의미한다./4.사용자가 직접 작성한 프로그램을 의미한다./"
}, {
  "question" : "SQL 의 분류 중 DDL에 해당하지 않는 것은?",
  "answer" : "1.UPDATE",
  "commentary" : "DDL(Data Definition Language)은 데이터베이스의 구조를 정의하거나 조작하는 언어로, CREATE, ALTER, DROP과 같은 명령어가 포함됩니다. UPDATE는 데이터베이스의 구조를 변경하지 않고, 기존 데이터를 수정하는 명령어이므로 DDL에 해당하지 않습니다.",
  "choices" : "1.UPDATE/2.ALTER/3.DROP/4.CREATE/"
}, {
  "question" : "다음 두 릴레이션에서 외래키로 사용된 것은? (단 밑줄 친 속성은 기본키이다.)",
  "answer" : "2.과목번호",
  "commentary" : "외래키로 사용된 속성은 \"과목번호\"이다. 이는 \"수강\" 릴레이션에서 \"과목\" 릴레이션을 참조하기 위한 외래키이다. \"과목번호\"는 \"과목\" 릴레이션의 기본키이기 때문에 이를 참조하여 \"수강\" 릴레이션에서 해당 과목을 식별할 수 있다.",
  "choices" : "1.수강번호/2.과목번호/3.학번/4.과목명/"
}, {
  "question" : "데이터 무결성 제약조건 중 “개체 무결성 제약”조건에 대한 설명으로 맞는 것은?",
  "answer" : "2.기본키에 속해 있는 애트리뷰트는 널값이나 중복값을 가질 수 없다.",
  "commentary" : "기본키는 릴레이션 내에서 각 튜플을 유일하게 식별하는 속성이므로, 중복값이나 널값을 가질 수 없다. 이는 데이터의 일관성과 무결성을 보장하기 위한 제약조건이다.",
  "choices" : "1.릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다./2.기본키에 속해 있는 애트리뷰트는 널값이나 중복값을 가질 수 없다./3.릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다./4.외래키 값은 참조 릴레이션의 기본키 값과 동일해야 한다./"
}, {
  "question" : "뷰(view)에 대한 설명으로 옳지 않은 것은?",
  "answer" : "4.뷰는 저장장치 내에 물리적으로 존재한다.",
  "commentary" : "뷰는 저장장치 내에 물리적으로 존재하지 않는다. 뷰는 데이터베이스에서 쿼리를 실행할 때마다 해당 쿼리에 대한 결과를 가상으로 생성하여 제공하는 가상 테이블이다. 따라서 뷰는 실제 데이터를 저장하고 있지 않으며, 저장장치 내에 물리적으로 존재하지 않는다.",
  "choices" : "1.뷰는 CREATE 문을 사용하여 정의한다./2.뷰는 데이터의 논리적 독립성을 제공한다./3.뷰를 제거할 때에는 DROP 문을 사용한다./4.뷰는 저장장치 내에 물리적으로 존재한다./"
}, {
  "question" : "다음 SQL 문의 실행 결과는?",
  "answer" : "4.25,000",
  "commentary" : "SELECT SUM(salary) FROM employee WHERE department = 'IT' IT 부서에 속한 직원들의 급여 합계를 구하는 쿼리이다. employee 테이블에서 department가 'IT'인 행들의 salary 값을 모두 더한 결과가 출력된다. 따라서 IT 부서에 속한 직원들의 급여 총합은 25,000이다.",
  "choices" : "1.10,000/2.15,000/3.20,000/4.25,000/"
}, {
  "question" : "데이터베이스의 논리적 설계(logical design) 단계에서 수행하는 작업이 아닌 것은?",
  "answer" : "1.레코드 집중의 분석 및 설계",
  "commentary" : "논리적 데이터베이스 구조로 매핑(mapping), 트랜잭션 인터페이스 설계, 스키마의 평가 및 정제는 데이터베이스의 논리적 설계 단계에서 수행하는 작업이지만, \"레코드 집중의 분석 및 설계\"는 데이터베이스의 물리적 설계 단계에서 수행하는 작업이기 때문에 정답이다. 레코드 집중의 분석 및 설계는 물리적인 저장장치에 데이터를 저장하는 방식을 결정하는 작업으로, 논리적인 데이터 모델링과는 관련이 없다.",
  "choices" : "1.레코드 집중의 분석 및 설계/2.논리적 데이터베이스 구조로 매핑(mapping)/3.트랜잭션 인터페이스 설계/4.스키마의 평가 및 정제/"
}, {
  "question" : "이행적 함수 종속 관계를 의미하는 것은?",
  "answer" : "1.A→B이고 B→C 일 때, A→C를 만족하는 관계",
  "commentary" : "이행적 함수 종속 관계란 A→B이고 B→C일 때, A→C를 만족하는 관계를 의미합니다. 이는 A가 B에 함수적으로 종속되고, B가 C에 함수적으로 종속되어 있으므로, A는 C에도 함수적으로 종속되는 것을 의미합니다. 따라서 A→C를 만족하는 것입니다.",
  "choices" : "1.A→B이고 B→C 일 때, A→C를 만족하는 관계/2.A→B이고 B→C 일 때, C→A를 만족하는 관계/3.A→B이고 B→C 일 때, B→A를 만족하는 관계/4.A→B이고 B→C 일 때, C→B를 만족하는 관계/"
}, {
  "question" : "하나의 애트리뷰트가 가질 수 있는 원자값들의 집합을 의미하는 것은?",
  "answer" : "1.도메인",
  "commentary" : "도메인은 하나의 애트리뷰트가 가질 수 있는 값들의 범위를 의미합니다. 즉, 해당 애트리뷰트가 가질 수 있는 모든 가능한 값들의 집합을 말합니다. 이에 반해 튜플은 릴레이션에서 하나의 행을 의미하고, 엔티티는 현실 세계에서 개체를 나타내는 개념입니다. 다형성은 객체지향 프로그래밍에서 하나의 클래스가 여러 가지 형태로 구현될 수 있는 능력을 의미합니다.",
  "choices" : "1.도메인/2.튜플/3.엔티티/4.다형성/"
}, {
  "question" : "STUDENT 테이블에 독일어과 학생 50명, 중국어과 학생 30명, 영어영문학과 학생 50명의 정보가 저장되어 있을 때, 다음 두 SQL문의 실행 결과 튜플 수는? (단, DEPT 컬럼은 학과명)",
  "answer" : "3.ⓐ 130, ⓑ 3",
  "commentary" : null,
  "choices" : "1.ⓐ 3, ⓑ 3/2.ⓐ 50, ⓑ 3/3.ⓐ 130, ⓑ 3/4.ⓐ 130, ⓑ 130/"
}, {
  "question" : "관계대수 연산에서 두 릴레이션이 공통으로 가지고 있는 속성을 이용하여 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산은?",
  "answer" : "1.",
  "commentary" : "관계대수 연산 중 \"교집합(intersection)\" 연산을 이용하여 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만들 수 있습니다. 이 연산은 두 릴레이션에서 공통으로 가지고 있는 속성만을 선택하여 새로운 릴레이션을 만들기 때문입니다. 따라서 정답은 \"\" 입니다.",
  "choices" : "1./2./3./4./"
}, {
  "question" : "트랜잭션의 특성 중 다음 설명에 해당하는 것은?",
  "answer" : "4.Atomicity",
  "commentary" : null,
  "choices" : "1.Durability/2.Share/3.Consistency/4.Atomicity/"
}, {
  "question" : "분산 데이터베이스 목표 중 “데이터베이스의 분산된 물리적 환경에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다”는 것과 관계있는 것은?",
  "answer" : "1.장애 투명성",
  "commentary" : "\"장애 투명성\"은 분산 데이터베이스에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장되는 목표와 관련이 있습니다. 이는 분산 데이터베이스 시스템이 장애가 발생한 지역을 자동으로 감지하고, 다른 지역의 노드들이 해당 지역의 역할을 대신 수행하여 데이터 무결성을 유지하는 것을 의미합니다. 따라서 \"장애 투명성\"은 분산 데이터베이스 시스템의 안정성과 신뢰성을 보장하는 중요한 요소 중 하나입니다.",
  "choices" : "1.장애 투명성/2.병행 투명성/3.위치 투명성/4.중복 투명성/"
}, {
  "question" : "데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL은?",
  "answer" : "1.트리거(trigger)",
  "commentary" : "트리거는 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 자동으로 실행되는 절차형 SQL이다. 따라서 데이터베이스의 무결성을 유지하고, 잠금과 복귀 등의 작업을 수행할 수 있다.",
  "choices" : "1.트리거(trigger)/2.무결성(integrity)/3.잠금(lock)/4.복귀(rollback)/"
}, {
  "question" : "참조 무결성을 유지하기 위하여 DROP문에서 부모 테이블의 항목 값을 삭제할 경우 자동적으로 자식 테이블의 해당 레코드를 삭제하기 위한 옵션은?",
  "answer" : "2.CASCADE",
  "commentary" : "CASCADE 옵션은 부모 테이블에서 레코드를 삭제할 때 자식 테이블에서 해당 레코드를 자동으로 삭제하는 옵션이다. 이를 통해 참조 무결성을 유지할 수 있다. 따라서 이 문제에서는 CASCADE가 정답이다.",
  "choices" : "1.CLUSTER/2.CASCADE/3.SET-NULL/4.RESTRICTED/"
}, {
  "question" : "DML에 해당하는 SQL 명령으로만 나열된 것은?",
  "answer" : "3.SELECT, INSERT, DELETE, UPDATE",
  "commentary" : "DML(Data Manipulation Language)은 데이터를 조작하는 SQL 명령어를 의미합니다. 따라서 DML에 해당하는 SQL 명령어로는 SELECT, INSERT, DELETE, UPDATE가 포함됩니다. 다른 보기들은 DDL(Data Definition Language)이나 DCL(Data Control Language)에 해당하는 SQL 명령어들이 포함되어 있습니다.",
  "choices" : "1.DELETE, UPDATE, CREATE, ALTER/2.INSERT, DELETE, UPDATE, DROP/3.SELECT, INSERT, DELETE, UPDATE/4.SELECT, INSERT, DELETE, ALTER/"
}, {
  "question" : "데이터 제어언어(DCL)의 기능으로 옳지 않은 것은?",
  "answer" : "2.논리적, 물리적 데이터 구조 정의",
  "commentary" : "DCL은 데이터 보안, 무결성 유지, 병행수행 제어와 같은 기능을 제공하지만, 논리적, 물리적 데이터 구조를 정의하는 것은 데이터 정의 언어(DDL)의 역할이다. 따라서 \"논리적, 물리적 데이터 구조 정의\"가 옳지 않은 것이다.",
  "choices" : "1.데이터 보안/2.논리적, 물리적 데이터 구조 정의/3.무결성 유지/4.병행수행 제어/"
}, {
  "question" : "병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?",
  "answer" : "2.로킹 단위가 작아지면 로킹 오버헤드가 감소한다.",
  "commentary" : "\"로킹 단위가 작아지면 데이터베이스 공유도가 증가한다.\"는 옳지 않은 설명입니다. 로킹 단위가 작아지면 로킹 오버헤드가 감소하는 이유는, 작은 단위로 로킹을 하면 다른 스레드나 프로세스가 해당 자원을 접근할 때 대기 시간이 줄어들기 때문입니다. 따라서 로킹 단위가 작아질수록 동시에 접근 가능한 자원의 수가 늘어나므로 데이터베이스 공유도가 증가한다는 설명은 옳지 않습니다. 한꺼번에 로킹 할 수 있는 객체의 크기를 로킹 단위라고 하는 것은 맞지만, 로킹 단위가 작아질수록 로킹할 수 있는 객체의 수가 늘어나므로 이는 로킹 오버헤드 감소와 관련이 있습니다.",
  "choices" : "1.데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다./2.로킹 단위가 작아지면 로킹 오버헤드가 감소한다./3.로킹 단위가 작아지면 데이터베이스 공유도가 증가한다./4.한꺼번에 로킹 할 수 있는 객체의 크기를 로킹 단위라고 한다./"
}, {
  "question" : "E-R 모델의 표현 방법으로 옳지 않은 것은?",
  "answer" : "3.속성: 오각형",
  "commentary" : "E-R 모델에서 속성은 원형으로 표현됩니다. 따라서 \"속성: 오각형\"은 옳지 않은 표현입니다.",
  "choices" : "1.개체타입: 사각형/2.관계타입: 마름모/3.속성: 오각형/4.연결: 선/"
}, {
  "question" : "다음 설명의 ( )안에 들어갈 내용으로 적합한 것은?",
  "answer" : "2.최소성",
  "commentary" : "보기에서 중복된 속성을 제거하여 최소한의 속성만으로 테이블을 구성하고자 하기 때문에 정답은 \"최소성\"이다.",
  "choices" : "1.중복성/2.최소성/3.참조성/4.동일성/"
}, {
  "question" : "정규화 과정 중 1NF에서 2NF가 되기 위한 조건은?",
  "answer" : "4.1NF를 만족하고 키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속 관계를 만족해야 한다.",
  "commentary" : "정규화 과정 중 1NF에서 2NF가 되기 위한 조건은 \"1NF를 만족하고 키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속 관계를 만족해야 한다.\" 이다. 이유는 2NF는 기본키에 대해 부분적으로 종속되는 속성을 제거하기 위한 것이기 때문이다. 따라서 키가 아닌 속성이 기본키의 일부에만 종속되는 경우, 이를 분리하여 별도의 테이블로 만들어야 한다. 이를 위해 키가 아닌 속성이 기본키 전체에 대해 완전 함수적 종속 관계를 가져야 한다.",
  "choices" : "1.1NF를 만족하는 모든 도메인이 원자 값이어야 한다./2.1NF를 만족하고 키가 아닌 모든 애트리뷰트들이 기본 키에 이행적으로 함수 종속되지 않아야 한다./3.1NF를 만족하고 다치 종속이 제거되어야 한다./4.1NF를 만족하고 키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속 관계를 만족해야 한다./"
}, {
  "question" : "IPv6에 대한 설명으로 틀린 것은?",
  "answer" : "3.패킷 크기가 64Kbyte로 고정되어 있다.",
  "commentary" : "IPv6에 대한 설명 중 패킷 크기가 64Kbyte로 고정되어 있다는 것은 틀린 설명입니다. IPv6에서는 패킷 크기가 최대 65,535바이트까지 가능하며, 이는 IPv4에서의 1,500바이트보다 큰 크기입니다. 따라서 IPv6에서는 더 많은 데이터를 한 번에 전송할 수 있습니다.",
  "choices" : "1.128비트의 주소 공간을 제공한다./2.인증 및 보안 기능을 포함하고 있다./3.패킷 크기가 64Kbyte로 고정되어 있다./4.IPv6 확장 헤더를 통해 네트워크 기능 확장이 용이하다./"
}, {
  "question" : "C언어에서 비트 논리연산자에 해당하지 않는 것은?",
  "answer" : "2.?",
  "commentary" : "정답은 \"?\"입니다. 이유는 C언어에서는 \"?\" 연산자가 삼항 연산자로 사용되며, 비트 논리연산자가 아니기 때문입니다. \"^\", \"&\", \"~\" 연산자는 비트 논리연산자로 사용됩니다.",
  "choices" : "1.^/2.?/3.&/4.~/"
}, {
  "question" : "TCP/IP 프로토콜 중 전송계층 프로토콜은?",
  "answer" : "4.TCP",
  "commentary" : "전송계층 프로토콜은 데이터를 안정적으로 전송하기 위한 프로토콜이며, TCP는 전송 제어 프로토콜로써 데이터의 신뢰성을 보장하고 오류가 발생하면 재전송을 수행합니다. 따라서 TCP가 전송계층 프로토콜 중 하나입니다.",
  "choices" : "1.HTTP/2.SMTP/3.FTP/4.TCP/"
}, {
  "question" : "시스템에서 모듈 사이의 결합도(Coupling)에 대한 설명으로 옳은 것은?",
  "answer" : "3.모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다.",
  "commentary" : "모듈 사이의 결합도란 모듈 간의 상호작용 정도를 나타내며, 결합도가 높을수록 모듈 간의 의존성이 높아지고, 유지보수 및 시스템 구현이 어려워진다. 따라서 모듈간의 결합도를 약하게 하면 모듈 독립성이 향상되어 유지보수 및 시스템 구현이 용이해진다.",
  "choices" : "1.한 모듈 내에 있는 처리요소들 사이의 기능적인 연관 정도를 나타낸다./2.결합도가 높으면 시스템 구현 및 유지보수 작업이 쉽다./3.모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다./4.자료결합도는 내용결합도 보다 결합도가 높다./"
}, {
  "question" : "은행가 알고리즘(Banker's Algorithm)은 교착상태의 해결 방법 중 어떤 기법에 해당하는가?",
  "answer" : "1.Avoidance",
  "commentary" : "은행가 알고리즘은 교착상태를 예방하는 방법으로 분류되어 \"Avoidance\"에 해당한다. 이 알고리즘은 프로세스가 자원을 요청할 때 시스템이 안정적인 상태를 유지할 수 있는지 미리 검사하여, 안정적인 상태를 유지할 수 없다면 해당 자원을 할당하지 않는 방식으로 교착상태를 예방한다.",
  "choices" : "1.Avoidance/2.Detection/3.Prevention/4.Recovery/"
}, {
  "question" : "UNIX의 쉘(Shell)에 관한 설명으로 옳지 않은 것은?",
  "answer" : "4.프로세스, 기억장치, 입출력 관리를 수행한다.",
  "commentary" : "\"프로세스, 기억장치, 입출력 관리를 수행한다.\"는 옳지 않은 설명이다. 쉘은 명령어 해석기이며, 시스템과 사용자 간의 인터페이스를 담당한다. 또한 여러 종류의 쉘이 존재한다. 하지만 쉘은 프로세스, 기억장치, 입출력 관리를 수행하지 않는다. 이러한 역할은 운영체제의 커널이 수행한다.",
  "choices" : "1.명령어 해석기이다./2.시스템과 사용자 간의 인터페이스를 담당한다./3.여러 종류의 쉘이 있다./4.프로세스, 기억장치, 입출력 관리를 수행한다./"
}, {
  "question" : "교착 상태 발생의 필요 충분 조건이 아닌 것은?",
  "answer" : "4.선점(preemption)",
  "commentary" : "선점(preemption)은 교착 상태 발생의 필요 충분 조건이 아니기 때문에 정답이다. 교착 상태 발생의 필요 충분 조건은 상호 배제, 점유와 대기, 환형 대기 세 가지이다. 선점은 프로세스가 다른 프로세스의 자원을 강제로 빼앗아 사용할 수 있는 기능을 말한다. 이러한 선점 기능이 있으면 교착 상태가 발생하지 않을 수 있지만, 선점 기능이 없는 시스템에서도 교착 상태가 발생할 수 있기 때문에 교착 상태 발생의 필요 충분 조건이 아니다.",
  "choices" : "1.상호 배제(mutual exclusion)/2.점유와 대기(hold and wait)/3.환형 대기(circular wait)/4.선점(preemption)/"
}, {
  "question" : "OSI-7계층에서 종단간 신뢰성 있고 효율적인 데이터를 전송하기 위해 오류검출과 복구, 흐름 제어를 수행하는 계층은?",
  "answer" : "1.전송 계층",
  "commentary" : "전송 계층은 종단간 신뢰성 있고 효율적인 데이터를 전송하기 위해 오류검출과 복구, 흐름 제어를 수행하는 계층입니다. 이 계층은 데이터를 세그먼트로 분할하고, 각 세그먼트에 일련번호를 부여하여 전송 중에 발생할 수 있는 오류를 검출하고 복구합니다. 또한, 흐름 제어를 통해 송신 측과 수신 측의 데이터 처리 속도 차이를 조절하여 데이터 전송의 효율성을 높입니다. 따라서, 전송 계층은 OSI-7계층에서 종단간 신뢰성 있고 효율적인 데이터 전송을 위해 필수적인 계층입니다.",
  "choices" : "1.전송 계층/2.세션 계층/3.표현 계층/4.응용 계층/"
}, {
  "question" : "IPv6의 주소체계로 거리가 먼 것은?",
  "answer" : "3.Broadcast",
  "commentary" : "IPv6에서 \"Broadcast\"는 모든 호스트에게 패킷을 전송하는 주소체계이며, 다른 주소체계들은 특정 호스트나 그룹에게 패킷을 전송하는 것이다. 따라서, Broadcast는 다른 주소체계들과 달리 거리가 먼 것이다.",
  "choices" : "1.Unicast/2.Anycast/3.Broadcast/4.Multicast/"
}, {
  "question" : "TCP/IP 네트워크에서 IP 주소를 MAC 주소로 변환하는 프로토콜은?",
  "answer" : "2.ARP",
  "commentary" : "ARP는 TCP/IP 네트워크에서 IP 주소를 MAC 주소로 변환하는 프로토콜입니다. ARP는 IP 주소를 가진 호스트가 네트워크 상에서 특정 MAC 주소를 가진 호스트와 통신할 때 사용됩니다. ARP는 IP 패킷을 전송하기 전에 해당 IP 주소에 대한 MAC 주소를 찾아내는 역할을 합니다.",
  "choices" : "1.UDP/2.ARP/3.TCP/4.ICMP/"
}, {
  "question" : "프로세스 상태의 종류가 아닌 것은?",
  "answer" : "3.Request",
  "commentary" : "\"Request\"는 프로세스 상태의 종류가 아닙니다. \"Ready\"는 실행 준비가 된 상태, \"Running\"은 현재 실행 중인 상태, \"Exit\"는 실행이 종료된 상태를 나타내는 반면, \"Request\"는 프로세스 상태를 나타내는 용어가 아닙니다. 따라서, \"Request\"가 정답입니다.",
  "choices" : "1.Ready/2.Running/3.Request/4.Exit/"
}, {
  "question" : "스레드(Thread)에 대한 설명으로 옳지 않은 것은?",
  "answer" : "1.한 개의 프로세스는 여러 개의 스레드를 가질 수 없다.",
  "commentary" : "\"한 개의 프로세스는 여러 개의 스레드를 가질 수 없다.\"가 옳지 않은 설명이다. 한 개의 프로세스는 여러 개의 스레드를 가질 수 있다. 이는 멀티스레딩(multithreading)이 가능하기 때문이다. 멀티스레딩은 하나의 프로세스 내에서 여러 개의 스레드가 동시에 실행되는 것을 말한다. 이를 통해 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.",
  "choices" : "1.한 개의 프로세스는 여러 개의 스레드를 가질 수 없다./2.커널 스레드의 경우 운영체제에 의해 스레드를 운용한다./3.사용자 스레드의 경우 사용자가 만든 라이브러리를 사용하여 스레드를 운용한다./4.스레드를 사용함으로써 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다./"
}, {
  "question" : "HRN(Highest Response-ratio Next) 스케줄링 방식에 대한 설명으로 옳지 않은 것은?",
  "answer" : "4.우선 순위를 계산하여 그 수치가 가장 낮은 것부터 높은 순으로 우선 순위가 부여된다.",
  "commentary" : null,
  "choices" : "1.대기 시간이 긴 프로세스의 경우 우선 순위가 높아진다./2.SJF 기법을 보완하기 위한 방식이다./3.긴 작업과 짧은 작업 간의 지나친 불평등을 해소할 수 있다./4.우선 순위를 계산하여 그 수치가 가장 낮은 것부터 높은 순으로 우선 순위가 부여된다./"
}, {
  "question" : "IEEE 802.11 워킹 그룹의 무선 LAN 표준화 현황 중 QoS 강화를 위해 MAC 지원 가능을 채택한 것은?",
  "answer" : "4.802.11e",
  "commentary" : "802.11e는 QoS (Quality of Service)를 강화하기 위해 MAC (Media Access Control)에서 지원 가능한 기능을 채택한 무선 LAN 표준이다. 이전의 802.11a, 802.11b, 802.11g는 QoS를 보장하지 않았으며, 802.11e는 높은 우선순위의 데이터에 대한 전송을 보장하기 위해 EDCA (Enhanced Distributed Channel Access)를 도입하였다. 이를 통해 무선 네트워크에서 음성, 영상 등의 실시간 데이터 전송에 대한 QoS를 보장할 수 있게 되었다.",
  "choices" : "1.802.11a/2.802.11b/3.802.11g/4.802.11e/"
}, {
  "question" : "C언어에서 사용할 수 없는 변수명은?",
  "answer" : "2.text-color",
  "commentary" : "\"C언어에서는 변수명에 '-' 기호를 사용할 수 없기 때문에 'text-color'는 사용할 수 없는 변수명이다.\"",
  "choices" : "1.student2019/2.text-color/3._korea/4.amount/"
}, {
  "question" : "스크립트 언어가 아닌 것은?",
  "answer" : "2.Cobol",
  "commentary" : "Cobol은 스크립트 언어가 아닌 프로그래밍 언어이다. 스크립트 언어는 코드를 한 줄씩 실행하며 인터프리터가 코드를 해석하고 실행하는 반면, Cobol은 컴파일러를 사용하여 코드를 기계어로 번역하고 실행한다. 따라서 Cobol은 스크립트 언어가 아니다.",
  "choices" : "1.PHP/2.Cobol/3.Basic/4.Python/"
}, {
  "question" : "다음의 페이지 참조 열(Page reference string)에 대해 페이지 교체 기법으로 선입선출 알고리즘을 사용할 경우 페이지 부재(Page Fault) 횟수는? (단, 할당된 페이지 프레임 수는 3이고, 처음에는 모든 프레임이 비어 있다.)",
  "answer" : "2.14",
  "commentary" : "선입선출 알고리즘은 가장 먼저 들어온 페이지를 먼저 교체하는 방식이다. 따라서 페이지 참조열에서 처음에는 모든 프레임이 비어 있으므로, 3개의 페이지가 차례로 할당된다. 이후에는 4번째 페이지부터 페이지 부재가 발생하게 되는데, 이때 가장 먼저 할당된 페이지인 1번 페이지가 교체되고, 4번 페이지가 새로 할당된다. 이후에도 마찬가지로 2번 페이지가 교체되고, 5번 페이지가 새로 할당된다. 마지막으로 3번 페이지가 교체되고, 6번 페이지가 새로 할당된다. 따라서 페이지 부재 횟수는 14번이 된다.",
  "choices" : "1.13/2.14/3.15/4.20/"
}, {
  "question" : "C언어에서 배열 b[5]의 값은?",
  "answer" : "1.0",
  "commentary" : "배열 b[5]는 5개의 요소를 가지고 있으며, 초기화되지 않았기 때문에 모든 요소의 값은 0으로 설정됩니다. 따라서 b[5]의 값은 0입니다.",
  "choices" : "1.0/2.1/3.2/4.3/"
}, {
  "question" : "응집도가 가장 낮은 것은?",
  "answer" : "4.우연적 응집도",
  "commentary" : "우연적 응집도는 모듈 내부의 요소들이 서로 관련성이 없이 무작위로 모여있는 경우를 말한다. 즉, 모듈 내부의 요소들이 서로 연관성이 없이 무작위로 모여있어서 모듈의 기능을 수행하는 데에 아무런 도움이 되지 않는 경우이다. 따라서 응집도가 가장 낮은 것은 우연적 응집도이다.",
  "choices" : "1.기능적 응집도/2.시간적 응집도/3.절차적 응집도/4.우연적 응집도/"
}, {
  "question" : "JAVA 언어에서 접근제한자가 아닌 것은?",
  "answer" : "3.package",
  "commentary" : "\"package\"는 JAVA 언어에서 접근제한자가 아닙니다. 이는 접근제한자 중 하나가 아니며, 클래스, 인터페이스, 변수, 메소드 등의 접근 범위를 지정하는 데 사용되는 키워드가 아닙니다. \"package\"는 패키지를 지정하는 데 사용되는 키워드입니다. 패키지는 클래스, 인터페이스, 변수, 메소드 등을 그룹화하는 데 사용되며, 패키지 내의 모든 요소는 기본적으로 같은 패키지에 속합니다. 따라서 \"package\"는 접근제한자가 아닌 패키지를 지정하는 키워드입니다.",
  "choices" : "1.public/2.protected/3.package/4.private/"
}, {
  "question" : "Rayleigh-Norden 곡선의 노력 분포도를 이용한 프로젝트 비용 산정기법은?",
  "answer" : "1.Putnam 모형",
  "commentary" : "Rayleigh-Norden 곡선의 노력 분포도를 이용한 프로젝트 비용 산정기법은 Putnam 모형이다. 이 모형은 프로젝트의 크기와 개발에 필요한 인력 수 사이의 관계를 나타내는 곡선을 사용하여 프로젝트 비용을 산정한다. Putnam 모형은 프로젝트의 규모와 인력 수를 고려하여 비용을 산정하기 때문에 다른 모형들보다 더 정확한 비용 산정이 가능하다.",
  "choices" : "1.Putnam 모형/2.델파이 모형/3.COCOMO 모형/4.기능점수 모형/"
}, {
  "question" : "메모리상에서 프로그램의 복귀 주소와 변수사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은?",
  "answer" : "4.스택가드",
  "commentary" : "스택가드는 메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술이다. 이를 통해 스택 오버플로우 공격을 방지할 수 있다. 따라서 정답은 \"스택가드\"이다.",
  "choices" : "1.모드체크/2.리커버리 통제/3.시스로그/4.스택가드/"
}, {
  "question" : "백도어 탐지 방법으로 틀린 것은?",
  "answer" : "2.닫힌 포트 확인",
  "commentary" : "닫힌 포트 확인은 백도어 탐지 방법이 아닙니다. 백도어는 이미 열려있는 포트를 이용하여 접근하거나, 악성코드를 통해 새로운 포트를 열어서 접근합니다. 따라서 닫힌 포트 확인은 백도어 탐지에 큰 도움이 되지 않습니다.",
  "choices" : "1.무결성 검사/2.닫힌 포트 확인/3.로그 분석/4.SetUID 파일 검사/"
}, {
  "question" : "IP 또는 ICMP의 특성을 악용하여 특정 사이트에 집중적으로 데이터를 보내 네트워크 또는 시스템의 상태를 불능으로 만드는 공격 방법은?",
  "answer" : "4.Smurfing",
  "commentary" : "Smurfing은 IP나 ICMP의 특성을 악용하여 공격 대상의 IP 주소를 송신지로 위장하여 대량의 ICMP Echo Request를 네트워크 상의 브로드캐스트 주소로 보내 네트워크나 시스템을 불능 상태로 만드는 공격 방법이다. 따라서 정답은 \"Smurfing\"이다. TearDrop은 IP 패킷을 조작하여 시스템을 다운시키는 공격 방법이고, Smishing과 Qshing은 모바일 기기를 대상으로 하는 사기성 문자 메시지 공격 방법이다.",
  "choices" : "1.TearDrop/2.Smishing/3.Qshing/4.Smurfing/"
}, {
  "question" : "CMM(Capability Maturity Model) 모델의 레벨로 옳지 않은 것은?",
  "answer" : "4.계획단계",
  "commentary" : "CMM 모델의 레벨로 옳지 않은 것은 \"계획단계\"입니다. CMM 모델은 소프트웨어 개발 프로세스의 성숙도를 5단계로 나누어 평가하는 모델로, \"정의단계\", \"관리단계\", \"정량화단계\", \"최적화단계\", \"지속적 개선 단계\"로 구성됩니다. \"계획단계\"는 CMM 모델에 포함되어 있지 않습니다.",
  "choices" : "1.최적단계/2.관리단계/3.정의단계/4.계획단계/"
}, {
  "question" : "웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성·값의 쌍 형태로 표현하는 형식으로 자바스크립트(JavaScript)를 토대로 개발되어진 형식은?",
  "answer" : "3.JSON",
  "commentary" : "JSON은 JavaScript Object Notation의 약자로, 자바스크립트 객체를 기반으로한 데이터 교환 형식이다. 속성과 값의 쌍으로 이루어져 있으며, 가벼우면서도 다양한 프로그래밍 언어에서 쉽게 사용할 수 있어서 웹과 컴퓨터 프로그램에서 많이 사용된다. 따라서 정답은 JSON이다.",
  "choices" : "1.Python/2.XML/3.JSON/4.WEB SEVER/"
}, {
  "question" : "크래커가 침입하여 백도어를 만들어 놓거나, 설정 파일을 변경했을 때 분석하는 도구는?",
  "answer" : "2.tripwire",
  "commentary" : "tripwire는 시스템의 파일 및 디렉토리의 변경사항을 모니터링하고, 무단 변경이 감지되면 해당 변경사항을 보고하는 보안 도구이다. 따라서 크래커가 백도어를 만들거나 설정 파일을 변경했을 때, tripwire는 해당 변경사항을 감지하고 보고할 수 있다.",
  "choices" : "1.trace/2.tripwire/3.udpdump/4.cron/"
}, {
  "question" : "소프트웨어 개발 프레임워크를 적용할 경우 기대효과로 거리가 먼 것은?",
  "answer" : "2.시스템 복잡도 증가",
  "commentary" : "소프트웨어 개발 프레임워크를 적용하면 개발 과정에서 일관성 있는 방법으로 작업을 수행할 수 있고, 품질보증과 변경 용이성이 향상됩니다. 그러나 이에 따라 시스템의 복잡도가 증가할 수 있습니다. 이는 프레임워크가 제공하는 다양한 기능과 규칙을 따르기 위해 추가적인 코드와 설정이 필요하기 때문입니다. 따라서 시스템의 구조가 더 복잡해지고 유지보수가 어려워질 수 있습니다.",
  "choices" : "1.품질보증/2.시스템 복잡도 증가/3.개발 용이성/4.변경 용이성/"
}, {
  "question" : "COCOMO model 중 기관 내부에서 개발된 중소 규모의 소프트웨어로 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용으로 5만 라인 이하의 소프트웨어를 개발하는 유형은?",
  "answer" : "2.organic",
  "commentary" : "5만 라인 이하의 소프트웨어를 개발하는 경우, 개발 프로세스가 자유롭고 유연하며, 개발자들 간의 의사소통이 원활하게 이루어지는 경우가 많습니다. 이러한 특징으로 인해 COCOMO 모델에서는 이 유형의 소프트웨어 개발을 \"organic\" 유형으로 분류합니다.",
  "choices" : "1.embeded/2.organic/3.semi-detached/4.semi-embeded/"
}, {
  "question" : "여러 개의 독립된 통신장치가 UWB(Ultra Wideband)기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술은?",
  "answer" : "1.PICONET",
  "commentary" : "PICONET은 UWB 또는 블루투스 기술을 사용하여 여러 개의 독립된 통신장치가 서로 통신망을 형성하는 무선 네트워크 기술입니다. 이는 하나의 마스터 장치와 최대 7개의 슬레이브 장치로 구성되며, 마스터 장치는 슬레이브 장치들을 제어하고 데이터를 전송합니다. 이러한 구성으로 인해 작은 범위 내에서 빠르고 안정적인 통신이 가능해집니다.",
  "choices" : "1.PICONET/2.SCRUM/3.NFC/4.WI-SUN/"
}, {
  "question" : "프로토타입을 지속적으로 발전시켜 최종 소프트웨어 개발까지 이르는 개발방법으로 위험관리가 중심인 소프트웨어 생명주기 모형은?",
  "answer" : "1.나선형 모형",
  "commentary" : "나선형 모형은 프로토타입을 지속적으로 발전시켜 최종 소프트웨어 개발까지 이르는 개발방법으로, 위험관리가 중심에 놓인 모형입니다. 이 모형은 초기 요구사항 수집과 분석, 위험분석, 프로토타입 개발, 테스트 및 검증, 그리고 최종 제품 개발 등의 단계를 반복적으로 수행하며, 위험을 최소화하고 품질을 향상시키는 것을 목표로 합니다. 따라서, 이 모형은 다른 모형들보다 더 유연하고 변화에 대응하기 쉬우며, 고객의 요구사항을 빠르게 반영할 수 있습니다.",
  "choices" : "1.나선형 모형/2.델파이 모형/3.폭포수 모형/4.기능점수 모형/"
}, {
  "question" : "다음이 설명하는 용어로 옳은 것은?",
  "answer" : "1.하둡(Hadoop)",
  "commentary" : "위 그림은 하둡(Hadoop) 아키텍처를 나타내고 있다. 하둡은 대용량 데이터를 분산 처리할 수 있는 오픈소스 프레임워크이다. 이를 통해 여러 대의 컴퓨터를 하나의 클러스터로 구성하여 데이터를 처리할 수 있다. 따라서 하둡은 대규모 데이터 처리에 적합하다.",
  "choices" : "1.하둡(Hadoop)/2.비컨(Beacon)/3.포스퀘어(Foursquare)/4.맴리스터(Memristor)/"
}, {
  "question" : "소인수 분해 문제를 이용한 공개키 암호화 기법에 널리 사용되는 암호 알고리즘 기법은?",
  "answer" : "1.RSA",
  "commentary" : "RSA는 소인수 분해 문제를 이용한 공개키 암호화 기법으로, 암호화와 복호화에 사용되는 두 개의 서로 다른 키를 가지고 있다. 이 중 하나는 공개키로, 누구나 알 수 있고 메시지를 암호화할 때 사용된다. 다른 하나는 개인키로, 암호화된 메시지를 복호화할 때 사용된다. RSA는 안전하고 효율적인 암호화 기법으로 널리 사용되며, 인터넷 보안 프로토콜에서도 사용된다.",
  "choices" : "1.RSA/2.ECC/3.PKI/4.PEM/"
}, {
  "question" : "LOC 기법에 의하여 예측된 총 라인수가 50000라인, 프로그래머의 월 평균 생산성이 200라인, 개발에 참여할 프로그래머가 10인 일 때, 개발 소요 기간은?",
  "answer" : "1.25개월",
  "commentary" : "개발 소요 기간 = 총 라인수 / (프로그래머 수 x 월 평균 생산성) = 50000 / (10 x 200) = 25개월 따라서 정답은 \"25개월\"이다.",
  "choices" : "1.25개월/2.50개월/3.200개월/4.2000개월/"
}, {
  "question" : "최대 홉수를 15로 제한한 라우팅 프로토콜은?",
  "answer" : "1.RIP",
  "commentary" : "최대 홉수를 15로 제한한 라우팅 프로토콜은 RIP입니다. 이는 RIP가 거리 벡터 프로토콜(Distance Vector Protocol)이기 때문입니다. 거리 벡터 프로토콜은 경로 정보를 주기적으로 교환하며, 경로 정보를 전달할 때마다 홉 수를 1씩 증가시킵니다. 이 때문에 홉 수가 일정 수준 이상 증가하면 라우팅 루프(Routing Loop)가 발생할 수 있습니다. 따라서 RIP는 최대 홉수를 15로 제한하여 라우팅 루프를 방지하고, 라우팅 테이블의 크기를 제한함으로써 네트워크의 안정성을 높이는 것입니다.",
  "choices" : "1.RIP/2.OSPF/3.Static/4.EIGRP/"
}, {
  "question" : "컴퓨터 사용자의 키보드 움직임을 탐지해 ID, 패스워드 등 개인의 중요한 정보를 몰래 빼가는 해킹 공격은?",
  "answer" : "1.Key Logger Attack",
  "commentary" : "\"Key Logger Attack\"은 컴퓨터 사용자의 키보드 움직임을 탐지해 개인의 중요한 정보를 몰래 빼가는 해킹 공격이다. 이는 키보드 입력을 가로채어 기록하는 프로그램을 설치하거나, 하드웨어적인 방법으로 키보드 입력을 감지하는 장치를 설치하여 공격한다. 따라서, 이 공격은 \"Key Logger Attack\"이라고 불린다.",
  "choices" : "1.Key Logger Attack/2.Worm/3.Rollback/4.Zombie Worm/"
}, {
  "question" : "테일러링(Tailoring) 개발 방법론의 내부 기준에 해당하지 않는 것은?",
  "answer" : "4.국제표준 품질기준",
  "commentary" : "테일러링 개발 방법론은 프로젝트의 특성에 따라 개발 방법을 조정하는 방법론이므로, \"납기/비용\", \"기술환경\", \"구성원 능력\"과 같은 내부 기준에 해당합니다. 하지만 \"국제표준 품질기준\"은 외부 기준이므로 테일러링 개발 방법론의 내부 기준에 해당하지 않습니다. 따라서 정답은 \"국제표준 품질기준\"입니다.",
  "choices" : "1.납기/비용/2.기술환경/3.구성원 능력/4.국제표준 품질기준/"
}, {
  "question" : "폭포수 모형의 특징으로 거리가 먼 것은",
  "answer" : "1.개발 중 발생한 요구사항을 쉽게 반영할 수 있다.",
  "commentary" : "폭포수 모형은 순차적인 접근방법을 이용하여 단계적 정의와 산출물이 명확하다는 특징이 있습니다. 이러한 특징으로 인해 개발 중 발생한 요구사항을 쉽게 반영할 수 있습니다. 각 단계에서 요구사항을 명확하게 정의하고 검토하며 진행하기 때문에, 개발 중에 발생한 요구사항도 해당 단계에서 적절하게 반영할 수 있습니다. 이는 모형의 적용 경험과 성공사례가 많아지도록 도와줍니다.",
  "choices" : "1.개발 중 발생한 요구사항을 쉽게 반영할 수 있다./2.순차적인 접근방법을 이용한다./3.단계적 정의와 산출물이 명확하다./4.모형의 적용 경험과 성공사례가 많다./"
}, {
  "question" : "다음 설명의 정보보안 침해 공격 관련 용어는?",
  "answer" : "4.Ransomware",
  "commentary" : "이미지에서 \"Your files are encrypted\"라는 메시지와 함께 금고 모양의 아이콘이 보이는데, 이는 파일을 암호화하고 금고 속에 보관해둔 후 해독키를 요구하는 Ransomware 공격에 대한 이미지입니다.",
  "choices" : "1.Smishing/2.C-brain/3.Trojan Horse/4.Ransomware/"
}, {
  "question" : "시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있는 보안 요소는?",
  "answer" : "4.무결성",
  "commentary" : "무결성은 시스템 내의 정보가 인가된 사용자에 의해서만 수정될 수 있도록 보호하는 보안 요소입니다. 이는 정보의 무결성을 보장하고, 불법적인 수정이나 변조를 방지하여 시스템의 신뢰성을 유지하는 데 중요한 역할을 합니다. 따라서 무결성은 시스템 보안의 핵심적인 요소 중 하나입니다.",
  "choices" : "1.기밀성/2.부인방지/3.가용성/4.무결성/"
} ]